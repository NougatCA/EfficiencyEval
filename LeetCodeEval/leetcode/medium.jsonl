{"id": "leetcode_2976", "url": "https://leetcode.com/problems/minimum-cost-to-convert-string-i/", "title": "Minimum Cost to Convert String I", "description": "You are given two **0-indexed** strings `source` and `target`, both of length `n` and consisting of **lowercase** English letters. You are also given two **0-indexed** character arrays `original` and `changed`, and an integer array `cost`, where `cost[i]` represents the cost of changing the character `original[i]` to the character `changed[i]`.\n\n\nYou start with the string `source`. In one operation, you can pick a character `x` from the string and change it to the character `y` at a cost of `z` **if** there exists **any** index `j` such that `cost[j] == z`, `original[j] == x`, and `changed[j] == y`.\n\n\nReturn *the **minimum** cost to convert the string* `source` *to the string* `target` *using **any** number of operations. If it is impossible to convert* `source` *to* `target`, *return* `-1`.\n\n\n**Note** that there may exist indices `i`, `j` such that `original[j] == original[i]` and `changed[j] == changed[i]`.", "examples": ["**Input:** source = \"abcd\", target = \"acbe\", original = [\"a\",\"b\",\"c\",\"c\",\"e\",\"d\"], changed = [\"b\",\"c\",\"b\",\"e\",\"b\",\"e\"], cost = [2,5,5,1,2,20]\n**Output:** 28\n**Explanation:** To convert the string \"abcd\" to string \"acbe\":\n- Change value at index 1 from 'b' to 'c' at a cost of 5.\n- Change value at index 2 from 'c' to 'e' at a cost of 1.\n- Change value at index 2 from 'e' to 'b' at a cost of 2.\n- Change value at index 3 from 'd' to 'e' at a cost of 20.\nThe total cost incurred is 5 + 1 + 2 + 20 = 28.\nIt can be shown that this is the minimum possible cost.", "**Input:** source = \"aaaa\", target = \"bbbb\", original = [\"a\",\"c\"], changed = [\"c\",\"b\"], cost = [1,2]\n**Output:** 12\n**Explanation:** To change the character 'a' to 'b' change the character 'a' to 'c' at a cost of 1, followed by changing the character 'c' to 'b' at a cost of 2, for a total cost of 1 + 2 = 3. To change all occurrences of 'a' to 'b', a total cost of 3 * 4 = 12 is incurred.", "**Input:** source = \"abcd\", target = \"abce\", original = [\"a\"], changed = [\"e\"], cost = [10000]\n**Output:** -1\n**Explanation:** It is impossible to convert source to target because the value at index 3 cannot be changed from 'd' to 'e'."], "constraints": "**Constraints:**\n\n\n* `1 <= source.length == target.length <= 105`\n* `source`, `target` consist of lowercase English letters.\n* `1 <= cost.length == original.length == changed.length <= 2000`\n* `original[i]`, `changed[i]` are lowercase English letters.\n* `1 <= cost[i] <= 106`\n* `original[i] != changed[i]`", "difficulty": "Medium", "tags": [], "hints": ["Construct a graph with each letter as a node, and construct an edge <code>(a, b)</code> with weight <code>c</code> if we can change from character <code>a</code> to letter <code>b</code> with cost <code>c</code>. (Keep the one with the smallest cost in case there are multiple edges between <code>a</code> and <code>b</code>).", "Calculate the shortest path for each pair of characters <code>(source[i], target[i])</code>. The sum of cost over all <code>i</code> in the range <code>[0, source.length - 1]</code>. If there is no path between <code>source[i]</code> and <code>target[i]</code>, the answer is <code>-1</code>.", "Any shortest path algorithms will work since we only have <code>26</code> nodes. Since we only have at most <code>26 * 26</code> pairs, we can save the result to avoid re-calculation.", "We can also use Floyd Warshall's algorithm to precompute all the results."], "templates": {"cpp": "class Solution {\npublic:\n    long long minimumCost(string source, string target, vector<char>& original, vector<char>& changed, vector<int>& cost) {\n        \n    }\n};", "java": "class Solution {\n    public long minimumCost(String source, String target, char[] original, char[] changed, int[] cost) {\n        \n    }\n}", "python": "class Solution(object):\n    def minimumCost(self, source, target, original, changed, cost):\n        \"\"\"\n        :type source: str\n        :type target: str\n        :type original: List[str]\n        :type changed: List[str]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        ", "c": "long long minimumCost(char* source, char* target, char* original, int originalSize, char* changed, int changedSize, int* cost, int costSize) {\n    \n}", "csharp": "public class Solution {\n    public long MinimumCost(string source, string target, char[] original, char[] changed, int[] cost) {\n        \n    }\n}", "javascript": "/**\n * @param {string} source\n * @param {string} target\n * @param {character[]} original\n * @param {character[]} changed\n * @param {number[]} cost\n * @return {number}\n */\nvar minimumCost = function(source, target, original, changed, cost) {\n    \n};", "typescript": "function minimumCost(source: string, target: string, original: string[], changed: string[], cost: number[]): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param String $source\n     * @param String $target\n     * @param String[] $original\n     * @param String[] $changed\n     * @param Integer[] $cost\n     * @return Integer\n     */\n    function minimumCost($source, $target, $original, $changed, $cost) {\n        \n    }\n}", "swift": "class Solution {\n    func minimumCost(_ source: String, _ target: String, _ original: [Character], _ changed: [Character], _ cost: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun minimumCost(source: String, target: String, original: CharArray, changed: CharArray, cost: IntArray): Long {\n        \n    }\n}", "dart": "class Solution {\n  int minimumCost(String source, String target, List<String> original, List<String> changed, List<int> cost) {\n    \n  }\n}", "golang": "func minimumCost(source string, target string, original []byte, changed []byte, cost []int) int64 {\n    \n}", "ruby": "# @param {String} source\n# @param {String} target\n# @param {Character[]} original\n# @param {Character[]} changed\n# @param {Integer[]} cost\n# @return {Integer}\ndef minimum_cost(source, target, original, changed, cost)\n    \nend", "scala": "object Solution {\n    def minimumCost(source: String, target: String, original: Array[Char], changed: Array[Char], cost: Array[Int]): Long = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn minimum_cost(source: String, target: String, original: Vec<char>, changed: Vec<char>, cost: Vec<i32>) -> i64 {\n        \n    }\n}", "racket": "(define/contract (minimum-cost source target original changed cost)\n  (-> string? string? (listof char?) (listof char?) (listof exact-integer?) exact-integer?)\n  )", "erlang": "-spec minimum_cost(Source :: unicode:unicode_binary(), Target :: unicode:unicode_binary(), Original :: [char()], Changed :: [char()], Cost :: [integer()]) -> integer().\nminimum_cost(Source, Target, Original, Changed, Cost) ->\n  .", "elixir": "defmodule Solution do\n  @spec minimum_cost(source :: String.t, target :: String.t, original :: [char], changed :: [char], cost :: [integer]) :: integer\n  def minimum_cost(source, target, original, changed, cost) do\n    \n  end\nend"}}
{"id": "leetcode_2825", "url": "https://leetcode.com/problems/make-string-a-subsequence-using-cyclic-increments/", "title": "Make String a Subsequence Using Cyclic Increments", "description": "You are given two **0-indexed** strings `str1` and `str2`.\n\n\nIn an operation, you select a **set** of indices in `str1`, and for each index `i` in the set, increment `str1[i]` to the next character **cyclically**. That is `'a'` becomes `'b'`, `'b'` becomes `'c'`, and so on, and `'z'` becomes `'a'`.\n\n\nReturn `true` *if it is possible to make* `str2` *a subsequence of* `str1` *by performing the operation **at most once***, *and* `false` *otherwise*.\n\n\n**Note:** A subsequence of a string is a new string that is formed from the original string by deleting some (possibly none) of the characters without disturbing the relative positions of the remaining characters.", "examples": ["**Input:** str1 = \"abc\", str2 = \"ad\"\n**Output:** true\n**Explanation:** Select index 2 in str1.\nIncrement str1[2] to become 'd'. \nHence, str1 becomes \"abd\" and str2 is now a subsequence. Therefore, true is returned.", "**Input:** str1 = \"zc\", str2 = \"ad\"\n**Output:** true\n**Explanation:** Select indices 0 and 1 in str1. \nIncrement str1[0] to become 'a'. \nIncrement str1[1] to become 'd'. \nHence, str1 becomes \"ad\" and str2 is now a subsequence. Therefore, true is returned.", "**Input:** str1 = \"ab\", str2 = \"d\"\n**Output:** false\n**Explanation:** In this example, it can be shown that it is impossible to make str2 a subsequence of str1 using the operation at most once. \nTherefore, false is returned."], "constraints": "**Constraints:**\n\n\n* `1 <= str1.length <= 105`\n* `1 <= str2.length <= 105`\n* `str1` and `str2` consist of only lowercase English letters.", "difficulty": "Medium", "tags": ["Two Pointers", "String"], "hints": ["<div class=\"_1l1MA\">Consider the indices we will increment separately.</div>", "<div class=\"_1l1MA\">We can maintain two pointers: pointer <code>i</code> for <code>str1</code> and pointer <code>j</code> for <code>str2</code>, while ensuring they remain within the bounds of the strings.</div>", "<div class=\"_1l1MA\">If both <code>str1[i]</code> and <code>str2[j]</code> match, or if incrementing <code>str1[i]</code> matches <code>str2[j]</code>, we increase both pointers; otherwise, we increment only pointer <code>i</code>.</div>", "<div class=\"_1l1MA\">It is possible to make <code>str2</code> a subsequence of <code>str1</code> if <code>j</code> is at the end of <code>str2</code>, after we can no longer find a match.</div>"], "templates": {"cpp": "class Solution {\npublic:\n    bool canMakeSubsequence(string str1, string str2) {\n        \n    }\n};", "java": "class Solution {\n    public boolean canMakeSubsequence(String str1, String str2) {\n        \n    }\n}", "python": "class Solution(object):\n    def canMakeSubsequence(self, str1, str2):\n        \"\"\"\n        :type str1: str\n        :type str2: str\n        :rtype: bool\n        \"\"\"\n        ", "python3": "class Solution:\n    def canMakeSubsequence(self, str1: str, str2: str) -> bool:\n        ", "c": "bool canMakeSubsequence(char * str1, char * str2){\n\n}", "csharp": "public class Solution {\n    public bool CanMakeSubsequence(string str1, string str2) {\n        \n    }\n}", "javascript": "/**\n * @param {string} str1\n * @param {string} str2\n * @return {boolean}\n */\nvar canMakeSubsequence = function(str1, str2) {\n    \n};", "typescript": "function canMakeSubsequence(str1: string, str2: string): boolean {\n\n};", "php": "class Solution {\n\n    /**\n     * @param String $str1\n     * @param String $str2\n     * @return Boolean\n     */\n    function canMakeSubsequence($str1, $str2) {\n        \n    }\n}", "swift": "class Solution {\n    func canMakeSubsequence(_ str1: String, _ str2: String) -> Bool {\n        \n    }\n}", "kotlin": "class Solution {\n    fun canMakeSubsequence(str1: String, str2: String): Boolean {\n        \n    }\n}", "dart": "class Solution {\n  bool canMakeSubsequence(String str1, String str2) {\n\n  }\n}", "golang": "func canMakeSubsequence(str1 string, str2 string) bool {\n    \n}", "ruby": "# @param {String} str1\n# @param {String} str2\n# @return {Boolean}\ndef can_make_subsequence(str1, str2)\n    \nend", "scala": "object Solution {\n    def canMakeSubsequence(str1: String, str2: String): Boolean = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn can_make_subsequence(str1: String, str2: String) -> bool {\n        \n    }\n}", "racket": "(define/contract (can-make-subsequence str1 str2)\n  (-> string? string? boolean?)\n\n  )", "erlang": "-spec can_make_subsequence(Str1 :: unicode:unicode_binary(), Str2 :: unicode:unicode_binary()) -> boolean().\ncan_make_subsequence(Str1, Str2) ->\n  .", "elixir": "defmodule Solution do\n  @spec can_make_subsequence(str1 :: String.t, str2 :: String.t) :: boolean\n  def can_make_subsequence(str1, str2) do\n\n  end\nend"}}
{"id": "leetcode_2761", "url": "https://leetcode.com/problems/prime-pairs-with-target-sum/", "title": "Prime Pairs With Target Sum", "description": "You are given an integer `n`. We say that two integers `x` and `y` form a prime number pair if:\n\n\n* `1 <= x <= y <= n`\n* `x + y == n`\n* `x` and `y` are prime numbers\n\n\nReturn *the 2D sorted list of prime number pairs* `[xi, yi]`. The list should be sorted in **increasing** order of `xi`. If there are no prime number pairs at all, return *an empty array*.\n\n\n**Note:** A prime number is a natural number greater than `1` with only two factors, itself and `1`.", "examples": ["**Input:** n = 10\n**Output:** [[3,7],[5,5]]\n**Explanation:** In this example, there are two prime pairs that satisfy the criteria. \nThese pairs are [3,7] and [5,5], and we return them in the sorted order as described in the problem statement.", "**Input:** n = 2\n**Output:** []\n**Explanation:** We can show that there is no prime number pair that gives a sum of 2, so we return an empty array."], "constraints": "**Constraints:**\n\n\n* `1 <= n <= 106`", "difficulty": "Medium", "tags": ["Array", "Math", "Enumeration", "Number Theory"], "hints": ["Pre-compute all the prime numbers in the range [1, n] using a sieve, and store them in a data structure where they can be accessed in O(1) time.", "For x in the range [2, n/2], we can use the pre-computed list of prime numbers to check if both x and n - x are primes. If they are, we add them to the result."], "templates": {"cpp": "class Solution {\npublic:\n    vector<vector<int>> findPrimePairs(int n) {\n        \n    }\n};", "java": "class Solution {\n    public List<List<Integer>> findPrimePairs(int n) {\n        \n    }\n}", "python": "class Solution(object):\n    def findPrimePairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        ", "python3": "class Solution:\n    def findPrimePairs(self, n: int) -> List[List[int]]:\n        ", "c": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** findPrimePairs(int n, int* returnSize, int** returnColumnSizes){\n\n}", "csharp": "public class Solution {\n    public IList<IList<int>> FindPrimePairs(int n) {\n        \n    }\n}", "javascript": "/**\n * @param {number} n\n * @return {number[][]}\n */\nvar findPrimePairs = function(n) {\n    \n};", "typescript": "function findPrimePairs(n: number): number[][] {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return Integer[][]\n     */\n    function findPrimePairs($n) {\n        \n    }\n}", "swift": "class Solution {\n    func findPrimePairs(_ n: Int) -> [[Int]] {\n        \n    }\n}", "kotlin": "class Solution {\n    fun findPrimePairs(n: Int): List<List<Int>> {\n        \n    }\n}", "dart": "class Solution {\n  List<List<int>> findPrimePairs(int n) {\n\n  }\n}", "golang": "func findPrimePairs(n int) [][]int {\n    \n}", "ruby": "# @param {Integer} n\n# @return {Integer[][]}\ndef find_prime_pairs(n)\n    \nend", "scala": "object Solution {\n    def findPrimePairs(n: Int): List[List[Int]] = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn find_prime_pairs(n: i32) -> Vec<Vec<i32>> {\n        \n    }\n}", "racket": "(define/contract (find-prime-pairs n)\n  (-> exact-integer? (listof (listof exact-integer?)))\n\n  )", "erlang": "-spec find_prime_pairs(N :: integer()) -> [[integer()]].\nfind_prime_pairs(N) ->\n  .", "elixir": "defmodule Solution do\n  @spec find_prime_pairs(n :: integer) :: [[integer]]\n  def find_prime_pairs(n) do\n\n  end\nend"}}
{"id": "leetcode_2741", "url": "https://leetcode.com/problems/special-permutations/", "title": "Special Permutations", "description": "You are given a\u00a0**0-indexed**\u00a0integer array\u00a0`nums`\u00a0containing\u00a0`n`\u00a0**distinct** positive integers. A permutation of\u00a0`nums`\u00a0is called special if:\n\n\n* For all indexes\u00a0`0 <= i < n - 1`, either\u00a0`nums[i] % nums[i+1] == 0`\u00a0or\u00a0`nums[i+1] % nums[i] == 0`.\n\n\nReturn\u00a0*the total number of special permutations.*As the answer could be large, return it\u00a0**modulo**`109+ 7`.", "examples": ["**Input:** nums = [2,3,6]\n**Output:** 2\n**Explanation:** [3,6,2] and [2,6,3] are the two special permutations of nums.", "**Input:** nums = [1,4,3]\n**Output:** 2\n**Explanation:** [3,1,4] and [4,1,3] are the two special permutations of nums."], "constraints": "**Constraints:**\n\n\n* `2 <= nums.length <= 14`\n* `1 <= nums[i] <= 109`", "difficulty": "Medium", "tags": ["Array", "Dynamic Programming", "Bit Manipulation", "Bitmask"], "hints": ["Can we solve this problem using DP with bit masking?", "You just need two states in DP which are last_ind in the permutation and the mask of numbers already used."], "templates": {"cpp": "class Solution {\npublic:\n    int specialPerm(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public int specialPerm(int[] nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def specialPerm(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def specialPerm(self, nums: List[int]) -> int:\n        ", "c": "int specialPerm(int* nums, int numsSize){\n\n}", "csharp": "public class Solution {\n    public int SpecialPerm(int[] nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar specialPerm = function(nums) {\n    \n};", "typescript": "function specialPerm(nums: number[]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function specialPerm($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func specialPerm(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun specialPerm(nums: IntArray): Int {\n        \n    }\n}", "dart": "class Solution {\n  int specialPerm(List<int> nums) {\n\n  }\n}", "golang": "func specialPerm(nums []int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef special_perm(nums)\n    \nend", "scala": "object Solution {\n    def specialPerm(nums: Array[Int]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn special_perm(nums: Vec<i32>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (special-perm nums)\n  (-> (listof exact-integer?) exact-integer?)\n\n  )", "erlang": "-spec special_perm(Nums :: [integer()]) -> integer().\nspecial_perm(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec special_perm(nums :: [integer]) :: integer\n  def special_perm(nums) do\n\n  end\nend"}}
{"id": "leetcode_2829", "url": "https://leetcode.com/problems/determine-the-minimum-sum-of-a-k-avoiding-array/", "title": "Determine the Minimum Sum of a k-avoiding Array", "description": "You are given two integers,\u00a0`n` and `k`.\n\n\nAn array of **distinct** positive integers is called a **k-avoiding** array if there does not exist any pair of distinct elements that sum to `k`.\n\n\nReturn *the **minimum** possible sum of a k-avoiding array of length* `n`.", "examples": ["**Input:** n = 5, k = 4\n**Output:** 18\n**Explanation:** Consider the k-avoiding array [1,2,4,5,6], which has a sum of 18.\nIt can be proven that there is no k-avoiding array with a sum less than 18.", "**Input:** n = 2, k = 6\n**Output:** 3\n**Explanation:** We can construct the array [1,2], which has a sum of 3.\nIt can be proven that there is no k-avoiding array with a sum less than 3."], "constraints": "**Constraints:**\n\n\n* `1 <= n, k <= 50`", "difficulty": "Medium", "tags": ["Math", "Greedy"], "hints": ["<div class=\"_1l1MA\">Try to start with the smallest possible integers.</div>", "<div class=\"_1l1MA\">Check if the current number can be added to the array.</div>", "<div class=\"_1l1MA\">To check if the current number can be added, keep track of already added numbers in a set.</div>", "<div class=\"_1l1MA\">If the number <code>i</code> is added to the array, then <code>i + k</code> can not be added.</div>"], "templates": {"cpp": "class Solution {\npublic:\n    int minimumSum(int n, int k) {\n        \n    }\n};", "java": "class Solution {\n    public int minimumSum(int n, int k) {\n        \n    }\n}", "python": "class Solution(object):\n    def minimumSum(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def minimumSum(self, n: int, k: int) -> int:\n        ", "c": "int minimumSum(int n, int k){\n\n}", "csharp": "public class Solution {\n    public int MinimumSum(int n, int k) {\n        \n    }\n}", "javascript": "/**\n * @param {number} n\n * @param {number} k\n * @return {number}\n */\nvar minimumSum = function(n, k) {\n    \n};", "typescript": "function minimumSum(n: number, k: number): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer $k\n     * @return Integer\n     */\n    function minimumSum($n, $k) {\n        \n    }\n}", "swift": "class Solution {\n    func minimumSum(_ n: Int, _ k: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun minimumSum(n: Int, k: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int minimumSum(int n, int k) {\n\n  }\n}", "golang": "func minimumSum(n int, k int) int {\n    \n}", "ruby": "# @param {Integer} n\n# @param {Integer} k\n# @return {Integer}\ndef minimum_sum(n, k)\n    \nend", "scala": "object Solution {\n    def minimumSum(n: Int, k: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn minimum_sum(n: i32, k: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (minimum-sum n k)\n  (-> exact-integer? exact-integer? exact-integer?)\n\n  )", "erlang": "-spec minimum_sum(N :: integer(), K :: integer()) -> integer().\nminimum_sum(N, K) ->\n  .", "elixir": "defmodule Solution do\n  @spec minimum_sum(n :: integer, k :: integer) :: integer\n  def minimum_sum(n, k) do\n\n  end\nend"}}
{"id": "leetcode_2901", "url": "https://leetcode.com/problems/longest-unequal-adjacent-groups-subsequence-ii/", "title": "Longest Unequal Adjacent Groups Subsequence II", "description": "You are given an integer `n`, a **0-indexed** string array `words`, and a **0-indexed** array `groups`, both arrays having length `n`.\n\n\nThe **hamming distance** between two strings of equal length is the number of positions at which the corresponding characters are **different**.\n\n\nYou need to select the **longest** **subsequence** from an array of indices `[0, 1, ..., n - 1]`, such that for the subsequence denoted as `[i0, i1, ..., ik - 1]` having length `k`, the following holds:\n\n\n* For **adjacent** indices in the subsequence, their corresponding groups are **unequal**, i.e., `groups[ij] != groups[ij + 1]`, for each `j` where `0 < j + 1 < k`.\n* `words[ij]` and `words[ij + 1]` are **equal** in length, and the **hamming distance** between them is `1`, where `0 < j + 1 < k`, for all indices in the subsequence.\n\n\nReturn *a string array containing the words corresponding to the indices **(in order)** in the selected subsequence*. If there are multiple answers, return *any of them*.\n\n\nA **subsequence** of an array is a new array that is formed from the original array by deleting some (possibly none) of the elements without disturbing the relative positions of the remaining elements.\n\n\n**Note:** strings in `words` may be **unequal** in length.", "examples": ["**Input:** n = 3, words = [\"bab\",\"dab\",\"cab\"], groups = [1,2,2]\n**Output:** [\"bab\",\"cab\"]\n**Explanation:** A subsequence that can be selected is [0,2].\n- groups[0] != groups[2]\n- words[0].length == words[2].length, and the hamming distance between them is 1.\nSo, a valid answer is [words[0],words[2]] = [\"bab\",\"cab\"].\nAnother subsequence that can be selected is [0,1].\n- groups[0] != groups[1]\n- words[0].length == words[1].length, and the hamming distance between them is 1.\nSo, another valid answer is [words[0],words[1]] = [\"bab\",\"dab\"].\nIt can be shown that the length of the longest subsequence of indices that satisfies the conditions is 2.", "**Input:** n = 4, words = [\"a\",\"b\",\"c\",\"d\"], groups = [1,2,3,4]\n**Output:** [\"a\",\"b\",\"c\",\"d\"]\n**Explanation:** We can select the subsequence [0,1,2,3].\nIt satisfies both conditions.\nHence, the answer is [words[0],words[1],words[2],words[3]] = [\"a\",\"b\",\"c\",\"d\"].\nIt has the longest length among all subsequences of indices that satisfy the conditions.\nHence, it is the only answer."], "constraints": "**Constraints:**\n\n\n* `1 <= n == words.length == groups.length <= 1000`\n* `1 <= words[i].length <= 10`\n* `1 <= groups[i] <= n`\n* `words` consists of **distinct** strings.\n* `words[i]` consists of lowercase English letters.", "difficulty": "Medium", "tags": ["Array", "String", "Dynamic Programming"], "hints": ["Let <code>dp[i]</code> represent the length of the longest subsequence ending with <code>words[i]</code> that satisfies the conditions.", "<code>dp[i] =</code> (maximum value of <code>dp[j]</code>) <code>+ 1</code> for indices <code>j < i</code>, where <code>groups[i] != groups[j]</code>, <code>words[i]</code> and <code>words[j]</code> are equal in length, and the hamming distance between <code>words[i]</code> and <code>words[j]</code> is exactly <code>1</code>.", "Keep track of the <code>j</code> values used to achieve the maximum <code>dp[i]</code> for each index <code>i</code>.", "The expected array's length is <code>max(dp[0:n])</code>, and starting from the index having the maximum value in <code>dp</code>, we can trace backward to get the words."], "templates": {"cpp": "class Solution {\npublic:\n    vector<string> getWordsInLongestSubsequence(int n, vector<string>& words, vector<int>& groups) {\n        \n    }\n};", "java": "class Solution {\n    public List<String> getWordsInLongestSubsequence(int n, String[] words, int[] groups) {\n        \n    }\n}", "python": "class Solution(object):\n    def getWordsInLongestSubsequence(self, n, words, groups):\n        \"\"\"\n        :type n: int\n        :type words: List[str]\n        :type groups: List[int]\n        :rtype: List[str]\n        \"\"\"\n        ", "python3": "class Solution:\n    def getWordsInLongestSubsequence(self, n: int, words: List[str], groups: List[int]) -> List[str]:\n        ", "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar** getWordsInLongestSubsequence(int n, char** words, int wordsSize, int* groups, int groupsSize, int* returnSize){\n\n}", "csharp": "public class Solution {\n    public IList<string> GetWordsInLongestSubsequence(int n, string[] words, int[] groups) {\n        \n    }\n}", "javascript": "/**\n * @param {number} n\n * @param {string[]} words\n * @param {number[]} groups\n * @return {string[]}\n */\nvar getWordsInLongestSubsequence = function(n, words, groups) {\n    \n};", "typescript": "function getWordsInLongestSubsequence(n: number, words: string[], groups: number[]): string[] {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param String[] $words\n     * @param Integer[] $groups\n     * @return String[]\n     */\n    function getWordsInLongestSubsequence($n, $words, $groups) {\n        \n    }\n}", "swift": "class Solution {\n    func getWordsInLongestSubsequence(_ n: Int, _ words: [String], _ groups: [Int]) -> [String] {\n        \n    }\n}", "kotlin": "class Solution {\n    fun getWordsInLongestSubsequence(n: Int, words: Array<String>, groups: IntArray): List<String> {\n        \n    }\n}", "dart": "class Solution {\n  List<String> getWordsInLongestSubsequence(int n, List<String> words, List<int> groups) {\n\n  }\n}", "golang": "func getWordsInLongestSubsequence(n int, words []string, groups []int) []string {\n    \n}", "ruby": "# @param {Integer} n\n# @param {String[]} words\n# @param {Integer[]} groups\n# @return {String[]}\ndef get_words_in_longest_subsequence(n, words, groups)\n    \nend", "scala": "object Solution {\n    def getWordsInLongestSubsequence(n: Int, words: Array[String], groups: Array[Int]): List[String] = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn get_words_in_longest_subsequence(n: i32, words: Vec<String>, groups: Vec<i32>) -> Vec<String> {\n        \n    }\n}", "racket": "(define/contract (get-words-in-longest-subsequence n words groups)\n  (-> exact-integer? (listof string?) (listof exact-integer?) (listof string?))\n\n  )", "erlang": "-spec get_words_in_longest_subsequence(N :: integer(), Words :: [unicode:unicode_binary()], Groups :: [integer()]) -> [unicode:unicode_binary()].\nget_words_in_longest_subsequence(N, Words, Groups) ->\n  .", "elixir": "defmodule Solution do\n  @spec get_words_in_longest_subsequence(n :: integer, words :: [String.t], groups :: [integer]) :: [String.t]\n  def get_words_in_longest_subsequence(n, words, groups) do\n\n  end\nend"}}
{"id": "leetcode_2844", "url": "https://leetcode.com/problems/minimum-operations-to-make-a-special-number/", "title": "Minimum Operations to Make a Special Number", "description": "You are given a **0-indexed** string `num` representing a non-negative integer.\n\n\nIn one operation, you can pick any digit of `num` and delete it. Note that if you delete all the digits of `num`, `num` becomes `0`.\n\n\nReturn *the **minimum number of operations** required to make* `num` *special*.\n\n\nAn integer `x` is considered **special** if it is divisible by `25`.", "examples": ["**Input:** num = \"2245047\"\n**Output:** 2\n**Explanation:** Delete digits num[5] and num[6]. The resulting number is \"22450\" which is special since it is divisible by 25.\nIt can be shown that 2 is the minimum number of operations required to get a special number.", "**Input:** num = \"2908305\"\n**Output:** 3\n**Explanation:** Delete digits num[3], num[4], and num[6]. The resulting number is \"2900\" which is special since it is divisible by 25.\nIt can be shown that 3 is the minimum number of operations required to get a special number.", "**Input:** num = \"10\"\n**Output:** 1\n**Explanation:** Delete digit num[0]. The resulting number is \"0\" which is special since it is divisible by 25.\nIt can be shown that 1 is the minimum number of operations required to get a special number."], "constraints": "**Constraints:**\n\n\n* `1 <= num.length <= 100`\n* `num` only consists of digits `'0'` through `'9'`.\n* `num` does not contain any leading zeros.", "difficulty": "Medium", "tags": ["Math", "String", "Greedy", "Enumeration"], "hints": ["If <code>num</code> contains a single zero digit then the answer is at most <code>n - 1</code>.", "A number is divisible by <code>25</code> if its last two digits are <code>75</code>, <code>50</code>, <code>25</code>, or <code>00</code>.", "Iterate over all possible pairs of indices <code>i &lt; j</code> such that <code>num[i] * 10 + num[j]</code> is in <code>[00,25,50,75]</code>. Then, set the answer to <code> min(answer, n - i - 2) </code>."], "templates": {"cpp": "class Solution {\npublic:\n    int minimumOperations(string num) {\n        \n    }\n};", "java": "class Solution {\n    public int minimumOperations(String num) {\n        \n    }\n}", "python": "class Solution(object):\n    def minimumOperations(self, num):\n        \"\"\"\n        :type num: str\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def minimumOperations(self, num: str) -> int:\n        ", "c": "int minimumOperations(char* num){\n\n}", "csharp": "public class Solution {\n    public int MinimumOperations(string num) {\n        \n    }\n}", "javascript": "/**\n * @param {string} num\n * @return {number}\n */\nvar minimumOperations = function(num) {\n    \n};", "typescript": "function minimumOperations(num: string): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param String $num\n     * @return Integer\n     */\n    function minimumOperations($num) {\n        \n    }\n}", "swift": "class Solution {\n    func minimumOperations(_ num: String) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun minimumOperations(num: String): Int {\n        \n    }\n}", "dart": "class Solution {\n  int minimumOperations(String num) {\n\n  }\n}", "golang": "func minimumOperations(num string) int {\n    \n}", "ruby": "# @param {String} num\n# @return {Integer}\ndef minimum_operations(num)\n    \nend", "scala": "object Solution {\n    def minimumOperations(num: String): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn minimum_operations(num: String) -> i32 {\n        \n    }\n}", "racket": "(define/contract (minimum-operations num)\n  (-> string? exact-integer?)\n\n  )", "erlang": "-spec minimum_operations(Num :: unicode:unicode_binary()) -> integer().\nminimum_operations(Num) ->\n  .", "elixir": "defmodule Solution do\n  @spec minimum_operations(num :: String.t) :: integer\n  def minimum_operations(num) do\n\n  end\nend"}}
{"id": "leetcode_2900", "url": "https://leetcode.com/problems/longest-unequal-adjacent-groups-subsequence-i/", "title": "Longest Unequal Adjacent Groups Subsequence I", "description": "You are given an integer `n`, a **0-indexed** string array `words`, and a **0-indexed** **binary** array `groups`, both arrays having length `n`.\n\n\nYou need to select the **longest** **subsequence** from an array of indices `[0, 1, ..., n - 1]`, such that for the subsequence denoted as `[i0, i1, ..., ik - 1]` having length `k`, `groups[ij] != groups[ij + 1]`, for each `j` where `0 < j + 1 < k`.\n\n\nReturn *a string array containing the words corresponding to the indices **(in order)** in the selected subsequence*. If there are multiple answers, return *any of them*.\n\n\nA **subsequence** of an array is a new array that is formed from the original array by deleting some (possibly none) of the elements without disturbing the relative positions of the remaining elements.\n\n\n**Note:** strings in `words` may be **unequal** in length.", "examples": ["**Input:** n = 3, words = [\"e\",\"a\",\"b\"], groups = [0,0,1]\n**Output:** [\"e\",\"b\"]\n**Explanation:** A subsequence that can be selected is [0,2] because groups[0] != groups[2].\nSo, a valid answer is [words[0],words[2]] = [\"e\",\"b\"].\nAnother subsequence that can be selected is [1,2] because groups[1] != groups[2].\nThis results in [words[1],words[2]] = [\"a\",\"b\"].\nIt is also a valid answer.\nIt can be shown that the length of the longest subsequence of indices that satisfies the condition is 2.", "**Input:** n = 4, words = [\"a\",\"b\",\"c\",\"d\"], groups = [1,0,1,1]\n**Output:** [\"a\",\"b\",\"c\"]\n**Explanation:** A subsequence that can be selected is [0,1,2] because groups[0] != groups[1] and groups[1] != groups[2].\nSo, a valid answer is [words[0],words[1],words[2]] = [\"a\",\"b\",\"c\"].\nAnother subsequence that can be selected is [0,1,3] because groups[0] != groups[1] and groups[1] != groups[3].\nThis results in [words[0],words[1],words[3]] = [\"a\",\"b\",\"d\"].\nIt is also a valid answer.\nIt can be shown that the length of the longest subsequence of indices that satisfies the condition is 3."], "constraints": "**Constraints:**\n\n\n* `1 <= n == words.length == groups.length <= 100`\n* `1 <= words[i].length <= 10`\n* `0 <= groups[i] < 2`\n* `words` consists of **distinct** strings.\n* `words[i]` consists of lowercase English letters.", "difficulty": "Medium", "tags": ["Array", "String", "Dynamic Programming", "Greedy"], "hints": ["This problem can be solved greedily.", "Begin by constructing the answer starting with the first word in <code>words</code>.", "For each index <code>i</code> in the range <code>[1, n - 1]</code>, add <code>words[i]</code> to the answer if <code>groups[i] != groups[i - 1]</code>."], "templates": {"cpp": "class Solution {\npublic:\n    vector<string> getWordsInLongestSubsequence(int n, vector<string>& words, vector<int>& groups) {\n        \n    }\n};", "java": "class Solution {\n    public List<String> getWordsInLongestSubsequence(int n, String[] words, int[] groups) {\n        \n    }\n}", "python": "class Solution(object):\n    def getWordsInLongestSubsequence(self, n, words, groups):\n        \"\"\"\n        :type n: int\n        :type words: List[str]\n        :type groups: List[int]\n        :rtype: List[str]\n        \"\"\"\n        ", "python3": "class Solution:\n    def getWordsInLongestSubsequence(self, n: int, words: List[str], groups: List[int]) -> List[str]:\n        ", "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar** getWordsInLongestSubsequence(int n, char** words, int wordsSize, int* groups, int groupsSize, int* returnSize){\n\n}", "csharp": "public class Solution {\n    public IList<string> GetWordsInLongestSubsequence(int n, string[] words, int[] groups) {\n        \n    }\n}", "javascript": "/**\n * @param {number} n\n * @param {string[]} words\n * @param {number[]} groups\n * @return {string[]}\n */\nvar getWordsInLongestSubsequence = function(n, words, groups) {\n    \n};", "typescript": "function getWordsInLongestSubsequence(n: number, words: string[], groups: number[]): string[] {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param String[] $words\n     * @param Integer[] $groups\n     * @return String[]\n     */\n    function getWordsInLongestSubsequence($n, $words, $groups) {\n        \n    }\n}", "swift": "class Solution {\n    func getWordsInLongestSubsequence(_ n: Int, _ words: [String], _ groups: [Int]) -> [String] {\n        \n    }\n}", "kotlin": "class Solution {\n    fun getWordsInLongestSubsequence(n: Int, words: Array<String>, groups: IntArray): List<String> {\n        \n    }\n}", "dart": "class Solution {\n  List<String> getWordsInLongestSubsequence(int n, List<String> words, List<int> groups) {\n\n  }\n}", "golang": "func getWordsInLongestSubsequence(n int, words []string, groups []int) []string {\n    \n}", "ruby": "# @param {Integer} n\n# @param {String[]} words\n# @param {Integer[]} groups\n# @return {String[]}\ndef get_words_in_longest_subsequence(n, words, groups)\n    \nend", "scala": "object Solution {\n    def getWordsInLongestSubsequence(n: Int, words: Array[String], groups: Array[Int]): List[String] = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn get_words_in_longest_subsequence(n: i32, words: Vec<String>, groups: Vec<i32>) -> Vec<String> {\n        \n    }\n}", "racket": "(define/contract (get-words-in-longest-subsequence n words groups)\n  (-> exact-integer? (listof string?) (listof exact-integer?) (listof string?))\n\n  )", "erlang": "-spec get_words_in_longest_subsequence(N :: integer(), Words :: [unicode:unicode_binary()], Groups :: [integer()]) -> [unicode:unicode_binary()].\nget_words_in_longest_subsequence(N, Words, Groups) ->\n  .", "elixir": "defmodule Solution do\n  @spec get_words_in_longest_subsequence(n :: integer, words :: [String.t], groups :: [integer]) :: [String.t]\n  def get_words_in_longest_subsequence(n, words, groups) do\n\n  end\nend"}}
{"id": "leetcode_2845", "url": "https://leetcode.com/problems/count-of-interesting-subarrays/", "title": "Count of Interesting Subarrays", "description": "You are given a **0-indexed** integer array `nums`, an integer `modulo`, and an integer `k`.\n\n\nYour task is to find the count of subarrays that are **interesting**.\n\n\nA **subarray** `nums[l..r]` is **interesting** if the following condition holds:\n\n\n* Let `cnt` be the number of indices `i` in the range `[l, r]` such that `nums[i] % modulo == k`. Then, `cnt % modulo == k`.\n\n\nReturn *an integer denoting the count of interesting subarrays.* \n\n\n**Note:** A subarray is *a contiguous non-empty sequence of elements within an array*.", "examples": ["**Input:** nums = [3,2,4], modulo = 2, k = 1\n**Output:** 3\n**Explanation:** In this example the interesting subarrays are: \nThe subarray nums[0..0] which is [3]. \n- There is only one index, i = 0, in the range [0, 0] that satisfies nums[i] % modulo == k. \n- Hence, cnt = 1 and cnt % modulo == k.  \nThe subarray nums[0..1] which is [3,2].\n- There is only one index, i = 0, in the range [0, 1] that satisfies nums[i] % modulo == k.  \n- Hence, cnt = 1 and cnt % modulo == k.\nThe subarray nums[0..2] which is [3,2,4]. \n- There is only one index, i = 0, in the range [0, 2] that satisfies nums[i] % modulo == k. \n- Hence, cnt = 1 and cnt % modulo == k. \nIt can be shown that there are no other interesting subarrays. So, the answer is 3.", "**Input:** nums = [3,1,9,6], modulo = 3, k = 0\n**Output:** 2\n**Explanation:** In this example the interesting subarrays are: \nThe subarray nums[0..3] which is [3,1,9,6]. \n- There are three indices, i = 0, 2, 3, in the range [0, 3] that satisfy nums[i] % modulo == k. \n- Hence, cnt = 3 and cnt % modulo == k. \nThe subarray nums[1..1] which is [1]. \n- There is no index, i, in the range [1, 1] that satisfies nums[i] % modulo == k. \n- Hence, cnt = 0 and cnt % modulo == k. \nIt can be shown that there are no other interesting subarrays. So, the answer is 2."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `1 <= nums[i] <= 109`\n* `1 <= modulo <= 109`\n* `0 <= k < modulo`", "difficulty": "Medium", "tags": ["Array", "Hash Table", "Prefix Sum"], "hints": ["The problem can be solved using prefix sums.", "Let <code>count[i]</code> be the number of indices where <code>nums[i] % modulo == k</code> among the first <code>i</code> indices.", "<code>count[0] = 0</code> and <code>count[i] = count[i - 1] + (nums[i - 1] % modulo == k ? 1 : 0)</code> for <code>i = 1, 2, ..., n</code>.", "Now we want to calculate for each <code>i = 1, 2, ..., n</code>, how many indices <code>j < i</code> such that <code>(count[i] - count[j]) % modulo == k</code>.", "Rewriting <code>(count[i] - count[j]) % modulo == k</code> becomes <code>count[j] = (count[i] + modulo - k) % modulo</code>.", "Using a map data structure, for each <code>i = 0, 1, 2, ..., n</code>, we just sum up all <code>map[(count[i] + modulo - k) % modulo]</code> before increasing <code>map[count[i] % modulo]</code>, and the total sum is the final answer."], "templates": {"cpp": "class Solution {\npublic:\n    long long countInterestingSubarrays(vector<int>& nums, int modulo, int k) {\n        \n    }\n};", "java": "class Solution {\n    public long countInterestingSubarrays(List<Integer> nums, int modulo, int k) {\n        \n    }\n}", "python": "class Solution(object):\n    def countInterestingSubarrays(self, nums, modulo, k):\n        \"\"\"\n        :type nums: List[int]\n        :type modulo: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def countInterestingSubarrays(self, nums: List[int], modulo: int, k: int) -> int:\n        ", "c": "long long countInterestingSubarrays(int* nums, int numsSize, int modulo, int k){\n\n}", "csharp": "public class Solution {\n    public long CountInterestingSubarrays(IList<int> nums, int modulo, int k) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @param {number} modulo\n * @param {number} k\n * @return {number}\n */\nvar countInterestingSubarrays = function(nums, modulo, k) {\n    \n};", "typescript": "function countInterestingSubarrays(nums: number[], modulo: number, k: number): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $modulo\n     * @param Integer $k\n     * @return Integer\n     */\n    function countInterestingSubarrays($nums, $modulo, $k) {\n        \n    }\n}", "swift": "class Solution {\n    func countInterestingSubarrays(_ nums: [Int], _ modulo: Int, _ k: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun countInterestingSubarrays(nums: List<Int>, modulo: Int, k: Int): Long {\n        \n    }\n}", "dart": "class Solution {\n  int countInterestingSubarrays(List<int> nums, int modulo, int k) {\n\n  }\n}", "golang": "func countInterestingSubarrays(nums []int, modulo int, k int) int64 {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @param {Integer} modulo\n# @param {Integer} k\n# @return {Integer}\ndef count_interesting_subarrays(nums, modulo, k)\n    \nend", "scala": "object Solution {\n    def countInterestingSubarrays(nums: List[Int], modulo: Int, k: Int): Long = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn count_interesting_subarrays(nums: Vec<i32>, modulo: i32, k: i32) -> i64 {\n        \n    }\n}", "racket": "(define/contract (count-interesting-subarrays nums modulo k)\n  (-> (listof exact-integer?) exact-integer? exact-integer? exact-integer?)\n\n  )", "erlang": "-spec count_interesting_subarrays(Nums :: [integer()], Modulo :: integer(), K :: integer()) -> integer().\ncount_interesting_subarrays(Nums, Modulo, K) ->\n  .", "elixir": "defmodule Solution do\n  @spec count_interesting_subarrays(nums :: [integer], modulo :: integer, k :: integer) :: integer\n  def count_interesting_subarrays(nums, modulo, k) do\n\n  end\nend"}}
{"id": "leetcode_2957", "url": "https://leetcode.com/problems/remove-adjacent-almost-equal-characters/", "title": "Remove Adjacent Almost-Equal Characters", "description": "You are given a **0-indexed** string `word`.\n\n\nIn one operation, you can pick any index `i` of `word` and change `word[i]` to any lowercase English letter.\n\n\nReturn *the **minimum** number of operations needed to remove all adjacent **almost-equal** characters from* `word`.\n\n\nTwo characters `a` and `b` are **almost-equal** if `a == b` or `a` and `b` are adjacent in the alphabet.", "examples": ["**Input:** word = \"aaaaa\"\n**Output:** 2\n**Explanation:** We can change word into \"a**c**a**c**a\" which does not have any adjacent almost-equal characters.\nIt can be shown that the minimum number of operations needed to remove all adjacent almost-equal characters from word is 2.", "**Input:** word = \"abddez\"\n**Output:** 2\n**Explanation:** We can change word into \"**y**bd**o**ez\" which does not have any adjacent almost-equal characters.\nIt can be shown that the minimum number of operations needed to remove all adjacent almost-equal characters from word is 2.", "**Input:** word = \"zyxyxyz\"\n**Output:** 3\n**Explanation:** We can change word into \"z**a**x**a**x**a**z\" which does not have any adjacent almost-equal characters. \nIt can be shown that the minimum number of operations needed to remove all adjacent almost-equal characters from word is 3."], "constraints": "**Constraints:**\n\n\n* `1 <= word.length <= 100`\n* `word` consists only of lowercase English letters.", "difficulty": "Medium", "tags": ["String", "Dynamic Programming", "Greedy"], "hints": ["For <code>i > 0</code>, if <code>word[i]</code> and <code>word[i - 1]</code> are adjacent, we will change <code>word[i]</code> to another character. Which character should we change it to?", "We will change <code>word[i]</code> to some character that is not adjacent to <code>word[i - 1]</code> nor <code>word[i + 1]</code> (if it exists). Such a character always exists. However, since the problem does not ask for the final state of the string, It is enough to prove that the character exists and we do not need to find it."], "templates": {"cpp": "class Solution {\npublic:\n    int removeAlmostEqualCharacters(string word) {\n        \n    }\n};", "java": "class Solution {\n    public int removeAlmostEqualCharacters(String word) {\n        \n    }\n}", "python": "class Solution(object):\n    def removeAlmostEqualCharacters(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def removeAlmostEqualCharacters(self, word: str) -> int:\n        ", "c": "int removeAlmostEqualCharacters(char* word) {\n    \n}", "csharp": "public class Solution {\n    public int RemoveAlmostEqualCharacters(string word) {\n        \n    }\n}", "javascript": "/**\n * @param {string} word\n * @return {number}\n */\nvar removeAlmostEqualCharacters = function(word) {\n    \n};", "typescript": "function removeAlmostEqualCharacters(word: string): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param String $word\n     * @return Integer\n     */\n    function removeAlmostEqualCharacters($word) {\n        \n    }\n}", "swift": "class Solution {\n    func removeAlmostEqualCharacters(_ word: String) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun removeAlmostEqualCharacters(word: String): Int {\n        \n    }\n}", "dart": "class Solution {\n  int removeAlmostEqualCharacters(String word) {\n    \n  }\n}", "golang": "func removeAlmostEqualCharacters(word string) int {\n    \n}", "ruby": "# @param {String} word\n# @return {Integer}\ndef remove_almost_equal_characters(word)\n    \nend", "scala": "object Solution {\n    def removeAlmostEqualCharacters(word: String): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn remove_almost_equal_characters(word: String) -> i32 {\n        \n    }\n}", "racket": "(define/contract (remove-almost-equal-characters word)\n  (-> string? exact-integer?)\n  )", "erlang": "-spec remove_almost_equal_characters(Word :: unicode:unicode_binary()) -> integer().\nremove_almost_equal_characters(Word) ->\n  .", "elixir": "defmodule Solution do\n  @spec remove_almost_equal_characters(word :: String.t) :: integer\n  def remove_almost_equal_characters(word) do\n    \n  end\nend"}}
{"id": "leetcode_2740", "url": "https://leetcode.com/problems/find-the-value-of-the-partition/", "title": "Find the Value of the Partition", "description": "You are given a **positive** integer array `nums`.\n\n\nPartition `nums` into two arrays,\u00a0`nums1` and `nums2`, such that:\n\n\n* Each element of the array `nums` belongs to either the array `nums1` or the array `nums2`.\n* Both arrays are **non-empty**.\n* The value of the partition is **minimized**.\n\n\nThe value of the partition is `|max(nums1) - min(nums2)|`.\n\n\nHere, `max(nums1)` denotes the maximum element of the array `nums1`, and `min(nums2)` denotes the minimum element of the array `nums2`.\n\n\nReturn *the integer denoting the value of such partition*.", "examples": ["**Input:** nums = [1,3,2,4]\n**Output:** 1\n**Explanation:** We can partition the array nums into nums1 = [1,2] and nums2 = [3,4].\n- The maximum element of the array nums1 is equal to 2.\n- The minimum element of the array nums2 is equal to 3.\nThe value of the partition is |2 - 3| = 1. \nIt can be proven that 1 is the minimum value out of all partitions.", "**Input:** nums = [100,1,10]\n**Output:** 9\n**Explanation:** We can partition the array nums into nums1 = [10] and nums2 = [100,1].\n- The maximum element of the array nums1 is equal to 10.\n- The minimum element of the array nums2 is equal to 1.\nThe value of the partition is |10 - 1| = 9.\nIt can be proven that 9 is the minimum value out of all partitions."], "constraints": "**Constraints:**\n\n\n* `2 <= nums.length <= 105`\n* `1 <= nums[i] <= 109`", "difficulty": "Medium", "tags": ["Array", "Sorting"], "hints": ["Sort the array.", "The answer is min(nums[i+1] - nums[i]) for all i in the range [0, n-2]."], "templates": {"cpp": "class Solution {\npublic:\n    int findValueOfPartition(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public int findValueOfPartition(int[] nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def findValueOfPartition(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def findValueOfPartition(self, nums: List[int]) -> int:\n        ", "c": "int findValueOfPartition(int* nums, int numsSize){\n\n}", "csharp": "public class Solution {\n    public int FindValueOfPartition(int[] nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findValueOfPartition = function(nums) {\n    \n};", "typescript": "function findValueOfPartition(nums: number[]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function findValueOfPartition($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func findValueOfPartition(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun findValueOfPartition(nums: IntArray): Int {\n        \n    }\n}", "dart": "class Solution {\n  int findValueOfPartition(List<int> nums) {\n\n  }\n}", "golang": "func findValueOfPartition(nums []int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef find_value_of_partition(nums)\n    \nend", "scala": "object Solution {\n    def findValueOfPartition(nums: Array[Int]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn find_value_of_partition(nums: Vec<i32>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (find-value-of-partition nums)\n  (-> (listof exact-integer?) exact-integer?)\n\n  )", "erlang": "-spec find_value_of_partition(Nums :: [integer()]) -> integer().\nfind_value_of_partition(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec find_value_of_partition(nums :: [integer]) :: integer\n  def find_value_of_partition(nums) do\n\n  end\nend"}}
{"id": "leetcode_2799", "url": "https://leetcode.com/problems/count-complete-subarrays-in-an-array/", "title": "Count Complete Subarrays in an Array", "description": "You are given an array `nums` consisting of **positive** integers.\n\n\nWe call a subarray of an array **complete** if the following condition is satisfied:\n\n\n* The number of **distinct** elements in the subarray is equal to the number of distinct elements in the whole array.\n\n\nReturn *the number of **complete** subarrays*.\n\n\nA **subarray** is a contiguous non-empty part of an array.", "examples": ["**Input:** nums = [1,3,1,2,2]\n**Output:** 4\n**Explanation:** The complete subarrays are the following: [1,3,1,2], [1,3,1,2,2], [3,1,2] and [3,1,2,2].", "**Input:** nums = [5,5,5,5]\n**Output:** 10\n**Explanation:** The array consists only of the integer 5, so any subarray is complete. The number of subarrays that we can choose is 10."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 1000`\n* `1 <= nums[i] <= 2000`", "difficulty": "Medium", "tags": ["Array", "Hash Table", "Sliding Window"], "hints": ["Let\u2019s say k is the number of distinct elements in the array. Our goal is to find the number of subarrays with k distinct elements.", "Since the constraints are small, you can check every subarray."], "templates": {"cpp": "class Solution {\npublic:\n    int countCompleteSubarrays(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public int countCompleteSubarrays(int[] nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def countCompleteSubarrays(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def countCompleteSubarrays(self, nums: List[int]) -> int:\n        ", "c": "int countCompleteSubarrays(int* nums, int numsSize){\n\n}", "csharp": "public class Solution {\n    public int CountCompleteSubarrays(int[] nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar countCompleteSubarrays = function(nums) {\n    \n};", "typescript": "function countCompleteSubarrays(nums: number[]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function countCompleteSubarrays($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func countCompleteSubarrays(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun countCompleteSubarrays(nums: IntArray): Int {\n        \n    }\n}", "dart": "class Solution {\n  int countCompleteSubarrays(List<int> nums) {\n\n  }\n}", "golang": "func countCompleteSubarrays(nums []int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef count_complete_subarrays(nums)\n    \nend", "scala": "object Solution {\n    def countCompleteSubarrays(nums: Array[Int]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn count_complete_subarrays(nums: Vec<i32>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (count-complete-subarrays nums)\n  (-> (listof exact-integer?) exact-integer?)\n\n  )", "erlang": "-spec count_complete_subarrays(Nums :: [integer()]) -> integer().\ncount_complete_subarrays(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec count_complete_subarrays(nums :: [integer]) :: integer\n  def count_complete_subarrays(nums) do\n\n  end\nend"}}
{"id": "leetcode_2672", "url": "https://leetcode.com/problems/number-of-adjacent-elements-with-the-same-color/", "title": "Number of Adjacent Elements With the Same Color", "description": "There is a **0-indexed** array `nums` of length `n`. Initially, all elements are **uncolored** (has a value of `0`).\n\n\nYou are given a 2D integer array `queries` where `queries[i] = [indexi, colori]`.\n\n\nFor each query, you color the index `indexi` with the color `colori` in the array `nums`.\n\n\nReturn *an array* `answer` *of the same length as* `queries` *where* `answer[i]` *is the number of adjacent elements with the same color **after** the* `ith` *query*.\n\n\nMore formally, `answer[i]` is the number of indices `j`, such that `0 <= j < n - 1` and `nums[j] == nums[j + 1]` and `nums[j] != 0` after the `ith` query.", "examples": ["**Input:** n = 4, queries = [[0,2],[1,2],[3,1],[1,1],[2,1]]\n**Output:** [0,1,1,0,2]\n**Explanation:** Initially array nums = [0,0,0,0], where 0 denotes uncolored elements of the array.\n- After the 1st query nums = [2,0,0,0]. The count of adjacent elements with the same color is 0.\n- After the 2nd query nums = [2,2,0,0]. The count of adjacent elements with the same color is 1.\n- After the 3rd\u00a0query nums = [2,2,0,1]. The count of adjacent elements with the same color is 1.\n- After the 4th\u00a0query nums = [2,1,0,1]. The count of adjacent elements with the same color is 0.\n- After the 5th\u00a0query nums = [2,1,1,1]. The count of adjacent elements with the same color is 2.", "**Input:** n = 1, queries = [[0,100000]]\n**Output:** [0]\n**Explanation:** Initially array nums = [0], where 0 denotes uncolored elements of the array.\n- After the 1st query nums = [100000]. The count of adjacent elements with the same color is 0."], "constraints": "**Constraints:**\n\n\n* `1 <= n <= 105`\n* `1 <= queries.length <= 105`\n* `queries[i].length\u00a0== 2`\n* `0 <= indexi\u00a0<= n - 1`\n* `1 <=\u00a0 colori\u00a0<= 105`", "difficulty": "Medium", "tags": ["Array"], "hints": ["Since at each query, only one element is being recolored, we just need to focus on its neighbors.", "If an element that is changed on the i-th query had the same color as its right element answer decreases by 1. Similarly contributes its left element too.", "After changing the color, if the element has the same color as its right element answer increases by 1. Similarly contributes its left element too."], "templates": {"cpp": "class Solution {\npublic:\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\n        \n    }\n};", "java": "class Solution {\n    public int[] colorTheArray(int n, int[][] queries) {\n        \n    }\n}", "python": "class Solution(object):\n    def colorTheArray(self, n, queries):\n        \"\"\"\n        :type n: int\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        ", "python3": "class Solution:\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\n        ", "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* colorTheArray(int n, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\n\n}", "csharp": "public class Solution {\n    public int[] ColorTheArray(int n, int[][] queries) {\n        \n    }\n}", "javascript": "/**\n * @param {number} n\n * @param {number[][]} queries\n * @return {number[]}\n */\nvar colorTheArray = function(n, queries) {\n    \n};", "typescript": "function colorTheArray(n: number, queries: number[][]): number[] {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $queries\n     * @return Integer[]\n     */\n    function colorTheArray($n, $queries) {\n        \n    }\n}", "swift": "class Solution {\n    func colorTheArray(_ n: Int, _ queries: [[Int]]) -> [Int] {\n        \n    }\n}", "kotlin": "class Solution {\n    fun colorTheArray(n: Int, queries: Array<IntArray>): IntArray {\n        \n    }\n}", "dart": "class Solution {\n  List<int> colorTheArray(int n, List<List<int>> queries) {\n\n  }\n}", "golang": "func colorTheArray(n int, queries [][]int) []int {\n    \n}", "ruby": "# @param {Integer} n\n# @param {Integer[][]} queries\n# @return {Integer[]}\ndef color_the_array(n, queries)\n    \nend", "scala": "object Solution {\n    def colorTheArray(n: Int, queries: Array[Array[Int]]): Array[Int] = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn color_the_array(n: i32, queries: Vec<Vec<i32>>) -> Vec<i32> {\n        \n    }\n}", "racket": "(define/contract (color-the-array n queries)\n  (-> exact-integer? (listof (listof exact-integer?)) (listof exact-integer?))\n\n  )", "erlang": "-spec color_the_array(N :: integer(), Queries :: [[integer()]]) -> [integer()].\ncolor_the_array(N, Queries) ->\n  .", "elixir": "defmodule Solution do\n  @spec color_the_array(n :: integer, queries :: [[integer]]) :: [integer]\n  def color_the_array(n, queries) do\n\n  end\nend"}}
{"id": "leetcode_2808", "url": "https://leetcode.com/problems/minimum-seconds-to-equalize-a-circular-array/", "title": "Minimum Seconds to Equalize a Circular Array", "description": "You are given a **0-indexed** array `nums` containing `n` integers.\n\n\nAt each second, you perform the following operation on the array:\n\n\n* For every index `i` in the range `[0, n - 1]`, replace `nums[i]` with either `nums[i]`, `nums[(i - 1 + n) % n]`, or `nums[(i + 1) % n]`.\n\n\n**Note** that all the elements get replaced simultaneously.\n\n\nReturn *the **minimum** number of seconds needed to make all elements in the array* `nums` *equal*.", "examples": ["**Input:** nums = [1,2,1,2]\n**Output:** 1\n**Explanation:** We can equalize the array in 1 second in the following way:\n- At 1st second, replace values at each index with [nums[3],nums[1],nums[3],nums[3]]. After replacement, nums = [2,2,2,2].\nIt can be proven that 1 second is the minimum amount of seconds needed for equalizing the array.", "**Input:** nums = [2,1,3,3,2]\n**Output:** 2\n**Explanation:** We can equalize the array in 2 seconds in the following way:\n- At 1st second, replace values at each index with [nums[0],nums[2],nums[2],nums[2],nums[3]]. After replacement, nums = [2,3,3,3,3].\n- At 2nd second, replace values at each index with [nums[1],nums[1],nums[2],nums[3],nums[4]]. After replacement, nums = [3,3,3,3,3].\nIt can be proven that 2 seconds is the minimum amount of seconds needed for equalizing the array.", "**Input:** nums = [5,5,5,5]\n**Output:** 0\n**Explanation:** We don't need to perform any operations as all elements in the initial array are the same."], "constraints": "**Constraints:**\n\n\n* `1 <= n == nums.length <= 105`\n* `1 <= nums[i] <= 109`", "difficulty": "Medium", "tags": ["Array", "Hash Table", "Greedy"], "hints": ["For every possible x - the final value of the array, calculate the number of seconds needed to make all elements equal to x.", "Notice that if you take two consecutive occurrences (i, j) of x, then the number of operations to make segment [i + 1, j - 1] equal to x is floor((j - i) / 2)"], "templates": {"cpp": "class Solution {\npublic:\n    int minimumSeconds(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public int minimumSeconds(List<Integer> nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def minimumSeconds(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def minimumSeconds(self, nums: List[int]) -> int:\n        ", "c": "int minimumSeconds(int* nums, int numsSize){\n\n}", "csharp": "public class Solution {\n    public int MinimumSeconds(IList<int> nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minimumSeconds = function(nums) {\n    \n};", "typescript": "function minimumSeconds(nums: number[]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function minimumSeconds($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func minimumSeconds(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun minimumSeconds(nums: List<Int>): Int {\n        \n    }\n}", "dart": "class Solution {\n  int minimumSeconds(List<int> nums) {\n\n  }\n}", "golang": "func minimumSeconds(nums []int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef minimum_seconds(nums)\n    \nend", "scala": "object Solution {\n    def minimumSeconds(nums: List[Int]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn minimum_seconds(nums: Vec<i32>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (minimum-seconds nums)\n  (-> (listof exact-integer?) exact-integer?)\n\n  )", "erlang": "-spec minimum_seconds(Nums :: [integer()]) -> integer().\nminimum_seconds(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec minimum_seconds(nums :: [integer]) :: integer\n  def minimum_seconds(nums) do\n\n  end\nend"}}
{"id": "leetcode_2961", "url": "https://leetcode.com/problems/double-modular-exponentiation/", "title": "Double Modular Exponentiation", "description": "You are given a **0-indexed** 2D array `variables` where `variables[i] = [ai, bi, ci, mi]`, and an integer `target`.\n\n\nAn index `i` is **good** if the following formula holds:\n\n\n* `0 <= i < variables.length`\n* `((aibi % 10)ci) % mi == target`\n\n\nReturn *an array consisting of **good** indices in **any order***.", "examples": ["**Input:** variables = [[2,3,3,10],[3,3,3,1],[6,1,1,4]], target = 2\n**Output:** [0,2]\n**Explanation:** For each index i in the variables array:\n1) For the index 0, variables[0] = [2,3,3,10], (23 % 10)3 % 10 = 2.\n2) For the index 1, variables[1] = [3,3,3,1], (33 % 10)3 % 1 = 0.\n3) For the index 2, variables[2] = [6,1,1,4], (61 % 10)1 % 4 = 2.\nTherefore we return [0,2] as the answer.", "**Input:** variables = [[39,3,1000,1000]], target = 17\n**Output:** []\n**Explanation:** For each index i in the variables array:\n1) For the index 0, variables[0] = [39,3,1000,1000], (393 % 10)1000 % 1000 = 1.\nTherefore we return [] as the answer."], "constraints": "**Constraints:**\n\n\n* `1 <= variables.length <= 100`\n* `variables[i] == [ai, bi, ci, mi]`\n* `1 <= ai, bi, ci, mi <= 103`\n* `0 <= target <= 103`", "difficulty": "Medium", "tags": ["Array", "Math", "Simulation"], "hints": [], "templates": {"cpp": "class Solution {\npublic:\n    vector<int> getGoodIndices(vector<vector<int>>& variables, int target) {\n        \n    }\n};", "java": "class Solution {\n    public List<Integer> getGoodIndices(int[][] variables, int target) {\n        \n    }\n}", "python": "class Solution(object):\n    def getGoodIndices(self, variables, target):\n        \"\"\"\n        :type variables: List[List[int]]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        ", "python3": "class Solution:\n    def getGoodIndices(self, variables: List[List[int]], target: int) -> List[int]:\n        ", "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* getGoodIndices(int** variables, int variablesSize, int* variablesColSize, int target, int* returnSize) {\n    \n}", "csharp": "public class Solution {\n    public IList<int> GetGoodIndices(int[][] variables, int target) {\n        \n    }\n}", "javascript": "/**\n * @param {number[][]} variables\n * @param {number} target\n * @return {number[]}\n */\nvar getGoodIndices = function(variables, target) {\n    \n};", "typescript": "function getGoodIndices(variables: number[][], target: number): number[] {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[][] $variables\n     * @param Integer $target\n     * @return Integer[]\n     */\n    function getGoodIndices($variables, $target) {\n        \n    }\n}", "swift": "class Solution {\n    func getGoodIndices(_ variables: [[Int]], _ target: Int) -> [Int] {\n        \n    }\n}", "kotlin": "class Solution {\n    fun getGoodIndices(variables: Array<IntArray>, target: Int): List<Int> {\n        \n    }\n}", "dart": "class Solution {\n  List<int> getGoodIndices(List<List<int>> variables, int target) {\n    \n  }\n}", "golang": "func getGoodIndices(variables [][]int, target int) []int {\n    \n}", "ruby": "# @param {Integer[][]} variables\n# @param {Integer} target\n# @return {Integer[]}\ndef get_good_indices(variables, target)\n    \nend", "scala": "object Solution {\n    def getGoodIndices(variables: Array[Array[Int]], target: Int): List[Int] = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn get_good_indices(variables: Vec<Vec<i32>>, target: i32) -> Vec<i32> {\n        \n    }\n}", "racket": "(define/contract (get-good-indices variables target)\n  (-> (listof (listof exact-integer?)) exact-integer? (listof exact-integer?))\n  )", "erlang": "-spec get_good_indices(Variables :: [[integer()]], Target :: integer()) -> [integer()].\nget_good_indices(Variables, Target) ->\n  .", "elixir": "defmodule Solution do\n  @spec get_good_indices(variables :: [[integer]], target :: integer) :: [integer]\n  def get_good_indices(variables, target) do\n    \n  end\nend"}}
{"id": "leetcode_2865", "url": "https://leetcode.com/problems/beautiful-towers-i/", "title": "Beautiful Towers I", "description": "You are given a **0-indexed** array `maxHeights` of `n` integers.\n\n\nYou are tasked with building `n` towers in the coordinate line. The `ith` tower is built at coordinate `i` and has a height of `heights[i]`.\n\n\nA configuration of towers is **beautiful** if the following conditions hold:\n\n\n1. `1 <= heights[i] <= maxHeights[i]`\n2. `heights` is a **mountain** array.\n\n\nArray `heights` is a **mountain** if there exists an index `i` such that:\n\n\n* For all `0 < j <= i`, `heights[j - 1] <= heights[j]`\n* For all `i <= k < n - 1`, `heights[k + 1] <= heights[k]`\n\n\nReturn *the **maximum possible sum of heights** of a beautiful configuration of towers*.", "examples": ["**Input:** maxHeights = [5,3,4,1,1]\n**Output:** 13\n**Explanation:** One beautiful configuration with a maximum sum is heights = [5,3,3,1,1]. This configuration is beautiful since:\n- 1 <= heights[i] <= maxHeights[i]  \n- heights is a mountain of peak i = 0.\nIt can be shown that there exists no other beautiful configuration with a sum of heights greater than 13.", "**Input:** maxHeights = [6,5,3,9,2,7]\n**Output:** 22\n**Explanation:** One beautiful configuration with a maximum sum is heights = [3,3,3,9,2,2]. This configuration is beautiful since:\n- 1 <= heights[i] <= maxHeights[i]\n- heights is a mountain of peak i = 3.\nIt can be shown that there exists no other beautiful configuration with a sum of heights greater than 22.", "**Input:** maxHeights = [3,2,5,5,2,3]\n**Output:** 18\n**Explanation:** One beautiful configuration with a maximum sum is heights = [2,2,5,5,2,2]. This configuration is beautiful since:\n- 1 <= heights[i] <= maxHeights[i]\n- heights is a mountain of peak i = 2. \nNote that, for this configuration, i = 3 can also be considered a peak.\nIt can be shown that there exists no other beautiful configuration with a sum of heights greater than 18."], "constraints": "**Constraints:**\n\n\n* `1 <= n == maxHeights <= 103`\n* `1 <= maxHeights[i] <= 109`", "difficulty": "Medium", "tags": ["Array", "Stack", "Monotonic Stack"], "hints": ["Try all the possible indices <code>i</code> as the peak.", "If <code>i</code> is the peak, start from <code>heights[i] = maxHeights[i]</code>, and <code>heights[j] = max(maxHeights[j], heights[j + 1])</code> for <code>0 <= j < i </code>", "If <code>i</code> is the peak, start from <code>heights[i] = maxHeights[i]</code>, and heights[j] = max(maxHeights[j], heights[j - 1]) for <code>i < j < heights.size()</code>"], "templates": {"cpp": "class Solution {\npublic:\n    long long maximumSumOfHeights(vector<int>& maxHeights) {\n        \n    }\n};", "java": "class Solution {\n    public long maximumSumOfHeights(List<Integer> maxHeights) {\n        \n    }\n}", "python": "class Solution(object):\n    def maximumSumOfHeights(self, maxHeights):\n        \"\"\"\n        :type maxHeights: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def maximumSumOfHeights(self, maxHeights: List[int]) -> int:\n        ", "c": "long long maximumSumOfHeights(int* maxHeights, int maxHeightsSize){\n\n}", "csharp": "public class Solution {\n    public long MaximumSumOfHeights(IList<int> maxHeights) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} maxHeights\n * @return {number}\n */\nvar maximumSumOfHeights = function(maxHeights) {\n    \n};", "typescript": "function maximumSumOfHeights(maxHeights: number[]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $maxHeights\n     * @return Integer\n     */\n    function maximumSumOfHeights($maxHeights) {\n        \n    }\n}", "swift": "class Solution {\n    func maximumSumOfHeights(_ maxHeights: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun maximumSumOfHeights(maxHeights: List<Int>): Long {\n        \n    }\n}", "dart": "class Solution {\n  int maximumSumOfHeights(List<int> maxHeights) {\n\n  }\n}", "golang": "func maximumSumOfHeights(maxHeights []int) int64 {\n    \n}", "ruby": "# @param {Integer[]} max_heights\n# @return {Integer}\ndef maximum_sum_of_heights(max_heights)\n    \nend", "scala": "object Solution {\n    def maximumSumOfHeights(maxHeights: List[Int]): Long = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn maximum_sum_of_heights(max_heights: Vec<i32>) -> i64 {\n        \n    }\n}", "racket": "(define/contract (maximum-sum-of-heights maxHeights)\n  (-> (listof exact-integer?) exact-integer?)\n\n  )", "erlang": "-spec maximum_sum_of_heights(MaxHeights :: [integer()]) -> integer().\nmaximum_sum_of_heights(MaxHeights) ->\n  .", "elixir": "defmodule Solution do\n  @spec maximum_sum_of_heights(max_heights :: [integer]) :: integer\n  def maximum_sum_of_heights(max_heights) do\n\n  end\nend"}}
{"id": "leetcode_2747", "url": "https://leetcode.com/problems/count-zero-request-servers/", "title": "Count Zero Request Servers", "description": "You are given an integer `n` denoting the total number of servers and a **2D** **0-indexed** integer array `logs`, where `logs[i] = [server_id, time]` denotes that the server with id `server_id` received a request at time `time`.\n\n\nYou are also given an integer `x` and a **0-indexed** integer array `queries`.\n\n\nReturn *a **0-indexed** integer array* `arr` *of length* `queries.length` *where* `arr[i]` *represents the number of servers that **did not receive** any requests during the time interval* `[queries[i] - x, queries[i]]`.\n\n\nNote that the time intervals are inclusive.", "examples": ["**Input:** n = 3, logs = [[1,3],[2,6],[1,5]], x = 5, queries = [10,11]\n**Output:** [1,2]\n**Explanation:** \nFor queries[0]: The servers with ids 1 and 2 get requests in the duration of [5, 10]. Hence, only server 3 gets zero requests.\nFor queries[1]: Only the server with id 2 gets a request in duration of [6,11]. Hence, the servers with ids 1 and 3 are the only servers that do not receive any requests during that time period.", "**Input:** n = 3, logs = [[2,4],[2,1],[1,2],[3,1]], x = 2, queries = [3,4]\n**Output:** [0,1]\n**Explanation:** \nFor queries[0]: All servers get at least one request in the duration of [1, 3].\nFor queries[1]: Only server with id 3 gets no request in the duration [2,4]."], "constraints": "**Constraints:**\n\n\n* `1 <= n <= 105`\n* `1 <= logs.length <= 105`\n* `1 <= queries.length <= 105`\n* `logs[i].length == 2`\n* `1 <= logs[i][0] <= n`\n* `1 <= logs[i][1] <= 106`\n* `1 <= x <= 105`\n* `x <\u00a0queries[i]\u00a0<= 106`", "difficulty": "Medium", "tags": ["Array", "Hash Table", "Sliding Window", "Sorting"], "hints": ["Can we use sorting and two-pointer approach here?", "Sort the queries array and logs array based on time in increasing order.", "For every window of size x, use sliding window and two-pointer approach to find the answer to the queries."], "templates": {"cpp": "class Solution {\npublic:\n    vector<int> countServers(int n, vector<vector<int>>& logs, int x, vector<int>& queries) {\n        \n    }\n};", "java": "class Solution {\n    public int[] countServers(int n, int[][] logs, int x, int[] queries) {\n        \n    }\n}", "python": "class Solution(object):\n    def countServers(self, n, logs, x, queries):\n        \"\"\"\n        :type n: int\n        :type logs: List[List[int]]\n        :type x: int\n        :type queries: List[int]\n        :rtype: List[int]\n        \"\"\"\n        ", "python3": "class Solution:\n    def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\n        ", "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* countServers(int n, int** logs, int logsSize, int* logsColSize, int x, int* queries, int queriesSize, int* returnSize){\n\n}", "csharp": "public class Solution {\n    public int[] CountServers(int n, int[][] logs, int x, int[] queries) {\n        \n    }\n}", "javascript": "/**\n * @param {number} n\n * @param {number[][]} logs\n * @param {number} x\n * @param {number[]} queries\n * @return {number[]}\n */\nvar countServers = function(n, logs, x, queries) {\n    \n};", "typescript": "function countServers(n: number, logs: number[][], x: number, queries: number[]): number[] {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $logs\n     * @param Integer $x\n     * @param Integer[] $queries\n     * @return Integer[]\n     */\n    function countServers($n, $logs, $x, $queries) {\n        \n    }\n}", "swift": "class Solution {\n    func countServers(_ n: Int, _ logs: [[Int]], _ x: Int, _ queries: [Int]) -> [Int] {\n        \n    }\n}", "kotlin": "class Solution {\n    fun countServers(n: Int, logs: Array<IntArray>, x: Int, queries: IntArray): IntArray {\n        \n    }\n}", "dart": "class Solution {\n  List<int> countServers(int n, List<List<int>> logs, int x, List<int> queries) {\n\n  }\n}", "golang": "func countServers(n int, logs [][]int, x int, queries []int) []int {\n    \n}", "ruby": "# @param {Integer} n\n# @param {Integer[][]} logs\n# @param {Integer} x\n# @param {Integer[]} queries\n# @return {Integer[]}\ndef count_servers(n, logs, x, queries)\n    \nend", "scala": "object Solution {\n    def countServers(n: Int, logs: Array[Array[Int]], x: Int, queries: Array[Int]): Array[Int] = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn count_servers(n: i32, logs: Vec<Vec<i32>>, x: i32, queries: Vec<i32>) -> Vec<i32> {\n        \n    }\n}", "racket": "(define/contract (count-servers n logs x queries)\n  (-> exact-integer? (listof (listof exact-integer?)) exact-integer? (listof exact-integer?) (listof exact-integer?))\n\n  )", "erlang": "-spec count_servers(N :: integer(), Logs :: [[integer()]], X :: integer(), Queries :: [integer()]) -> [integer()].\ncount_servers(N, Logs, X, Queries) ->\n  .", "elixir": "defmodule Solution do\n  @spec count_servers(n :: integer, logs :: [[integer]], x :: integer, queries :: [integer]) :: [integer]\n  def count_servers(n, logs, x, queries) do\n\n  end\nend"}}
{"id": "leetcode_2679", "url": "https://leetcode.com/problems/sum-in-a-matrix/", "title": "Sum in a Matrix", "description": "You are given a **0-indexed** 2D integer array `nums`. Initially, your score is `0`. Perform the following operations until the matrix becomes empty:\n\n\n1. From each row in the matrix, select the largest number and remove it. In the case of a tie, it does not matter which number is chosen.\n2. Identify the highest number amongst all those removed in step 1. Add that number to your **score**.\n\n\nReturn *the final **score**.*", "examples": ["**Input:** nums = [[7,2,1],[6,4,2],[6,5,3],[3,2,1]]\n**Output:** 15\n**Explanation:** In the first operation, we remove 7, 6, 6, and 3. We then add 7 to our score. Next, we remove 2, 4, 5, and 2. We add 5 to our score. Lastly, we remove 1, 2, 3, and 1. We add 3 to our score. Thus, our final score is 7 + 5 + 3 = 15.", "**Input:** nums = [[1]]\n**Output:** 1\n**Explanation:** We remove 1 and add it to the answer. We return 1."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 300`\n* `1 <= nums[i].length <= 500`\n* `0 <= nums[i][j] <= 103`", "difficulty": "Medium", "tags": ["Array", "Sorting", "Heap (Priority Queue)", "Matrix", "Simulation"], "hints": ["Sort the numbers in each row in decreasing order.", "The answer is the summation of the max number in every column after sorting the rows."], "templates": {"cpp": "class Solution {\npublic:\n    int matrixSum(vector<vector<int>>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public int matrixSum(int[][] nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def matrixSum(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        ", "c": "int matrixSum(int** nums, int numsSize, int* numsColSize){\n\n}", "csharp": "public class Solution {\n    public int MatrixSum(int[][] nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[][]} nums\n * @return {number}\n */\nvar matrixSum = function(nums) {\n    \n};", "typescript": "function matrixSum(nums: number[][]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[][] $nums\n     * @return Integer\n     */\n    function matrixSum($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func matrixSum(_ nums: [[Int]]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun matrixSum(nums: Array<IntArray>): Int {\n        \n    }\n}", "dart": "class Solution {\n  int matrixSum(List<List<int>> nums) {\n\n  }\n}", "golang": "func matrixSum(nums [][]int) int {\n    \n}", "ruby": "# @param {Integer[][]} nums\n# @return {Integer}\ndef matrix_sum(nums)\n    \nend", "scala": "object Solution {\n    def matrixSum(nums: Array[Array[Int]]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn matrix_sum(nums: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (matrix-sum nums)\n  (-> (listof (listof exact-integer?)) exact-integer?)\n\n  )", "erlang": "-spec matrix_sum(Nums :: [[integer()]]) -> integer().\nmatrix_sum(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec matrix_sum(nums :: [[integer]]) :: integer\n  def matrix_sum(nums) do\n\n  end\nend"}}
{"id": "leetcode_2680", "url": "https://leetcode.com/problems/maximum-or/", "title": "Maximum OR", "description": "You are given a **0-indexed** integer array `nums` of length `n` and an integer `k`. In an operation, you can choose an element and multiply it by `2`.\n\n\nReturn *the maximum possible value of* `nums[0] | nums[1] | ... | nums[n - 1]` *that can be obtained after applying the operation on nums at most* `k` *times*.\n\n\nNote that `a | b` denotes the **bitwise or** between two integers `a` and `b`.", "examples": ["**Input:** nums = [12,9], k = 1\n**Output:** 30\n**Explanation:** If we apply the operation to index 1, our new array nums will be equal to [12,18]. Thus, we return the bitwise or of 12 and 18, which is 30.", "**Input:** nums = [8,1,2], k = 2\n**Output:** 35\n**Explanation:** If we apply the operation twice on index 0, we yield a new array of [32,1,2]. Thus, we return 32|1|2 = 35."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `1 <= nums[i] <= 109`\n* `1 <= k <= 15`", "difficulty": "Medium", "tags": ["Array", "Greedy", "Bit Manipulation", "Prefix Sum"], "hints": ["The optimal solution should apply all the k operations on a single number.", "Calculate the prefix or and the suffix or and perform k operations over each element, and maximize the answer."], "templates": {"cpp": "class Solution {\npublic:\n    long long maximumOr(vector<int>& nums, int k) {\n        \n    }\n};", "java": "class Solution {\n    public long maximumOr(int[] nums, int k) {\n        \n    }\n}", "python": "class Solution(object):\n    def maximumOr(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def maximumOr(self, nums: List[int], k: int) -> int:\n        ", "c": "long long maximumOr(int* nums, int numsSize, int k){\n\n}", "csharp": "public class Solution {\n    public long MaximumOr(int[] nums, int k) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maximumOr = function(nums, k) {\n    \n};", "typescript": "function maximumOr(nums: number[], k: number): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer\n     */\n    function maximumOr($nums, $k) {\n        \n    }\n}", "swift": "class Solution {\n    func maximumOr(_ nums: [Int], _ k: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun maximumOr(nums: IntArray, k: Int): Long {\n        \n    }\n}", "dart": "class Solution {\n  int maximumOr(List<int> nums, int k) {\n\n  }\n}", "golang": "func maximumOr(nums []int, k int) int64 {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer}\ndef maximum_or(nums, k)\n    \nend", "scala": "object Solution {\n    def maximumOr(nums: Array[Int], k: Int): Long = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn maximum_or(nums: Vec<i32>, k: i32) -> i64 {\n        \n    }\n}", "racket": "(define/contract (maximum-or nums k)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n\n  )", "erlang": "-spec maximum_or(Nums :: [integer()], K :: integer()) -> integer().\nmaximum_or(Nums, K) ->\n  .", "elixir": "defmodule Solution do\n  @spec maximum_or(nums :: [integer], k :: integer) :: integer\n  def maximum_or(nums, k) do\n\n  end\nend"}}
{"id": "leetcode_2874", "url": "https://leetcode.com/problems/maximum-value-of-an-ordered-triplet-ii/", "title": "Maximum Value of an Ordered Triplet II", "description": "You are given a **0-indexed** integer array `nums`.\n\n\nReturn ***the maximum value over all triplets of indices*** `(i, j, k)` *such that* `i < j < k`*.* If all such triplets have a negative value, return `0`.\n\n\nThe **value of a triplet of indices** `(i, j, k)` is equal to `(nums[i] - nums[j]) * nums[k]`.", "examples": ["**Input:** nums = [12,6,1,2,7]\n**Output:** 77\n**Explanation:** The value of the triplet (0, 2, 4) is (nums[0] - nums[2]) * nums[4] = 77.\nIt can be shown that there are no ordered triplets of indices with a value greater than 77.", "**Input:** nums = [1,10,3,4,19]\n**Output:** 133\n**Explanation:** The value of the triplet (1, 2, 4) is (nums[1] - nums[2]) * nums[4] = 133.\nIt can be shown that there are no ordered triplets of indices with a value greater than 133.", "**Input:** nums = [1,2,3]\n**Output:** 0\n**Explanation:** The only ordered triplet of indices (0, 1, 2) has a negative value of (nums[0] - nums[1]) * nums[2] = -3. Hence, the answer would be 0."], "constraints": "**Constraints:**\n\n\n* `3 <= nums.length <= 105`\n* `1 <= nums[i] <= 106`", "difficulty": "Medium", "tags": ["Array"], "hints": ["Preprocess the prefix maximum array, <code>prefix_max[i] = max(nums[0], nums[1], \u2026, nums[i])</code> and the suffix maximum array, <code>suffix_max[i] = max(nums[i], nums[i + 1], \u2026, nums[i - 1])</code>.", "For each index <code>j</code>, find two indices <code>i</code> and <code>k</code> such that <code>i < j < k</code> and <code>(nums[i] - nums[j]) * nums[k]</code> is the maximum, using the prefix and suffix maximum arrays.", "For index <code>j</code>, the maximum triplet value is <code>(prefix_max[j - 1] - nums[j]) * suffix_max[j + 1]</code>."], "templates": {"cpp": "class Solution {\npublic:\n    long long maximumTripletValue(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public long maximumTripletValue(int[] nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def maximumTripletValue(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def maximumTripletValue(self, nums: List[int]) -> int:\n        ", "c": "long long maximumTripletValue(int* nums, int numsSize) {\n    \n}", "csharp": "public class Solution {\n    public long MaximumTripletValue(int[] nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maximumTripletValue = function(nums) {\n    \n};", "typescript": "function maximumTripletValue(nums: number[]): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function maximumTripletValue($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func maximumTripletValue(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun maximumTripletValue(nums: IntArray): Long {\n        \n    }\n}", "dart": "class Solution {\n  int maximumTripletValue(List<int> nums) {\n    \n  }\n}", "golang": "func maximumTripletValue(nums []int) int64 {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef maximum_triplet_value(nums)\n    \nend", "scala": "object Solution {\n    def maximumTripletValue(nums: Array[Int]): Long = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn maximum_triplet_value(nums: Vec<i32>) -> i64 {\n        \n    }\n}", "racket": "(define/contract (maximum-triplet-value nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )", "erlang": "-spec maximum_triplet_value(Nums :: [integer()]) -> integer().\nmaximum_triplet_value(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec maximum_triplet_value(nums :: [integer]) :: integer\n  def maximum_triplet_value(nums) do\n    \n  end\nend"}}
{"id": "leetcode_2966", "url": "https://leetcode.com/problems/divide-array-into-arrays-with-max-difference/", "title": "Divide Array Into Arrays With Max Difference", "description": "You are given an integer array `nums` of size `n` and a positive integer `k`.\n\n\nDivide the array into one or more arrays of size `3` satisfying the following conditions:\n\n\n* **Each** element of `nums` should be in **exactly** one array.\n* The difference between **any** two elements in one array is less than or equal to `k`.\n\n\nReturn *a* **2D** *array containing all the arrays. If it is impossible to satisfy the conditions, return an empty array. And if there are multiple answers, return **any** of them.*", "examples": ["**Input:** nums = [1,3,4,8,7,9,3,5,1], k = 2\n**Output:** [[1,1,3],[3,4,5],[7,8,9]]\n**Explanation:** We can divide the array into the following arrays: [1,1,3], [3,4,5] and [7,8,9].\nThe difference between any two elements in each array is less than or equal to 2.\nNote that the order of elements is not important.", "**Input:** nums = [1,3,3,2,7,3], k = 3\n**Output:** []\n**Explanation:** It is not possible to divide the array satisfying all the conditions."], "constraints": "**Constraints:**\n\n\n* `n == nums.length`\n* `1 <= n <= 105`\n* `n` is a multiple of `3`.\n* `1 <= nums[i] <= 105`\n* `1 <= k <= 105`", "difficulty": "Medium", "tags": ["Array", "Greedy", "Sorting"], "hints": ["Try to use a greedy approach.", "Sort the array and try to group each <code>3</code> consecutive elements."], "templates": {"cpp": "class Solution {\npublic:\n    vector<vector<int>> divideArray(vector<int>& nums, int k) {\n        \n    }\n};", "java": "class Solution {\n    public int[][] divideArray(int[] nums, int k) {\n        \n    }\n}", "python": "class Solution(object):\n    def divideArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        ", "python3": "class Solution:\n    def divideArray(self, nums: List[int], k: int) -> List[List[int]]:\n        ", "c": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** divideArray(int* nums, int numsSize, int k, int* returnSize, int** returnColumnSizes) {\n    \n}", "csharp": "public class Solution {\n    public int[][] DivideArray(int[] nums, int k) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[][]}\n */\nvar divideArray = function(nums, k) {\n    \n};", "typescript": "function divideArray(nums: number[], k: number): number[][] {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer[][]\n     */\n    function divideArray($nums, $k) {\n        \n    }\n}", "swift": "class Solution {\n    func divideArray(_ nums: [Int], _ k: Int) -> [[Int]] {\n        \n    }\n}", "kotlin": "class Solution {\n    fun divideArray(nums: IntArray, k: Int): Array<IntArray> {\n        \n    }\n}", "dart": "class Solution {\n  List<List<int>> divideArray(List<int> nums, int k) {\n    \n  }\n}", "golang": "func divideArray(nums []int, k int) [][]int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer[][]}\ndef divide_array(nums, k)\n    \nend", "scala": "object Solution {\n    def divideArray(nums: Array[Int], k: Int): Array[Array[Int]] = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn divide_array(nums: Vec<i32>, k: i32) -> Vec<Vec<i32>> {\n        \n    }\n}", "racket": "(define/contract (divide-array nums k)\n  (-> (listof exact-integer?) exact-integer? (listof (listof exact-integer?)))\n  )", "erlang": "-spec divide_array(Nums :: [integer()], K :: integer()) -> [[integer()]].\ndivide_array(Nums, K) ->\n  .", "elixir": "defmodule Solution do\n  @spec divide_array(nums :: [integer], k :: integer) :: [[integer]]\n  def divide_array(nums, k) do\n    \n  end\nend"}}
{"id": "leetcode_2767", "url": "https://leetcode.com/problems/partition-string-into-minimum-beautiful-substrings/", "title": "Partition String Into Minimum Beautiful Substrings", "description": "Given a binary string `s`, partition the string into one or more **substrings** such that each substring is **beautiful**.\n\n\nA string is **beautiful** if:\n\n\n* It doesn't contain leading zeros.\n* It's the **binary** representation of a number that is a power of `5`.\n\n\nReturn *the **minimum** number of substrings in such partition.* If it is impossible to partition the string `s` into beautiful substrings,\u00a0return `-1`.\n\n\nA **substring** is a contiguous sequence of characters in a string.", "examples": ["**Input:** s = \"1011\"\n**Output:** 2\n**Explanation:** We can paritition the given string into [\"101\", \"1\"].\n- The string \"101\" does not contain leading zeros and is the binary representation of integer 51 = 5.\n- The string \"1\" does not contain leading zeros and is the binary representation of integer 50 = 1.\nIt can be shown that 2 is the minimum number of beautiful substrings that s can be partitioned into.", "**Input:** s = \"111\"\n**Output:** 3\n**Explanation:** We can paritition the given string into [\"1\", \"1\", \"1\"].\n- The string \"1\" does not contain leading zeros and is the binary representation of integer 50 = 1.\nIt can be shown that 3 is the minimum number of beautiful substrings that s can be partitioned into.", "**Input:** s = \"0\"\n**Output:** -1\n**Explanation:** We can not partition the given string into beautiful substrings."], "constraints": "**Constraints:**\n\n\n* `1 <= s.length <= 15`\n* `s[i]` is either `'0'` or `'1'`.", "difficulty": "Medium", "tags": ["Hash Table", "String", "Dynamic Programming", "Backtracking"], "hints": ["To check if number x is a power of 5 or not, we will divide x by 5 while x > 1 and x mod 5 == 0. After iteration if x == 1, then it was a power of 5.", "Since the constraint of s.length is small, we can use recursion to find all the partitions."], "templates": {"cpp": "class Solution {\npublic:\n    int minimumBeautifulSubstrings(string s) {\n        \n    }\n};", "java": "class Solution {\n    public int minimumBeautifulSubstrings(String s) {\n        \n    }\n}", "python": "class Solution(object):\n    def minimumBeautifulSubstrings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def minimumBeautifulSubstrings(self, s: str) -> int:\n        ", "c": "int minimumBeautifulSubstrings(char * s){\n\n}", "csharp": "public class Solution {\n    public int MinimumBeautifulSubstrings(string s) {\n        \n    }\n}", "javascript": "/**\n * @param {string} s\n * @return {number}\n */\nvar minimumBeautifulSubstrings = function(s) {\n    \n};", "typescript": "function minimumBeautifulSubstrings(s: string): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function minimumBeautifulSubstrings($s) {\n        \n    }\n}", "swift": "class Solution {\n    func minimumBeautifulSubstrings(_ s: String) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun minimumBeautifulSubstrings(s: String): Int {\n        \n    }\n}", "dart": "class Solution {\n  int minimumBeautifulSubstrings(String s) {\n\n  }\n}", "golang": "func minimumBeautifulSubstrings(s string) int {\n    \n}", "ruby": "# @param {String} s\n# @return {Integer}\ndef minimum_beautiful_substrings(s)\n    \nend", "scala": "object Solution {\n    def minimumBeautifulSubstrings(s: String): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn minimum_beautiful_substrings(s: String) -> i32 {\n        \n    }\n}", "racket": "(define/contract (minimum-beautiful-substrings s)\n  (-> string? exact-integer?)\n\n  )", "erlang": "-spec minimum_beautiful_substrings(S :: unicode:unicode_binary()) -> integer().\nminimum_beautiful_substrings(S) ->\n  .", "elixir": "defmodule Solution do\n  @spec minimum_beautiful_substrings(s :: String.t) :: integer\n  def minimum_beautiful_substrings(s) do\n\n  end\nend"}}
{"id": "leetcode_2730", "url": "https://leetcode.com/problems/find-the-longest-semi-repetitive-substring/", "title": "Find the Longest Semi-Repetitive Substring", "description": "You are given a **0-indexed** string `s` that consists of digits from `0` to `9`.\n\n\nA string `t` is called a **semi-repetitive** if there is at most one consecutive pair of the same digits inside `t`. For example, `0010`, `002020`, `0123`, `2002`, and `54944` are semi-repetitive while\u00a0`00101022`, and `1101234883` are not.\n\n\nReturn *the length of the longest semi-repetitive substring inside* `s`.\n\n\nA **substring** is a contiguous **non-empty** sequence of characters within a string.", "examples": ["**Input:** s = \"52233\"\n**Output:** 4\n**Explanation:** The longest semi-repetitive substring is \"5223\", which starts at i = 0 and ends at j = 3.", "**Input:** s = \"5494\"\n**Output:** 4\n**Explanation:** s is a semi-reptitive string, so the answer is 4.", "**Input:** s = \"1111111\"\n**Output:** 2\n**Explanation:** The longest semi-repetitive substring is \"11\", which starts at i = 0 and ends at j = 1."], "constraints": "**Constraints:**\n\n\n* `1 <= s.length <= 50`\n* `'0' <= s[i] <= '9'`", "difficulty": "Medium", "tags": ["String", "Sliding Window"], "hints": ["Since n is small, we can just check every substring, and if the substring is semi-repetitive, maximize the answer with its length."], "templates": {"cpp": "class Solution {\npublic:\n    int longestSemiRepetitiveSubstring(string s) {\n        \n    }\n};", "java": "class Solution {\n    public int longestSemiRepetitiveSubstring(String s) {\n        \n    }\n}", "python": "class Solution(object):\n    def longestSemiRepetitiveSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\n        ", "c": "int longestSemiRepetitiveSubstring(char * s){\n\n}", "csharp": "public class Solution {\n    public int LongestSemiRepetitiveSubstring(string s) {\n        \n    }\n}", "javascript": "/**\n * @param {string} s\n * @return {number}\n */\nvar longestSemiRepetitiveSubstring = function(s) {\n    \n};", "typescript": "function longestSemiRepetitiveSubstring(s: string): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function longestSemiRepetitiveSubstring($s) {\n        \n    }\n}", "swift": "class Solution {\n    func longestSemiRepetitiveSubstring(_ s: String) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun longestSemiRepetitiveSubstring(s: String): Int {\n        \n    }\n}", "dart": "class Solution {\n  int longestSemiRepetitiveSubstring(String s) {\n\n  }\n}", "golang": "func longestSemiRepetitiveSubstring(s string) int {\n    \n}", "ruby": "# @param {String} s\n# @return {Integer}\ndef longest_semi_repetitive_substring(s)\n    \nend", "scala": "object Solution {\n    def longestSemiRepetitiveSubstring(s: String): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn longest_semi_repetitive_substring(s: String) -> i32 {\n        \n    }\n}", "racket": "(define/contract (longest-semi-repetitive-substring s)\n  (-> string? exact-integer?)\n\n  )", "erlang": "-spec longest_semi_repetitive_substring(S :: unicode:unicode_binary()) -> integer().\nlongest_semi_repetitive_substring(S) ->\n  .", "elixir": "defmodule Solution do\n  @spec longest_semi_repetitive_substring(s :: String.t) :: integer\n  def longest_semi_repetitive_substring(s) do\n\n  end\nend"}}
{"id": "leetcode_2771", "url": "https://leetcode.com/problems/longest-non-decreasing-subarray-from-two-arrays/", "title": "Longest Non-decreasing Subarray From Two Arrays", "description": "You are given two **0-indexed** integer arrays `nums1` and `nums2` of length `n`.\n\n\nLet's define another **0-indexed** integer array, `nums3`, of length `n`. For each index `i` in the range `[0, n - 1]`, you can assign either `nums1[i]` or `nums2[i]` to `nums3[i]`.\n\n\nYour task is to maximize the length of the **longest non-decreasing subarray** in `nums3` by choosing its values optimally.\n\n\nReturn *an integer representing the length of the **longest non-decreasing** subarray in* `nums3`.\n\n\n**Note:** A **subarray** is a contiguous **non-empty** sequence of elements within an array.", "examples": ["**Input:** nums1 = [2,3,1], nums2 = [1,2,1]\n**Output:** 2\n**Explanation:** One way to construct nums3 is: \nnums3 = [nums1[0], nums2[1], nums2[2]] => [2,2,1]. \nThe subarray starting from index 0 and ending at index 1, [2,2], forms a non-decreasing subarray of length 2. \nWe can show that 2 is the maximum achievable length.", "**Input:** nums1 = [1,3,2,1], nums2 = [2,2,3,4]\n**Output:** 4\n**Explanation:** One way to construct nums3 is: \nnums3 = [nums1[0], nums2[1], nums2[2], nums2[3]] => [1,2,3,4]. \nThe entire array forms a non-decreasing subarray of length 4, making it the maximum achievable length.", "**Input:** nums1 = [1,1], nums2 = [2,2]\n**Output:** 2\n**Explanation:** One way to construct nums3 is: \nnums3 = [nums1[0], nums1[1]] => [1,1]. \nThe entire array forms a non-decreasing subarray of length 2, making it the maximum achievable length."], "constraints": "**Constraints:**\n\n\n* `1 <= nums1.length == nums2.length == n <= 105`\n* `1 <= nums1[i], nums2[i] <= 109`", "difficulty": "Medium", "tags": ["Array", "Dynamic Programming"], "hints": ["Consider using dynamic programming.", "Let dp[i][0] (dp[i][1]) be the length of the longest non-decreasing ending with nums1[i] (nums2[i]).", "Initialize dp[i][0] to 1. If nums1[i] >= nums1[i - 1] then dp[i][0] may be dp[i - 1][0] + 1. If nums1[i] >= nums2[i - 1] then dp[i][0] may be dp[i - 1][1] + 1. Perform a similar calculation for nums2[i] and dp[i][1]."], "templates": {"cpp": "class Solution {\npublic:\n    int maxNonDecreasingLength(vector<int>& nums1, vector<int>& nums2) {\n        \n    }\n};", "java": "class Solution {\n    public int maxNonDecreasingLength(int[] nums1, int[] nums2) {\n        \n    }\n}", "python": "class Solution(object):\n    def maxNonDecreasingLength(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def maxNonDecreasingLength(self, nums1: List[int], nums2: List[int]) -> int:\n        ", "c": "int maxNonDecreasingLength(int* nums1, int nums1Size, int* nums2, int nums2Size){\n\n}", "csharp": "public class Solution {\n    public int MaxNonDecreasingLength(int[] nums1, int[] nums2) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar maxNonDecreasingLength = function(nums1, nums2) {\n    \n};", "typescript": "function maxNonDecreasingLength(nums1: number[], nums2: number[]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums1\n     * @param Integer[] $nums2\n     * @return Integer\n     */\n    function maxNonDecreasingLength($nums1, $nums2) {\n        \n    }\n}", "swift": "class Solution {\n    func maxNonDecreasingLength(_ nums1: [Int], _ nums2: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun maxNonDecreasingLength(nums1: IntArray, nums2: IntArray): Int {\n        \n    }\n}", "dart": "class Solution {\n  int maxNonDecreasingLength(List<int> nums1, List<int> nums2) {\n\n  }\n}", "golang": "func maxNonDecreasingLength(nums1 []int, nums2 []int) int {\n    \n}", "ruby": "# @param {Integer[]} nums1\n# @param {Integer[]} nums2\n# @return {Integer}\ndef max_non_decreasing_length(nums1, nums2)\n    \nend", "scala": "object Solution {\n    def maxNonDecreasingLength(nums1: Array[Int], nums2: Array[Int]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn max_non_decreasing_length(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (max-non-decreasing-length nums1 nums2)\n  (-> (listof exact-integer?) (listof exact-integer?) exact-integer?)\n\n  )", "erlang": "-spec max_non_decreasing_length(Nums1 :: [integer()], Nums2 :: [integer()]) -> integer().\nmax_non_decreasing_length(Nums1, Nums2) ->\n  .", "elixir": "defmodule Solution do\n  @spec max_non_decreasing_length(nums1 :: [integer], nums2 :: [integer]) :: integer\n  def max_non_decreasing_length(nums1, nums2) do\n\n  end\nend"}}
{"id": "leetcode_2770", "url": "https://leetcode.com/problems/maximum-number-of-jumps-to-reach-the-last-index/", "title": "Maximum Number of Jumps to Reach the Last Index", "description": "You are given a **0-indexed** array `nums` of `n` integers and an integer `target`.\n\n\nYou are initially positioned at index `0`. In one step, you can jump from index `i` to any index `j` such that:\n\n\n* `0 <= i < j < n`\n* `-target <= nums[j] - nums[i] <= target`\n\n\nReturn *the **maximum number of jumps** you can make to reach index* `n - 1`.\n\n\nIf there is no way to reach index `n - 1`, return `-1`.", "examples": ["**Input:** nums = [1,3,6,4,1,2], target = 2\n**Output:** 3\n**Explanation:** To go from index 0 to index n - 1 with the maximum number of jumps, you can perform the following jumping sequence:\n- Jump from index 0 to index 1. \n- Jump from index 1 to index 3.\n- Jump from index 3 to index 5.\nIt can be proven that there is no other jumping sequence that goes from 0 to n - 1 with more than 3 jumps. Hence, the answer is 3.", "**Input:** nums = [1,3,6,4,1,2], target = 3\n**Output:** 5\n**Explanation:** To go from index 0 to index n - 1 with the maximum number of jumps, you can perform the following jumping sequence:\n- Jump from index 0 to index 1.\n- Jump from index 1 to index 2.\n- Jump from index 2 to index 3.\n- Jump from index 3 to index 4.\n- Jump from index 4 to index 5.\nIt can be proven that there is no other jumping sequence that goes from 0 to n - 1 with more than 5 jumps. Hence, the answer is 5.", "**Input:** nums = [1,3,6,4,1,2], target = 0\n**Output:** -1\n**Explanation:** It can be proven that there is no jumping sequence that goes from 0 to n - 1. Hence, the answer is -1."], "constraints": "**Constraints:**\n\n\n* `2 <= nums.length == n <= 1000`\n* `-109\u00a0<= nums[i]\u00a0<= 109`\n* `0 <= target <= 2 * 109`", "difficulty": "Medium", "tags": ["Array", "Dynamic Programming"], "hints": ["Use a dynamic programming approach.", "Define a dynamic programming array\u00a0dp\u00a0of size\u00a0n, where\u00a0dp[i]\u00a0represents the maximum number of jumps from index\u00a00\u00a0to index\u00a0i.", "For each\u00a0j\u00a0iterate over all\u00a0i < j. Set\u00a0dp[j] = max(dp[j], dp[i] + 1)\u00a0if\u00a0-target <= nums[j] - nums[i] <= target."], "templates": {"cpp": "class Solution {\npublic:\n    int maximumJumps(vector<int>& nums, int target) {\n        \n    }\n};", "java": "class Solution {\n    public int maximumJumps(int[] nums, int target) {\n        \n    }\n}", "python": "class Solution(object):\n    def maximumJumps(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def maximumJumps(self, nums: List[int], target: int) -> int:\n        ", "c": "int maximumJumps(int* nums, int numsSize, int target){\n\n}", "csharp": "public class Solution {\n    public int MaximumJumps(int[] nums, int target) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar maximumJumps = function(nums, target) {\n    \n};", "typescript": "function maximumJumps(nums: number[], target: number): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $target\n     * @return Integer\n     */\n    function maximumJumps($nums, $target) {\n        \n    }\n}", "swift": "class Solution {\n    func maximumJumps(_ nums: [Int], _ target: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun maximumJumps(nums: IntArray, target: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int maximumJumps(List<int> nums, int target) {\n\n  }\n}", "golang": "func maximumJumps(nums []int, target int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @param {Integer} target\n# @return {Integer}\ndef maximum_jumps(nums, target)\n    \nend", "scala": "object Solution {\n    def maximumJumps(nums: Array[Int], target: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn maximum_jumps(nums: Vec<i32>, target: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (maximum-jumps nums target)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n\n  )", "erlang": "-spec maximum_jumps(Nums :: [integer()], Target :: integer()) -> integer().\nmaximum_jumps(Nums, Target) ->\n  .", "elixir": "defmodule Solution do\n  @spec maximum_jumps(nums :: [integer], target :: integer) :: integer\n  def maximum_jumps(nums, target) do\n\n  end\nend"}}
{"id": "leetcode_2731", "url": "https://leetcode.com/problems/movement-of-robots/", "title": "Movement of Robots", "description": "Some robots are standing on an infinite number line with their initial coordinates given by a **0-indexed** integer array `nums` and will start moving once given the command to move. The robots will move a unit distance each second.\n\n\nYou are given a string `s` denoting the direction in which robots will move on command. `'L'` means the robot will move towards the left side or negative side of the number line, whereas `'R'` means the robot will move towards the right side or positive side of the number line.\n\n\nIf two robots collide, they will start moving in opposite directions.\n\n\nReturn *the sum of distances between all the\u00a0pairs of robots* `d` *seconds after\u00a0the command.* Since the sum can be very large, return it modulo `109 + 7`.\n\n\n**Note:** \n\n\n* For two robots at the index `i` and `j`, pair `(i,j)` and pair `(j,i)` are considered the same pair.\n* When robots collide, they **instantly change** their directions without wasting any time.\n* Collision happens\u00a0when two robots share the same place in a\u00a0moment.\n\t+ For example, if a robot is positioned in 0 going to the right and another is positioned in 2 going to the left, the next second they'll be both in 1 and they will change direction and the next second the first one will be in 0, heading left, and another will be in 2, heading right.\n\t+ For example,\u00a0if a robot is positioned in 0 going to the right and another is positioned in 1\u00a0going to the left, the next second the first one will be in 0, heading left, and another will be in 1, heading right.", "examples": ["**Input:** nums = [-2,0,2], s = \"RLL\", d = 3\n**Output:** 8\n**Explanation:** \nAfter 1 second, the positions are [-1,-1,1]. Now, the robot at index 0 will move left, and the robot at index 1 will move right.\nAfter 2 seconds, the positions are [-2,0,0]. Now, the robot at index 1 will move left, and the robot at index 2 will move right.\nAfter 3 seconds, the positions are [-3,-1,1].\nThe distance between the robot at index 0 and 1 is abs(-3 - (-1)) = 2.\nThe distance between the robot at index 0 and 2 is abs(-3 - 1) = 4.\nThe distance between the robot at index 1 and 2 is abs(-1 - 1) = 2.\nThe sum of the pairs of all distances = 2 + 4 + 2 = 8.", "**Input:** nums = [1,0], s = \"RL\", d = 2\n**Output:** 5\n**Explanation:** \nAfter 1 second, the positions are [2,-1].\nAfter 2 seconds, the positions are [3,-2].\nThe distance between the two robots is abs(-2 - 3) = 5."], "constraints": "**Constraints:**\n\n\n* `2 <= nums.length <= 105`\n* `-2 * 109\u00a0<= nums[i] <= 2 * 109`\n* `0 <= d <= 109`\n* `nums.length == s.length`\n* `s` consists of 'L' and 'R' only\n* `nums[i]`\u00a0will be unique.", "difficulty": "Medium", "tags": ["Array", "Brainteaser", "Sorting", "Prefix Sum"], "hints": ["Observe that if you ignore collisions, the resultant positions of robots after d seconds would be the same.", "After d seconds, sort the ending positions and use prefix sum to calculate the distance sum."], "templates": {"cpp": "class Solution {\npublic:\n    int sumDistance(vector<int>& nums, string s, int d) {\n        \n    }\n};", "java": "class Solution {\n    public int sumDistance(int[] nums, String s, int d) {\n        \n    }\n}", "python": "class Solution(object):\n    def sumDistance(self, nums, s, d):\n        \"\"\"\n        :type nums: List[int]\n        :type s: str\n        :type d: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def sumDistance(self, nums: List[int], s: str, d: int) -> int:\n        ", "c": "int sumDistance(int* nums, int numsSize, char * s, int d){\n\n}", "csharp": "public class Solution {\n    public int SumDistance(int[] nums, string s, int d) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @param {string} s\n * @param {number} d\n * @return {number}\n */\nvar sumDistance = function(nums, s, d) {\n    \n};", "typescript": "function sumDistance(nums: number[], s: string, d: number): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param String $s\n     * @param Integer $d\n     * @return Integer\n     */\n    function sumDistance($nums, $s, $d) {\n        \n    }\n}", "swift": "class Solution {\n    func sumDistance(_ nums: [Int], _ s: String, _ d: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun sumDistance(nums: IntArray, s: String, d: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int sumDistance(List<int> nums, String s, int d) {\n\n  }\n}", "golang": "func sumDistance(nums []int, s string, d int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @param {String} s\n# @param {Integer} d\n# @return {Integer}\ndef sum_distance(nums, s, d)\n    \nend", "scala": "object Solution {\n    def sumDistance(nums: Array[Int], s: String, d: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn sum_distance(nums: Vec<i32>, s: String, d: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (sum-distance nums s d)\n  (-> (listof exact-integer?) string? exact-integer? exact-integer?)\n\n  )", "erlang": "-spec sum_distance(Nums :: [integer()], S :: unicode:unicode_binary(), D :: integer()) -> integer().\nsum_distance(Nums, S, D) ->\n  .", "elixir": "defmodule Solution do\n  @spec sum_distance(nums :: [integer], s :: String.t, d :: integer) :: integer\n  def sum_distance(nums, s, d) do\n\n  end\nend"}}
{"id": "leetcode_2789", "url": "https://leetcode.com/problems/largest-element-in-an-array-after-merge-operations/", "title": "Largest Element in an Array after Merge Operations", "description": "You are given a **0-indexed** array `nums` consisting of positive integers.\n\n\nYou can do the following operation on the array **any** number of times:\n\n\n* Choose an integer `i` such that `0 <= i < nums.length - 1` and `nums[i] <= nums[i + 1]`. Replace the element `nums[i + 1]` with `nums[i] + nums[i + 1]` and delete the element `nums[i]` from the array.\n\n\nReturn *the value of the **largest** element that you can possibly obtain in the final array.*", "examples": ["**Input:** nums = [2,3,7,9,3]\n**Output:** 21\n**Explanation:** We can apply the following operations on the array:\n- Choose i = 0. The resulting array will be nums = [5,7,9,3].\n- Choose i = 1. The resulting array will be nums = [5,16,3].\n- Choose i = 0. The resulting array will be nums = [21,3].\nThe largest element in the final array is 21. It can be shown that we cannot obtain a larger element.", "**Input:** nums = [5,3,3]\n**Output:** 11\n**Explanation:** We can do the following operations on the array:\n- Choose i = 1. The resulting array will be nums = [5,6].\n- Choose i = 0. The resulting array will be nums = [11].\nThere is only one element in the final array, which is 11."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `1 <= nums[i] <= 106`", "difficulty": "Medium", "tags": ["Array", "Greedy", "Prefix Sum"], "hints": ["Start from the end of the array and keep merging elements together until it is no longer possible.", "The answer will be the resulting element from the last merge operation."], "templates": {"cpp": "class Solution {\npublic:\n    long long maxArrayValue(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public long maxArrayValue(int[] nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def maxArrayValue(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def maxArrayValue(self, nums: List[int]) -> int:\n        ", "c": "long long maxArrayValue(int* nums, int numsSize){\n\n}", "csharp": "public class Solution {\n    public long MaxArrayValue(int[] nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxArrayValue = function(nums) {\n    \n};", "typescript": "function maxArrayValue(nums: number[]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function maxArrayValue($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func maxArrayValue(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun maxArrayValue(nums: IntArray): Long {\n        \n    }\n}", "dart": "class Solution {\n  int maxArrayValue(List<int> nums) {\n\n  }\n}", "golang": "func maxArrayValue(nums []int) int64 {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef max_array_value(nums)\n    \nend", "scala": "object Solution {\n    def maxArrayValue(nums: Array[Int]): Long = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn max_array_value(nums: Vec<i32>) -> i64 {\n        \n    }\n}", "racket": "(define/contract (max-array-value nums)\n  (-> (listof exact-integer?) exact-integer?)\n\n  )", "erlang": "-spec max_array_value(Nums :: [integer()]) -> integer().\nmax_array_value(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec max_array_value(nums :: [integer]) :: integer\n  def max_array_value(nums) do\n\n  end\nend"}}
{"id": "leetcode_2766", "url": "https://leetcode.com/problems/relocate-marbles/", "title": "Relocate Marbles", "description": "You are given a **0-indexed** integer array `nums` representing the initial positions of some marbles. You are also given two **0-indexed** integer arrays `moveFrom` and `moveTo` of **equal** length.\n\n\nThroughout `moveFrom.length` steps, you will change the positions of the marbles. On the `ith` step, you will move **all** marbles at position `moveFrom[i]` to position `moveTo[i]`.\n\n\nAfter completing all the steps, return *the sorted list of **occupied** positions*.\n\n\n**Notes:**\n\n\n* We call a position **occupied** if there is at least one marble in that position.\n* There may be multiple marbles in a single position.", "examples": ["**Input:** nums = [1,6,7,8], moveFrom = [1,7,2], moveTo = [2,9,5]\n**Output:** [5,6,8,9]\n**Explanation:** Initially, the marbles are at positions 1,6,7,8.\nAt the i = 0th step, we move the marbles at position 1 to position 2. Then, positions 2,6,7,8 are occupied.\nAt the i = 1st step, we move the marbles at position 7 to position 9. Then, positions 2,6,8,9 are occupied.\nAt the i = 2nd step, we move the marbles at position 2 to position 5. Then, positions 5,6,8,9 are occupied.\nAt the end, the final positions containing at least one marbles are [5,6,8,9].", "**Input:** nums = [1,1,3,3], moveFrom = [1,3], moveTo = [2,2]\n**Output:** [2]\n**Explanation:** Initially, the marbles are at positions [1,1,3,3].\nAt the i = 0th step, we move all the marbles at position 1 to position 2. Then, the marbles are at positions [2,2,3,3].\nAt the i = 1st step, we move all the marbles at position 3 to position 2. Then, the marbles are at positions [2,2,2,2].\nSince 2 is the only occupied position, we return [2]."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `1 <= moveFrom.length <= 105`\n* `moveFrom.length == moveTo.length`\n* `1 <= nums[i], moveFrom[i], moveTo[i] <= 109`\n* The test cases are generated such that there is at least a marble in\u00a0`moveFrom[i]`\u00a0at the moment we want to apply\u00a0the `ith`\u00a0move.", "difficulty": "Medium", "tags": ["Array", "Hash Table", "Sorting", "Simulation"], "hints": ["Can we solve this problem using a set or map?", "Sequentially process pairs from moveFrom[i] and moveTo[i]. In each step, remove the occurrence of moveFrom[i] and add moveTo[i] into the set."], "templates": {"cpp": "class Solution {\npublic:\n    vector<int> relocateMarbles(vector<int>& nums, vector<int>& moveFrom, vector<int>& moveTo) {\n        \n    }\n};", "java": "class Solution {\n    public List<Integer> relocateMarbles(int[] nums, int[] moveFrom, int[] moveTo) {\n        \n    }\n}", "python": "class Solution(object):\n    def relocateMarbles(self, nums, moveFrom, moveTo):\n        \"\"\"\n        :type nums: List[int]\n        :type moveFrom: List[int]\n        :type moveTo: List[int]\n        :rtype: List[int]\n        \"\"\"\n        ", "python3": "class Solution:\n    def relocateMarbles(self, nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n        ", "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* relocateMarbles(int* nums, int numsSize, int* moveFrom, int moveFromSize, int* moveTo, int moveToSize, int* returnSize){\n\n}", "csharp": "public class Solution {\n    public IList<int> RelocateMarbles(int[] nums, int[] moveFrom, int[] moveTo) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @param {number[]} moveFrom\n * @param {number[]} moveTo\n * @return {number[]}\n */\nvar relocateMarbles = function(nums, moveFrom, moveTo) {\n    \n};", "typescript": "function relocateMarbles(nums: number[], moveFrom: number[], moveTo: number[]): number[] {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer[] $moveFrom\n     * @param Integer[] $moveTo\n     * @return Integer[]\n     */\n    function relocateMarbles($nums, $moveFrom, $moveTo) {\n        \n    }\n}", "swift": "class Solution {\n    func relocateMarbles(_ nums: [Int], _ moveFrom: [Int], _ moveTo: [Int]) -> [Int] {\n        \n    }\n}", "kotlin": "class Solution {\n    fun relocateMarbles(nums: IntArray, moveFrom: IntArray, moveTo: IntArray): List<Int> {\n        \n    }\n}", "dart": "class Solution {\n  List<int> relocateMarbles(List<int> nums, List<int> moveFrom, List<int> moveTo) {\n\n  }\n}", "golang": "func relocateMarbles(nums []int, moveFrom []int, moveTo []int) []int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @param {Integer[]} move_from\n# @param {Integer[]} move_to\n# @return {Integer[]}\ndef relocate_marbles(nums, move_from, move_to)\n    \nend", "scala": "object Solution {\n    def relocateMarbles(nums: Array[Int], moveFrom: Array[Int], moveTo: Array[Int]): List[Int] = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn relocate_marbles(nums: Vec<i32>, move_from: Vec<i32>, move_to: Vec<i32>) -> Vec<i32> {\n        \n    }\n}", "racket": "(define/contract (relocate-marbles nums moveFrom moveTo)\n  (-> (listof exact-integer?) (listof exact-integer?) (listof exact-integer?) (listof exact-integer?))\n\n  )", "erlang": "-spec relocate_marbles(Nums :: [integer()], MoveFrom :: [integer()], MoveTo :: [integer()]) -> [integer()].\nrelocate_marbles(Nums, MoveFrom, MoveTo) ->\n  .", "elixir": "defmodule Solution do\n  @spec relocate_marbles(nums :: [integer], move_from :: [integer], move_to :: [integer]) :: [integer]\n  def relocate_marbles(nums, move_from, move_to) do\n\n  end\nend"}}
{"id": "leetcode_2967", "url": "https://leetcode.com/problems/minimum-cost-to-make-array-equalindromic/", "title": "Minimum Cost to Make Array Equalindromic", "description": "You are given a **0-indexed** integer array `nums` having length `n`.\n\n\nYou are allowed to perform a special move **any** number of times (**including zero**) on `nums`. In one **special** **move** you perform the following steps **in order**:\n\n\n* Choose an index `i` in the range `[0, n - 1]`, and a **positive** integer `x`.\n* Add `|nums[i] - x|` to the total cost.\n* Change the value of `nums[i]` to `x`.\n\n\nA **palindromic number** is a positive integer that remains the same when its digits are reversed. For example, `121`, `2552` and `65756` are palindromic numbers whereas `24`, `46`, `235` are not palindromic numbers.\n\n\nAn array is considered **equalindromic** if all the elements in the array are equal to an integer `y`, where `y` is a **palindromic number** less than `109`.\n\n\nReturn *an integer denoting the **minimum** possible total cost to make* `nums` ***equalindromic** by performing any number of special moves.*", "examples": ["**Input:** nums = [1,2,3,4,5]\n**Output:** 6\n**Explanation:** We can make the array equalindromic by changing all elements to 3 which is a palindromic number. The cost of changing the array to [3,3,3,3,3] using 4 special moves is given by |1 - 3| + |2 - 3| + |4 - 3| + |5 - 3| = 6.\nIt can be shown that changing all elements to any palindromic number other than 3 cannot be achieved at a lower cost.", "**Input:** nums = [10,12,13,14,15]\n**Output:** 11\n**Explanation:** We can make the array equalindromic by changing all elements to 11 which is a palindromic number. The cost of changing the array to [11,11,11,11,11] using 5 special moves is given by |10 - 11| + |12 - 11| + |13 - 11| + |14 - 11| + |15 - 11| = 11.\nIt can be shown that changing all elements to any palindromic number other than 11 cannot be achieved at a lower cost.", "**Input:** nums = [22,33,22,33,22]\n**Output:** 22\n**Explanation:** We can make the array equalindromic by changing all elements to 22 which is a palindromic number. The cost of changing the array to [22,22,22,22,22] using 2 special moves is given by |33 - 22| + |33 - 22| = 22.\nIt can be shown that changing all elements to any palindromic number other than 22 cannot be achieved at a lower cost."], "constraints": "**Constraints:**\n\n\n* `1 <= n <= 105`\n* `1 <= nums[i] <= 109`", "difficulty": "Medium", "tags": ["Array", "Math", "Greedy", "Sorting"], "hints": ["Find the median of <code>nums</code> after sorting it (if the length is even, we can select any number from the two in the middle). Let\u2019s call it <code>m</code>.", "Try the smallest palindromic number that is larger than or equal to <code>m</code> (if any) and the largest palindromic number that is smaller than or equal to <code>m</code> (if any). These two values are the candidate palindromic numbers for values of all indices.", "We can use math constructions to construct the two palindromic numbers in <code>O(log(m) / 2)</code> time or we can do it using brute-force by starting from m and checking smaller and larger values in <code>O(sqrt(10<sup>log(m)</sup>))</code>.", "It is also possible to just generate all palindromic numbers using recursion in <code>O(sqrt(10<sup>9</sup>))</code>."], "templates": {"cpp": "class Solution {\npublic:\n    long long minimumCost(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public long minimumCost(int[] nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def minimumCost(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def minimumCost(self, nums: List[int]) -> int:\n        ", "c": "long long minimumCost(int* nums, int numsSize) {\n    \n}", "csharp": "public class Solution {\n    public long MinimumCost(int[] nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minimumCost = function(nums) {\n    \n};", "typescript": "function minimumCost(nums: number[]): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function minimumCost($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func minimumCost(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun minimumCost(nums: IntArray): Long {\n        \n    }\n}", "dart": "class Solution {\n  int minimumCost(List<int> nums) {\n    \n  }\n}", "golang": "func minimumCost(nums []int) int64 {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef minimum_cost(nums)\n    \nend", "scala": "object Solution {\n    def minimumCost(nums: Array[Int]): Long = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn minimum_cost(nums: Vec<i32>) -> i64 {\n        \n    }\n}", "racket": "(define/contract (minimum-cost nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )", "erlang": "-spec minimum_cost(Nums :: [integer()]) -> integer().\nminimum_cost(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec minimum_cost(nums :: [integer]) :: integer\n  def minimum_cost(nums) do\n    \n  end\nend"}}
{"id": "leetcode_2875", "url": "https://leetcode.com/problems/minimum-size-subarray-in-infinite-array/", "title": "Minimum Size Subarray in Infinite Array", "description": "You are given a **0-indexed** array `nums` and an integer `target`.\n\n\nA **0-indexed** array `infinite_nums` is generated by infinitely appending the elements of `nums` to itself.\n\n\nReturn *the length of the **shortest** subarray of the array* `infinite_nums` *with a sum equal to* `target`*.* If there is no such subarray return `-1`.", "examples": ["**Input:** nums = [1,2,3], target = 5\n**Output:** 2\n**Explanation:** In this example infinite_nums = [1,2,3,1,2,3,1,2,...].\nThe subarray in the range [1,2], has the sum equal to target = 5 and length = 2.\nIt can be proven that 2 is the shortest length of a subarray with sum equal to target = 5.", "**Input:** nums = [1,1,1,2,3], target = 4\n**Output:** 2\n**Explanation:** In this example infinite_nums = [1,1,1,2,3,1,1,1,2,3,1,1,...].\nThe subarray in the range [4,5], has the sum equal to target = 4 and length = 2.\nIt can be proven that 2 is the shortest length of a subarray with sum equal to target = 4.", "**Input:** nums = [2,4,6,8], target = 3\n**Output:** -1\n**Explanation:** In this example infinite_nums = [2,4,6,8,2,4,6,8,...].\nIt can be proven that there is no subarray with sum equal to target = 3."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `1 <= nums[i] <= 105`\n* `1 <= target <= 109`", "difficulty": "Medium", "tags": ["Array", "Hash Table", "Sliding Window", "Prefix Sum"], "hints": ["Notice that, <code>target</code> is either: A subarray of <code>nums</code>, or <code>prefix_sum[i]</code> + <code> k * sum(nums) </code> + <code>suffix_sum[j]</code> for some <code>i, j, k</code>.", "You can solve the problem for those two separate cases using hash map and prefix sums."], "templates": {"cpp": "class Solution {\npublic:\n    int minSizeSubarray(vector<int>& nums, int target) {\n        \n    }\n};", "java": "class Solution {\n    public int minSizeSubarray(int[] nums, int target) {\n        \n    }\n}", "python": "class Solution(object):\n    def minSizeSubarray(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def minSizeSubarray(self, nums: List[int], target: int) -> int:\n        ", "c": "int minSizeSubarray(int* nums, int numsSize, int target) {\n    \n}", "csharp": "public class Solution {\n    public int MinSizeSubarray(int[] nums, int target) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar minSizeSubarray = function(nums, target) {\n    \n};", "typescript": "function minSizeSubarray(nums: number[], target: number): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $target\n     * @return Integer\n     */\n    function minSizeSubarray($nums, $target) {\n        \n    }\n}", "swift": "class Solution {\n    func minSizeSubarray(_ nums: [Int], _ target: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun minSizeSubarray(nums: IntArray, target: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int minSizeSubarray(List<int> nums, int target) {\n    \n  }\n}", "golang": "func minSizeSubarray(nums []int, target int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @param {Integer} target\n# @return {Integer}\ndef min_size_subarray(nums, target)\n    \nend", "scala": "object Solution {\n    def minSizeSubarray(nums: Array[Int], target: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn min_size_subarray(nums: Vec<i32>, target: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (min-size-subarray nums target)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )", "erlang": "-spec min_size_subarray(Nums :: [integer()], Target :: integer()) -> integer().\nmin_size_subarray(Nums, Target) ->\n  .", "elixir": "defmodule Solution do\n  @spec min_size_subarray(nums :: [integer], target :: integer) :: integer\n  def min_size_subarray(nums, target) do\n    \n  end\nend"}}
{"id": "leetcode_2930", "url": "https://leetcode.com/problems/number-of-strings-which-can-be-rearranged-to-contain-substring/", "title": "Number of Strings Which Can Be Rearranged to Contain Substring", "description": "You are given an integer `n`.\n\n\nA string `s` is called **good** if it contains only lowercase English characters **and** it is possible to rearrange the characters of `s` such that the new string contains `\"leet\"` as a **substring**.\n\n\nFor example:\n\n\n* The string `\"lteer\"` is good because we can rearrange it to form `\"leetr\"` .\n* `\"letl\"` is not good because we cannot rearrange it to contain `\"leet\"` as a substring.\n\n\nReturn *the **total** number of good strings of length* `n`.\n\n\nSince the answer may be large, return it **modulo** `109 + 7`.\n\n\nA **substring** is a contiguous sequence of characters within a string.", "examples": ["**Input:** n = 4\n**Output:** 12\n**Explanation:** The 12 strings which can be rearranged to have \"leet\" as a substring are: \"eelt\", \"eetl\", \"elet\", \"elte\", \"etel\", \"etle\", \"leet\", \"lete\", \"ltee\", \"teel\", \"tele\", and \"tlee\".", "**Input:** n = 10\n**Output:** 83943898\n**Explanation:** The number of strings with length 10 which can be rearranged to have \"leet\" as a substring is 526083947580. Hence the answer is 526083947580 % (109 + 7) = 83943898."], "constraints": "**Constraints:**\n\n\n* `1 <= n <= 105`", "difficulty": "Medium", "tags": ["Math", "Dynamic Programming", "Combinatorics"], "hints": ["A good string must contain at least one <code>l</code>, one <code>t</code>, and two <code>e</code>.", "Divide the problem into subproblems and use Dynamic Programming."], "templates": {"cpp": "class Solution {\npublic:\n    int stringCount(int n) {\n        \n    }\n};", "java": "class Solution {\n    public int stringCount(int n) {\n        \n    }\n}", "python": "class Solution(object):\n    def stringCount(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def stringCount(self, n: int) -> int:\n        ", "c": "int stringCount(int n) {\n    \n}", "csharp": "public class Solution {\n    public int StringCount(int n) {\n        \n    }\n}", "javascript": "/**\n * @param {number} n\n * @return {number}\n */\nvar stringCount = function(n) {\n    \n};", "typescript": "function stringCount(n: number): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return Integer\n     */\n    function stringCount($n) {\n        \n    }\n}", "swift": "class Solution {\n    func stringCount(_ n: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun stringCount(n: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int stringCount(int n) {\n    \n  }\n}", "golang": "func stringCount(n int) int {\n    \n}", "ruby": "# @param {Integer} n\n# @return {Integer}\ndef string_count(n)\n    \nend", "scala": "object Solution {\n    def stringCount(n: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn string_count(n: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (string-count n)\n  (-> exact-integer? exact-integer?)\n  )", "erlang": "-spec string_count(N :: integer()) -> integer().\nstring_count(N) ->\n  .", "elixir": "defmodule Solution do\n  @spec string_count(n :: integer) :: integer\n  def string_count(n) do\n    \n  end\nend"}}
{"id": "leetcode_2834", "url": "https://leetcode.com/problems/find-the-minimum-possible-sum-of-a-beautiful-array/", "title": "Find the Minimum Possible Sum of a Beautiful Array", "description": "You are given positive integers `n` and `target`.\n\n\nAn array `nums` is **beautiful** if it meets the following conditions:\n\n\n* `nums.length == n`.\n* `nums` consists of pairwise **distinct** **positive** integers.\n* There doesn't exist two **distinct** indices, `i` and `j`, in the range `[0, n - 1]`, such that `nums[i] + nums[j] == target`.\n\n\nReturn *the **minimum** possible sum that a beautiful array could have modulo* `109 + 7`.", "examples": ["**Input:** n = 2, target = 3\n**Output:** 4\n**Explanation:** We can see that nums = [1,3] is beautiful.\n- The array nums has length n = 2.\n- The array nums consists of pairwise distinct positive integers.\n- There doesn't exist two distinct indices, i and j, with nums[i] + nums[j] == 3.\nIt can be proven that 4 is the minimum possible sum that a beautiful array could have.", "**Input:** n = 3, target = 3\n**Output:** 8\n**Explanation:** We can see that nums = [1,3,4] is beautiful.\n- The array nums has length n = 3.\n- The array nums consists of pairwise distinct positive integers.\n- There doesn't exist two distinct indices, i and j, with nums[i] + nums[j] == 3.\nIt can be proven that 8 is the minimum possible sum that a beautiful array could have.", "**Input:** n = 1, target = 1\n**Output:** 1\n**Explanation:** We can see, that nums = [1] is beautiful."], "constraints": "**Constraints:**\n\n\n* `1 <= n <= 109`\n* `1 <= target <= 109`", "difficulty": "Medium", "tags": ["Math", "Greedy"], "hints": ["<div class=\"_1l1MA\">Greedily try to add the smallest possible number in the array <code>nums</code>, such that <code>nums</code> contains distinct positive integers, and there are no two indices <code>i</code> and <code>j</code> with <code>nums[i] + nums[j] == target</code>.</div>"], "templates": {"cpp": "class Solution {\npublic:\n    int minimumPossibleSum(int n, int target) {\n        \n    }\n};", "java": "class Solution {\n    public int minimumPossibleSum(int n, int target) {\n        \n    }\n}", "python": "class Solution(object):\n    def minimumPossibleSum(self, n, target):\n        \"\"\"\n        :type n: int\n        :type target: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def minimumPossibleSum(self, n: int, target: int) -> int:\n        ", "c": "int minimumPossibleSum(int n, int target){\n\n}", "csharp": "public class Solution {\n    public int MinimumPossibleSum(int n, int target) {\n        \n    }\n}", "javascript": "/**\n * @param {number} n\n * @param {number} target\n * @return {number}\n */\nvar minimumPossibleSum = function(n, target) {\n    \n};", "typescript": "function minimumPossibleSum(n: number, target: number): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer $target\n     * @return Integer\n     */\n    function minimumPossibleSum($n, $target) {\n        \n    }\n}", "swift": "class Solution {\n    func minimumPossibleSum(_ n: Int, _ target: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun minimumPossibleSum(n: Int, target: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int minimumPossibleSum(int n, int target) {\n\n  }\n}", "golang": "func minimumPossibleSum(n int, target int) int {\n    \n}", "ruby": "# @param {Integer} n\n# @param {Integer} target\n# @return {Integer}\ndef minimum_possible_sum(n, target)\n    \nend", "scala": "object Solution {\n    def minimumPossibleSum(n: Int, target: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn minimum_possible_sum(n: i32, target: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (minimum-possible-sum n target)\n  (-> exact-integer? exact-integer? exact-integer?)\n\n  )", "erlang": "-spec minimum_possible_sum(N :: integer(), Target :: integer()) -> integer().\nminimum_possible_sum(N, Target) ->\n  .", "elixir": "defmodule Solution do\n  @spec minimum_possible_sum(n :: integer, target :: integer) :: integer\n  def minimum_possible_sum(n, target) do\n\n  end\nend"}}
{"id": "leetcode_2971", "url": "https://leetcode.com/problems/find-polygon-with-the-largest-perimeter/", "title": "Find Polygon With the Largest Perimeter", "description": "You are given an array of **positive** integers `nums` of length `n`.\n\n\nA **polygon** is a closed plane figure that has at least `3` sides. The **longest side** of a polygon is **smaller** than the sum of its other sides.\n\n\nConversely, if you have `k` (`k >= 3`) **positive** real numbers `a1`, `a2`, `a3`, ..., `ak` where `a1 <= a2 <= a3 <= ... <= ak` **and** `a1 + a2 + a3 + ... + ak-1 > ak`, then there **always** exists a polygon with `k` sides whose lengths are `a1`, `a2`, `a3`, ..., `ak`.\n\n\nThe **perimeter** of a polygon is the sum of lengths of its sides.\n\n\nReturn *the **largest** possible **perimeter** of a **polygon** whose sides can be formed from* `nums`, *or* `-1` *if it is not possible to create a polygon*.", "examples": ["**Input:** nums = [5,5,5]\n**Output:** 15\n**Explanation:** The only possible polygon that can be made from nums has 3 sides: 5, 5, and 5. The perimeter is 5 + 5 + 5 = 15.", "**Input:** nums = [1,12,1,2,5,50,3]\n**Output:** 12\n**Explanation:** The polygon with the largest perimeter which can be made from nums has 5 sides: 1, 1, 2, 3, and 5. The perimeter is 1 + 1 + 2 + 3 + 5 = 12.\nWe cannot have a polygon with either 12 or 50 as the longest side because it is not possible to include 2 or more smaller sides that have a greater sum than either of them.\nIt can be shown that the largest possible perimeter is 12.", "**Input:** nums = [5,5,50]\n**Output:** -1\n**Explanation:** There is no possible way to form a polygon from nums, as a polygon has at least 3 sides and 50 > 5 + 5."], "constraints": "**Constraints:**\n\n\n* `3 <= n <= 105`\n* `1 <= nums[i] <= 109`", "difficulty": "Medium", "tags": [], "hints": ["Sort the array.", "Use greedy algorithm. If we select an edge as the longest side, it is always better to pick up all the edges with length no longer than this longest edge.", "Note that the number of edges should not be less than 3."], "templates": {"cpp": "class Solution {\npublic:\n    long long largestPerimeter(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public long largestPerimeter(int[] nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def largestPerimeter(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def largestPerimeter(self, nums: List[int]) -> int:\n        ", "c": "long long largestPerimeter(int* nums, int numsSize) {\n    \n}", "csharp": "public class Solution {\n    public long LargestPerimeter(int[] nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar largestPerimeter = function(nums) {\n    \n};", "typescript": "function largestPerimeter(nums: number[]): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function largestPerimeter($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func largestPerimeter(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun largestPerimeter(nums: IntArray): Long {\n        \n    }\n}", "dart": "class Solution {\n  int largestPerimeter(List<int> nums) {\n    \n  }\n}", "golang": "func largestPerimeter(nums []int) int64 {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef largest_perimeter(nums)\n    \nend", "scala": "object Solution {\n    def largestPerimeter(nums: Array[Int]): Long = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn largest_perimeter(nums: Vec<i32>) -> i64 {\n        \n    }\n}", "racket": "(define/contract (largest-perimeter nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )", "erlang": "-spec largest_perimeter(Nums :: [integer()]) -> integer().\nlargest_perimeter(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec largest_perimeter(nums :: [integer]) :: integer\n  def largest_perimeter(nums) do\n    \n  end\nend"}}
{"id": "leetcode_2906", "url": "https://leetcode.com/problems/construct-product-matrix/", "title": "Construct Product Matrix", "description": "Given a **0-indexed** 2D integer matrix `grid` of size `n * m`, we define a **0-indexed** 2D matrix `p` of size `n * m` as the **product** matrix of `grid` if the following condition is met:\n\n\n* Each element `p[i][j]` is calculated as the product of all elements in `grid` except for the element `grid[i][j]`. This product is then taken modulo `12345`.\n\n\nReturn *the product matrix of* `grid`.", "examples": ["**Input:** grid = [[1,2],[3,4]]\n**Output:** [[24,12],[8,6]]\n**Explanation:** p[0][0] = grid[0][1] * grid[1][0] * grid[1][1] = 2 * 3 * 4 = 24\np[0][1] = grid[0][0] * grid[1][0] * grid[1][1] = 1 * 3 * 4 = 12\np[1][0] = grid[0][0] * grid[0][1] * grid[1][1] = 1 * 2 * 4 = 8\np[1][1] = grid[0][0] * grid[0][1] * grid[1][0] = 1 * 2 * 3 = 6\nSo the answer is [[24,12],[8,6]].", "**Input:** grid = [[12345],[2],[1]]\n**Output:** [[2],[0],[0]]\n**Explanation:** p[0][0] = grid[0][1] * grid[0][2] = 2 * 1 = 2.\np[0][1] = grid[0][0] * grid[0][2] = 12345 * 1 = 12345. 12345 % 12345 = 0. So p[0][1] = 0.\np[0][2] = grid[0][0] * grid[0][1] = 12345 * 2 = 24690. 24690 % 12345 = 0. So p[0][2] = 0.\nSo the answer is [[2],[0],[0]]."], "constraints": "**Constraints:**\n\n\n* `1 <= n == grid.length\u00a0<= 105`\n* `1 <= m == grid[i].length\u00a0<= 105`\n* `2 <= n * m <= 105`\n* `1 <= grid[i][j] <= 109`", "difficulty": "Medium", "tags": ["Array", "Matrix", "Prefix Sum"], "hints": ["Try to solve this without using the <code>'/'</code> (division operation).", "Create two 2D arrays for <b>suffix</b> and <b>prefix</b> product, and use them to find the product for each position."], "templates": {"cpp": "class Solution {\npublic:\n    vector<vector<int>> constructProductMatrix(vector<vector<int>>& grid) {\n        \n    }\n};", "java": "class Solution {\n    public int[][] constructProductMatrix(int[][] grid) {\n        \n    }\n}", "python": "class Solution(object):\n    def constructProductMatrix(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        ", "python3": "class Solution:\n    def constructProductMatrix(self, grid: List[List[int]]) -> List[List[int]]:\n        ", "c": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** constructProductMatrix(int** grid, int gridSize, int* gridColSize, int* returnSize, int** returnColumnSizes) {\n    \n}", "csharp": "public class Solution {\n    public int[][] ConstructProductMatrix(int[][] grid) {\n        \n    }\n}", "javascript": "/**\n * @param {number[][]} grid\n * @return {number[][]}\n */\nvar constructProductMatrix = function(grid) {\n    \n};", "typescript": "function constructProductMatrix(grid: number[][]): number[][] {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[][] $grid\n     * @return Integer[][]\n     */\n    function constructProductMatrix($grid) {\n        \n    }\n}", "swift": "class Solution {\n    func constructProductMatrix(_ grid: [[Int]]) -> [[Int]] {\n        \n    }\n}", "kotlin": "class Solution {\n    fun constructProductMatrix(grid: Array<IntArray>): Array<IntArray> {\n        \n    }\n}", "dart": "class Solution {\n  List<List<int>> constructProductMatrix(List<List<int>> grid) {\n    \n  }\n}", "golang": "func constructProductMatrix(grid [][]int) [][]int {\n    \n}", "ruby": "# @param {Integer[][]} grid\n# @return {Integer[][]}\ndef construct_product_matrix(grid)\n    \nend", "scala": "object Solution {\n    def constructProductMatrix(grid: Array[Array[Int]]): Array[Array[Int]] = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn construct_product_matrix(grid: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n        \n    }\n}", "racket": "(define/contract (construct-product-matrix grid)\n  (-> (listof (listof exact-integer?)) (listof (listof exact-integer?)))\n  )", "erlang": "-spec construct_product_matrix(Grid :: [[integer()]]) -> [[integer()]].\nconstruct_product_matrix(Grid) ->\n  .", "elixir": "defmodule Solution do\n  @spec construct_product_matrix(grid :: [[integer]]) :: [[integer]]\n  def construct_product_matrix(grid) do\n    \n  end\nend"}}
{"id": "leetcode_2947", "url": "https://leetcode.com/problems/count-beautiful-substrings-i/", "title": "Count Beautiful Substrings I", "description": "You are given a string `s` and a positive integer `k`.\n\n\nLet `vowels` and `consonants` be the number of vowels and consonants in a string.\n\n\nA string is **beautiful** if:\n\n\n* `vowels == consonants`.\n* `(vowels * consonants) % k == 0`, in other terms the multiplication of `vowels` and `consonants` is divisible by `k`.\n\n\nReturn *the number of **non-empty beautiful substrings** in the given string* `s`.\n\n\nA **substring** is a contiguous sequence of characters in a string.\n\n\n**Vowel letters** in English are `'a'`, `'e'`, `'i'`, `'o'`, and `'u'`.\n\n\n**Consonant letters** in English are every letter except vowels.", "examples": ["**Input:** s = \"baeyh\", k = 2\n**Output:** 2\n**Explanation:** There are 2 beautiful substrings in the given string.\n- Substring \"baeyh\", vowels = 2 ([\"a\",e\"]), consonants = 2 ([\"y\",\"h\"]).\nYou can see that string \"aeyh\" is beautiful as vowels == consonants and vowels * consonants % k == 0.\n- Substring \"baeyh\", vowels = 2 ([\"a\",e\"]), consonants = 2 ([\"b\",\"y\"]). \nYou can see that string \"baey\" is beautiful as vowels == consonants and vowels * consonants % k == 0.\nIt can be shown that there are only 2 beautiful substrings in the given string.", "**Input:** s = \"abba\", k = 1\n**Output:** 3\n**Explanation:** There are 3 beautiful substrings in the given string.\n- Substring \"abba\", vowels = 1 ([\"a\"]), consonants = 1 ([\"b\"]). \n- Substring \"abba\", vowels = 1 ([\"a\"]), consonants = 1 ([\"b\"]).\n- Substring \"abba\", vowels = 2 ([\"a\",\"a\"]), consonants = 2 ([\"b\",\"b\"]).\nIt can be shown that there are only 3 beautiful substrings in the given string.", "**Input:** s = \"bcdf\", k = 1\n**Output:** 0\n**Explanation:** There are no beautiful substrings in the given string."], "constraints": "**Constraints:**\n\n\n* `1 <= s.length <= 1000`\n* `1 <= k <= 1000`\n* `s` consists of only English lowercase letters.", "difficulty": "Medium", "tags": ["String", "Enumeration", "Prefix Sum"], "hints": ["Iterate over all substrings and maintain the frequencies of vowels and consonants."], "templates": {"cpp": "class Solution {\npublic:\n    int beautifulSubstrings(string s, int k) {\n        \n    }\n};", "java": "class Solution {\n    public int beautifulSubstrings(String s, int k) {\n        \n    }\n}", "python": "class Solution(object):\n    def beautifulSubstrings(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def beautifulSubstrings(self, s: str, k: int) -> int:\n        ", "c": "int beautifulSubstrings(char* s, int k) {\n    \n}", "csharp": "public class Solution {\n    public int BeautifulSubstrings(string s, int k) {\n        \n    }\n}", "javascript": "/**\n * @param {string} s\n * @param {number} k\n * @return {number}\n */\nvar beautifulSubstrings = function(s, k) {\n    \n};", "typescript": "function beautifulSubstrings(s: string, k: number): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @param Integer $k\n     * @return Integer\n     */\n    function beautifulSubstrings($s, $k) {\n        \n    }\n}", "swift": "class Solution {\n    func beautifulSubstrings(_ s: String, _ k: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun beautifulSubstrings(s: String, k: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int beautifulSubstrings(String s, int k) {\n    \n  }\n}", "golang": "func beautifulSubstrings(s string, k int) int {\n    \n}", "ruby": "# @param {String} s\n# @param {Integer} k\n# @return {Integer}\ndef beautiful_substrings(s, k)\n    \nend", "scala": "object Solution {\n    def beautifulSubstrings(s: String, k: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn beautiful_substrings(s: String, k: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (beautiful-substrings s k)\n  (-> string? exact-integer? exact-integer?)\n  )", "erlang": "-spec beautiful_substrings(S :: unicode:unicode_binary(), K :: integer()) -> integer().\nbeautiful_substrings(S, K) ->\n  .", "elixir": "defmodule Solution do\n  @spec beautiful_substrings(s :: String.t, k :: integer) :: integer\n  def beautiful_substrings(s, k) do\n    \n  end\nend"}}
{"id": "leetcode_2910", "url": "https://leetcode.com/problems/minimum-number-of-groups-to-create-a-valid-assignment/", "title": "Minimum Number of Groups to Create a Valid Assignment", "description": "You are given a **0-indexed** integer array `nums` of length `n`.\n\n\nWe want to group the indices so for each index `i` in the range `[0, n - 1]`, it is assigned to **exactly one** group.\n\n\nA groupassignment is **valid** if the following conditions hold:\n\n\n* For every group `g`, all indices `i` assigned to group `g` have the same value in `nums`.\n* For any two groups `g1` and `g2`, the **difference** between the **number of indices** assigned to `g1` and `g2` should **not exceed** `1`.\n\n\nReturn *an integer denoting* *the **minimum** number of groups needed to create a valid group assignment.*", "examples": ["**Input:** nums = [3,2,3,2,3]\n**Output:** 2\n**Explanation:** One way the indices can be assigned to 2 groups is as follows, where the values in square brackets are indices:\ngroup 1 -> [0,2,4]\ngroup 2 -> [1,3]\nAll indices are assigned to one group.\nIn group 1, nums[0] == nums[2] == nums[4], so all indices have the same value.\nIn group 2, nums[1] == nums[3], so all indices have the same value.\nThe number of indices assigned to group 1 is 3, and the number of indices assigned to group 2 is 2.\nTheir difference doesn't exceed 1.\nIt is not possible to use fewer than 2 groups because, in order to use just 1 group, all indices assigned to that group must have the same value.\nHence, the answer is 2.", "**Input:** nums = [10,10,10,3,1,1]\n**Output:** 4\n**Explanation:** One way the indices can be assigned to 4 groups is as follows, where the values in square brackets are indices:\ngroup 1 -> [0]\ngroup 2 -> [1,2]\ngroup 3 -> [3]\ngroup 4 -> [4,5]\nThe group assignment above satisfies both conditions.\nIt can be shown that it is not possible to create a valid assignment using fewer than 4 groups.\nHence, the answer is 4."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `1 <= nums[i] <= 109`", "difficulty": "Medium", "tags": ["Array", "Hash Table", "Greedy"], "hints": ["Calculate the frequency of each number.", "For each <code>x</code> in the range <code>[1, minimum_frequency]</code>, try to create groups with either <code>x</code> or <code>x + 1</code> indices assigned to them while minimizing the total number of groups.", "For each distinct number, using its frequency, check that all its occurrences can be assigned to groups of size <code>x</code> or <code>x + 1</code> while minimizing the number of groups used.", "To get the minimum number of groups needed for a number having frequency <code>f</code> to be assigned to groups of size <code>x</code> or <code>x + 1</code>, let <code>a = f / (x + 1)</code> and <code>b = f % (x + 1)</code>. <ul> <li>If <code>b == 0</code>, then we can simply create <code>a</code> groups of size <code>x + 1</code>.</li> <li>If <code>x - b <= a</code>, we can have <code>a - (x - b)</code> groups of size <code>x + 1</code> and <code>x - b + 1</code> groups of size <code>x</code>. So, in total, we have <code>a + 1</code> groups.</li> <li>Otherwise, it's impossible.</li> </ul>", "The minimum number of groups needed for some <code>x</code> is the total minimized number of groups needed for each distinct number.", "The answer is the minimum number of groups needed for each <code>x</code> in the range <code>[1, minimum_frequency]</code>."], "templates": {"cpp": "class Solution {\npublic:\n    int minGroupsForValidAssignment(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public int minGroupsForValidAssignment(int[] nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def minGroupsForValidAssignment(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def minGroupsForValidAssignment(self, nums: List[int]) -> int:\n        ", "c": "int minGroupsForValidAssignment(int* nums, int numsSize) {\n    \n}", "csharp": "public class Solution {\n    public int MinGroupsForValidAssignment(int[] nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minGroupsForValidAssignment = function(nums) {\n    \n};", "typescript": "function minGroupsForValidAssignment(nums: number[]): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function minGroupsForValidAssignment($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func minGroupsForValidAssignment(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun minGroupsForValidAssignment(nums: IntArray): Int {\n        \n    }\n}", "dart": "class Solution {\n  int minGroupsForValidAssignment(List<int> nums) {\n    \n  }\n}", "golang": "func minGroupsForValidAssignment(nums []int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef min_groups_for_valid_assignment(nums)\n    \nend", "scala": "object Solution {\n    def minGroupsForValidAssignment(nums: Array[Int]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn min_groups_for_valid_assignment(nums: Vec<i32>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (min-groups-for-valid-assignment nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )", "erlang": "-spec min_groups_for_valid_assignment(Nums :: [integer()]) -> integer().\nmin_groups_for_valid_assignment(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec min_groups_for_valid_assignment(nums :: [integer]) :: integer\n  def min_groups_for_valid_assignment(nums) do\n    \n  end\nend"}}
{"id": "leetcode_2785", "url": "https://leetcode.com/problems/sort-vowels-in-a-string/", "title": "Sort Vowels in a String", "description": "Given a **0-indexed** string `s`, **permute** `s` to get a new string `t` such that:\n\n\n* All consonants remain in their original places. More formally, if there is an index `i` with `0 <= i < s.length` such that `s[i]` is a consonant, then `t[i] = s[i]`.\n* The vowels must be sorted in the **nondecreasing** order of their **ASCII** values. More formally, for pairs of indices `i`, `j` with `0 <= i < j < s.length` such that `s[i]` and `s[j]` are vowels, then `t[i]` must not have a higher ASCII value than `t[j]`.\n\n\nReturn *the resulting string*.\n\n\nThe vowels are `'a'`, `'e'`, `'i'`, `'o'`, and `'u'`, and they can appear in lowercase or uppercase. Consonants comprise all letters that are not vowels.", "examples": ["**Input:** s = \"lEetcOde\"\n**Output:** \"lEOtcede\"\n**Explanation:** 'E', 'O', and 'e' are the vowels in s; 'l', 't', 'c', and 'd' are all consonants. The vowels are sorted according to their ASCII values, and the consonants remain in the same places.", "**Input:** s = \"lYmpH\"\n**Output:** \"lYmpH\"\n**Explanation:** There are no vowels in s (all characters in s are consonants), so we return \"lYmpH\"."], "constraints": "**Constraints:**\n\n\n* `1 <= s.length <= 105`\n* `s` consists only of letters of the\u00a0English alphabet\u00a0in **uppercase and lowercase**.", "difficulty": "Medium", "tags": ["String", "Sorting"], "hints": ["Add all the vowels in an array and sort the array.", "Replace characters in string s if it's a vowel from the new array."], "templates": {"cpp": "class Solution {\npublic:\n    string sortVowels(string s) {\n        \n    }\n};", "java": "class Solution {\n    public String sortVowels(String s) {\n        \n    }\n}", "python": "class Solution(object):\n    def sortVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        ", "python3": "class Solution:\n    def sortVowels(self, s: str) -> str:\n        ", "c": "char * sortVowels(char * s){\n\n}", "csharp": "public class Solution {\n    public string SortVowels(string s) {\n        \n    }\n}", "javascript": "/**\n * @param {string} s\n * @return {string}\n */\nvar sortVowels = function(s) {\n    \n};", "typescript": "function sortVowels(s: string): string {\n\n};", "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @return String\n     */\n    function sortVowels($s) {\n        \n    }\n}", "swift": "class Solution {\n    func sortVowels(_ s: String) -> String {\n        \n    }\n}", "kotlin": "class Solution {\n    fun sortVowels(s: String): String {\n        \n    }\n}", "dart": "class Solution {\n  String sortVowels(String s) {\n\n  }\n}", "golang": "func sortVowels(s string) string {\n    \n}", "ruby": "# @param {String} s\n# @return {String}\ndef sort_vowels(s)\n    \nend", "scala": "object Solution {\n    def sortVowels(s: String): String = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn sort_vowels(s: String) -> String {\n        \n    }\n}", "racket": "(define/contract (sort-vowels s)\n  (-> string? string?)\n\n  )", "erlang": "-spec sort_vowels(S :: unicode:unicode_binary()) -> unicode:unicode_binary().\nsort_vowels(S) ->\n  .", "elixir": "defmodule Solution do\n  @spec sort_vowels(s :: String.t) :: String.t\n  def sort_vowels(s) do\n\n  end\nend"}}
{"id": "leetcode_2896", "url": "https://leetcode.com/problems/apply-operations-to-make-two-strings-equal/", "title": "Apply Operations to Make Two Strings Equal", "description": "You are given two **0-indexed** binary strings `s1` and `s2`, both of length `n`, and a positive integer `x`.\n\n\nYou can perform any of the following operations on the string `s1` **any** number of times:\n\n\n* Choose two indices `i` and `j`, and flip both `s1[i]` and `s1[j]`. The cost of this operation is `x`.\n* Choose an index `i` such that `i < n - 1` and flip both `s1[i]` and `s1[i + 1]`. The cost of this operation is `1`.\n\n\nReturn *the **minimum** cost needed to make the strings* `s1` *and* `s2` *equal, or return* `-1` *if it is impossible.*\n\n\n**Note** that flipping a character means changing it from `0` to `1` or vice-versa.", "examples": ["**Input:** s1 = \"1100011000\", s2 = \"0101001010\", x = 2\n**Output:** 4\n**Explanation:** We can do the following operations:\n- Choose i = 3 and apply the second operation. The resulting string is s1 = \"110**11**11000\".\n- Choose i = 4 and apply the second operation. The resulting string is s1 = \"1101**00**1000\".\n- Choose i = 0 and j = 8 and apply the first operation. The resulting string is s1 = \"**0**1010010**1**0\" = s2.\nThe total cost is 1 + 1 + 2 = 4. It can be shown that it is the minimum cost possible.", "**Input:** s1 = \"10110\", s2 = \"00011\", x = 4\n**Output:** -1\n**Explanation:** It is not possible to make the two strings equal."], "constraints": "**Constraints:**\n\n\n* `n == s1.length == s2.length`\n* `1 <= n, x <= 500`\n* `s1` and `s2` consist only of the characters `'0'` and `'1'`.", "difficulty": "Medium", "tags": ["String", "Dynamic Programming"], "hints": ["Save all the indices that have different characters on <code>s1</code> and <code>s2</code> into a list, and work only with this list.", "Try to use dynamic programming on this list to solve the problem. What will be the states and transitions of this dp?"], "templates": {"cpp": "class Solution {\npublic:\n    int minOperations(string s1, string s2, int x) {\n        \n    }\n};", "java": "class Solution {\n    public int minOperations(String s1, String s2, int x) {\n        \n    }\n}", "python": "class Solution(object):\n    def minOperations(self, s1, s2, x):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type x: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def minOperations(self, s1: str, s2: str, x: int) -> int:\n        ", "c": "int minOperations(char * s1, char * s2, int x){\n\n}", "csharp": "public class Solution {\n    public int MinOperations(string s1, string s2, int x) {\n        \n    }\n}", "javascript": "/**\n * @param {string} s1\n * @param {string} s2\n * @param {number} x\n * @return {number}\n */\nvar minOperations = function(s1, s2, x) {\n    \n};", "typescript": "function minOperations(s1: string, s2: string, x: number): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param String $s1\n     * @param String $s2\n     * @param Integer $x\n     * @return Integer\n     */\n    function minOperations($s1, $s2, $x) {\n        \n    }\n}", "swift": "class Solution {\n    func minOperations(_ s1: String, _ s2: String, _ x: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun minOperations(s1: String, s2: String, x: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int minOperations(String s1, String s2, int x) {\n\n  }\n}", "golang": "func minOperations(s1 string, s2 string, x int) int {\n    \n}", "ruby": "# @param {String} s1\n# @param {String} s2\n# @param {Integer} x\n# @return {Integer}\ndef min_operations(s1, s2, x)\n    \nend", "scala": "object Solution {\n    def minOperations(s1: String, s2: String, x: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn min_operations(s1: String, s2: String, x: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (min-operations s1 s2 x)\n  (-> string? string? exact-integer? exact-integer?)\n\n  )", "erlang": "-spec min_operations(S1 :: unicode:unicode_binary(), S2 :: unicode:unicode_binary(), X :: integer()) -> integer().\nmin_operations(S1, S2, X) ->\n  .", "elixir": "defmodule Solution do\n  @spec min_operations(s1 :: String.t, s2 :: String.t, x :: integer) :: integer\n  def min_operations(s1, s2, x) do\n\n  end\nend"}}
{"id": "leetcode_2746", "url": "https://leetcode.com/problems/decremental-string-concatenation/", "title": "Decremental String Concatenation", "description": "You are given a **0-indexed** array `words` containing `n` strings.\n\n\nLet's define a **join** operation `join(x, y)` between two strings `x` and `y` as concatenating them into `xy`. However, if the last character of `x` is equal to the first character of `y`, one of them is **deleted**.\n\n\nFor example `join(\"ab\", \"ba\") = \"aba\"` and `join(\"ab\", \"cde\") = \"abcde\"`.\n\n\nYou are to perform `n - 1` **join** operations. Let `str0 = words[0]`. Starting from `i = 1` up to `i = n - 1`, for the `ith` operation, you can do one of the following:\n\n\n* Make `stri = join(stri - 1, words[i])`\n* Make `stri = join(words[i], stri - 1)`\n\n\nYour task is to **minimize** the length of `strn - 1`.\n\n\nReturn *an integer denoting the minimum possible length of* `strn - 1`.", "examples": ["**Input:** words = [\"aa\",\"ab\",\"bc\"]\n**Output:** 4\n**Explanation:** In this example, we can perform join operations in the following order to minimize the length of str2: \nstr0 = \"aa\"\nstr1 = join(str0, \"ab\") = \"aab\"\nstr2 = join(str1, \"bc\") = \"aabc\" \nIt can be shown that the minimum possible length of str2 is 4.", "**Input:** words = [\"ab\",\"b\"]\n**Output:** 2\n**Explanation:** In this example, str0 = \"ab\", there are two ways to get str1: \njoin(str0, \"b\") = \"ab\" or join(\"b\", str0) = \"bab\". \nThe first string, \"ab\", has the minimum length. Hence, the answer is 2.", "**Input:** words = [\"aaa\",\"c\",\"aba\"]\n**Output:** 6\n**Explanation:** In this example, we can perform join operations in the following order to minimize the length of str2: \nstr0 = \"aaa\"\nstr1 = join(str0, \"c\") = \"aaac\"\nstr2 = join(\"aba\", str1) = \"abaaac\"\nIt can be shown that the minimum possible length of str2 is 6."], "constraints": "**Constraints:**\n\n\n* `1 <= words.length <= 1000`\n* `1 <= words[i].length <= 50`\n* Each character in `words[i]` is an English lowercase letter", "difficulty": "Medium", "tags": ["Array", "String", "Dynamic Programming"], "hints": ["Use dynamic programming with memoization.", "Notice that the first and last characters of a string are sufficient to determine the length of its concatenation with any other string.", "Define dp[i][first][last] as the shortest concatenation length of the first i words starting with a character first and ending with a character last. Convert characters to their ASCII codes if your programming language cannot implicitly convert them to array indices."], "templates": {"cpp": "class Solution {\npublic:\n    int minimizeConcatenatedLength(vector<string>& words) {\n        \n    }\n};", "java": "class Solution {\n    public int minimizeConcatenatedLength(String[] words) {\n        \n    }\n}", "python": "class Solution(object):\n    def minimizeConcatenatedLength(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def minimizeConcatenatedLength(self, words: List[str]) -> int:\n        ", "c": "int minimizeConcatenatedLength(char ** words, int wordsSize){\n\n}", "csharp": "public class Solution {\n    public int MinimizeConcatenatedLength(string[] words) {\n        \n    }\n}", "javascript": "/**\n * @param {string[]} words\n * @return {number}\n */\nvar minimizeConcatenatedLength = function(words) {\n    \n};", "typescript": "function minimizeConcatenatedLength(words: string[]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param String[] $words\n     * @return Integer\n     */\n    function minimizeConcatenatedLength($words) {\n        \n    }\n}", "swift": "class Solution {\n    func minimizeConcatenatedLength(_ words: [String]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun minimizeConcatenatedLength(words: Array<String>): Int {\n        \n    }\n}", "dart": "class Solution {\n  int minimizeConcatenatedLength(List<String> words) {\n\n  }\n}", "golang": "func minimizeConcatenatedLength(words []string) int {\n    \n}", "ruby": "# @param {String[]} words\n# @return {Integer}\ndef minimize_concatenated_length(words)\n    \nend", "scala": "object Solution {\n    def minimizeConcatenatedLength(words: Array[String]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn minimize_concatenated_length(words: Vec<String>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (minimize-concatenated-length words)\n  (-> (listof string?) exact-integer?)\n\n  )", "erlang": "-spec minimize_concatenated_length(Words :: [unicode:unicode_binary()]) -> integer().\nminimize_concatenated_length(Words) ->\n  .", "elixir": "defmodule Solution do\n  @spec minimize_concatenated_length(words :: [String.t]) :: integer\n  def minimize_concatenated_length(words) do\n\n  end\nend"}}
{"id": "leetcode_2750", "url": "https://leetcode.com/problems/ways-to-split-array-into-good-subarrays/", "title": "Ways to Split Array Into Good Subarrays", "description": "You are given a binary array `nums`.\n\n\nA subarray of an array is **good** if it contains **exactly** **one** element with the value `1`.\n\n\nReturn *an integer denoting the number of ways to split the array* `nums` *into **good** subarrays*. As the number may be too large, return it **modulo** `109 + 7`.\n\n\nA subarray is a contiguous **non-empty** sequence of elements within an array.", "examples": ["**Input:** nums = [0,1,0,0,1]\n**Output:** 3\n**Explanation:** There are 3 ways to split nums into good subarrays:\n- [0,1] [0,0,1]\n- [0,1,0] [0,1]\n- [0,1,0,0] [1]", "**Input:** nums = [0,1,0]\n**Output:** 1\n**Explanation:** There is 1 way to split nums into good subarrays:\n- [0,1,0]"], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `0 <= nums[i] <= 1`", "difficulty": "Medium", "tags": ["Array", "Math", "Dynamic Programming"], "hints": ["If the array consists of only 0s answer is 0.", "In the final split, exactly one separation point exists between two consecutive 1s.", "In how many ways can separation points be put?"], "templates": {"cpp": "class Solution {\npublic:\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public int numberOfGoodSubarraySplits(int[] nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def numberOfGoodSubarraySplits(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\n        ", "c": "int numberOfGoodSubarraySplits(int* nums, int numsSize){\n\n}", "csharp": "public class Solution {\n    public int NumberOfGoodSubarraySplits(int[] nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numberOfGoodSubarraySplits = function(nums) {\n    \n};", "typescript": "function numberOfGoodSubarraySplits(nums: number[]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function numberOfGoodSubarraySplits($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func numberOfGoodSubarraySplits(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun numberOfGoodSubarraySplits(nums: IntArray): Int {\n        \n    }\n}", "dart": "class Solution {\n  int numberOfGoodSubarraySplits(List<int> nums) {\n\n  }\n}", "golang": "func numberOfGoodSubarraySplits(nums []int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef number_of_good_subarray_splits(nums)\n    \nend", "scala": "object Solution {\n    def numberOfGoodSubarraySplits(nums: Array[Int]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn number_of_good_subarray_splits(nums: Vec<i32>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (number-of-good-subarray-splits nums)\n  (-> (listof exact-integer?) exact-integer?)\n\n  )", "erlang": "-spec number_of_good_subarray_splits(Nums :: [integer()]) -> integer().\nnumber_of_good_subarray_splits(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec number_of_good_subarray_splits(nums :: [integer]) :: integer\n  def number_of_good_subarray_splits(nums) do\n\n  end\nend"}}
{"id": "leetcode_2707", "url": "https://leetcode.com/problems/extra-characters-in-a-string/", "title": "Extra Characters in a String", "description": "You are given a **0-indexed** string `s` and a dictionary of words `dictionary`. You have to break `s` into one or more **non-overlapping** substrings such that each substring is present in `dictionary`. There may be some **extra characters** in `s` which are not present in any of the substrings.\n\n\nReturn *the **minimum** number of extra characters left over if you break up* `s` *optimally.*", "examples": ["**Input:** s = \"leetscode\", dictionary = [\"leet\",\"code\",\"leetcode\"]\n**Output:** 1\n**Explanation:** We can break s in two substrings: \"leet\" from index 0 to 3 and \"code\" from index 5 to 8. There is only 1 unused character (at index 4), so we return 1.", "**Input:** s = \"sayhelloworld\", dictionary = [\"hello\",\"world\"]\n**Output:** 3\n**Explanation:** We can break s in two substrings: \"hello\" from index 3 to 7 and \"world\" from index 8 to 12. The characters at indices 0, 1, 2 are not used in any substring and thus are considered as extra characters. Hence, we return 3."], "constraints": "**Constraints:**\n\n\n* `1 <= s.length <= 50`\n* `1 <= dictionary.length <= 50`\n* `1 <= dictionary[i].length <= 50`\n* `dictionary[i]`\u00a0and `s` consists of only lowercase English letters\n* `dictionary` contains distinct words", "difficulty": "Medium", "tags": ["Array", "Hash Table", "String", "Dynamic Programming", "Trie"], "hints": ["Can we use Dynamic Programming here?", "Define DP[i] as the min extra character if breaking up s[0:i] optimally."], "templates": {"cpp": "class Solution {\npublic:\n    int minExtraChar(string s, vector<string>& dictionary) {\n        \n    }\n};", "java": "class Solution {\n    public int minExtraChar(String s, String[] dictionary) {\n        \n    }\n}", "python": "class Solution(object):\n    def minExtraChar(self, s, dictionary):\n        \"\"\"\n        :type s: str\n        :type dictionary: List[str]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\n        ", "c": "int minExtraChar(char * s, char ** dictionary, int dictionarySize){\n\n}", "csharp": "public class Solution {\n    public int MinExtraChar(string s, string[] dictionary) {\n        \n    }\n}", "javascript": "/**\n * @param {string} s\n * @param {string[]} dictionary\n * @return {number}\n */\nvar minExtraChar = function(s, dictionary) {\n    \n};", "typescript": "function minExtraChar(s: string, dictionary: string[]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @param String[] $dictionary\n     * @return Integer\n     */\n    function minExtraChar($s, $dictionary) {\n        \n    }\n}", "swift": "class Solution {\n    func minExtraChar(_ s: String, _ dictionary: [String]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun minExtraChar(s: String, dictionary: Array<String>): Int {\n        \n    }\n}", "dart": "class Solution {\n  int minExtraChar(String s, List<String> dictionary) {\n\n  }\n}", "golang": "func minExtraChar(s string, dictionary []string) int {\n    \n}", "ruby": "# @param {String} s\n# @param {String[]} dictionary\n# @return {Integer}\ndef min_extra_char(s, dictionary)\n    \nend", "scala": "object Solution {\n    def minExtraChar(s: String, dictionary: Array[String]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn min_extra_char(s: String, dictionary: Vec<String>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (min-extra-char s dictionary)\n  (-> string? (listof string?) exact-integer?)\n\n  )", "erlang": "-spec min_extra_char(S :: unicode:unicode_binary(), Dictionary :: [unicode:unicode_binary()]) -> integer().\nmin_extra_char(S, Dictionary) ->\n  .", "elixir": "defmodule Solution do\n  @spec min_extra_char(s :: String.t, dictionary :: [String.t]) :: integer\n  def min_extra_char(s, dictionary) do\n\n  end\nend"}}
{"id": "leetcode_2840", "url": "https://leetcode.com/problems/check-if-strings-can-be-made-equal-with-operations-ii/", "title": "Check if Strings Can be Made Equal With Operations II", "description": "You are given two strings `s1` and `s2`, both of length `n`, consisting of **lowercase** English letters.\n\n\nYou can apply the following operation on **any** of the two strings **any** number of times:\n\n\n* Choose any two indices `i` and `j` such that `i < j` and the difference `j - i` is **even**, then **swap** the two characters at those indices in the string.\n\n\nReturn `true` *if you can make the strings* `s1` *and* `s2` *equal, and*`false` *otherwise*.", "examples": ["**Input:** s1 = \"abcdba\", s2 = \"cabdab\"\n**Output:** true\n**Explanation:** We can apply the following operations on s1:\n- Choose the indices i = 0, j = 2. The resulting string is s1 = \"cbadba\".\n- Choose the indices i = 2, j = 4. The resulting string is s1 = \"cbbdaa\".\n- Choose the indices i = 1, j = 5. The resulting string is s1 = \"cabdab\" = s2.", "**Input:** s1 = \"abe\", s2 = \"bea\"\n**Output:** false\n**Explanation:** It is not possible to make the two strings equal."], "constraints": "**Constraints:**\n\n\n* `n == s1.length == s2.length`\n* `1 <= n <= 105`\n* `s1` and `s2` consist only of lowercase English letters.", "difficulty": "Medium", "tags": ["Hash Table", "String", "Sorting"], "hints": ["<div class=\"_1l1MA\">Characters in two positions can be swapped if and only if the two positions have the same parity.</div>", "<div class=\"_1l1MA\">To be able to make the two strings equal, the characters at even and odd positions in the strings should be the same.</div>"], "templates": {"cpp": "class Solution {\npublic:\n    bool checkStrings(string s1, string s2) {\n        \n    }\n};", "java": "class Solution {\n    public boolean checkStrings(String s1, String s2) {\n        \n    }\n}", "python": "class Solution(object):\n    def checkStrings(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        ", "python3": "class Solution:\n    def checkStrings(self, s1: str, s2: str) -> bool:\n        ", "c": "bool checkStrings(char * s1, char * s2){\n\n}", "csharp": "public class Solution {\n    public bool CheckStrings(string s1, string s2) {\n        \n    }\n}", "javascript": "/**\n * @param {string} s1\n * @param {string} s2\n * @return {boolean}\n */\nvar checkStrings = function(s1, s2) {\n    \n};", "typescript": "function checkStrings(s1: string, s2: string): boolean {\n\n};", "php": "class Solution {\n\n    /**\n     * @param String $s1\n     * @param String $s2\n     * @return Boolean\n     */\n    function checkStrings($s1, $s2) {\n        \n    }\n}", "swift": "class Solution {\n    func checkStrings(_ s1: String, _ s2: String) -> Bool {\n        \n    }\n}", "kotlin": "class Solution {\n    fun checkStrings(s1: String, s2: String): Boolean {\n        \n    }\n}", "dart": "class Solution {\n  bool checkStrings(String s1, String s2) {\n\n  }\n}", "golang": "func checkStrings(s1 string, s2 string) bool {\n    \n}", "ruby": "# @param {String} s1\n# @param {String} s2\n# @return {Boolean}\ndef check_strings(s1, s2)\n    \nend", "scala": "object Solution {\n    def checkStrings(s1: String, s2: String): Boolean = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn check_strings(s1: String, s2: String) -> bool {\n        \n    }\n}", "racket": "(define/contract (check-strings s1 s2)\n  (-> string? string? boolean?)\n\n  )", "erlang": "-spec check_strings(S1 :: unicode:unicode_binary(), S2 :: unicode:unicode_binary()) -> boolean().\ncheck_strings(S1, S2) ->\n  .", "elixir": "defmodule Solution do\n  @spec check_strings(s1 :: String.t, s2 :: String.t) :: boolean\n  def check_strings(s1, s2) do\n\n  end\nend"}}
{"id": "leetcode_2905", "url": "https://leetcode.com/problems/find-indices-with-index-and-value-difference-ii/", "title": "Find Indices With Index and Value Difference II", "description": "You are given a **0-indexed** integer array `nums` having length `n`, an integer `indexDifference`, and an integer `valueDifference`.\n\n\nYour task is to find **two** indices `i` and `j`, both in the range `[0, n - 1]`, that satisfy the following conditions:\n\n\n* `abs(i - j) >= indexDifference`, and\n* `abs(nums[i] - nums[j]) >= valueDifference`\n\n\nReturn *an integer array* `answer`, *where* `answer = [i, j]` *if there are two such indices*, *and* `answer = [-1, -1]` *otherwise*. If there are multiple choices for the two indices, return *any of them*.\n\n\n**Note:** `i` and `j` may be **equal**.", "examples": ["**Input:** nums = [5,1,4,1], indexDifference = 2, valueDifference = 4\n**Output:** [0,3]\n**Explanation:** In this example, i = 0 and j = 3 can be selected.\nabs(0 - 3) >= 2 and abs(nums[0] - nums[3]) >= 4.\nHence, a valid answer is [0,3].\n[3,0] is also a valid answer.", "**Input:** nums = [2,1], indexDifference = 0, valueDifference = 0\n**Output:** [0,0]\n**Explanation:** In this example, i = 0 and j = 0 can be selected.\nabs(0 - 0) >= 0 and abs(nums[0] - nums[0]) >= 0.\nHence, a valid answer is [0,0].\nOther valid answers are [0,1], [1,0], and [1,1].", "**Input:** nums = [1,2,3], indexDifference = 2, valueDifference = 4\n**Output:** [-1,-1]\n**Explanation:** In this example, it can be shown that it is impossible to find two indices that satisfy both conditions.\nHence, [-1,-1] is returned."], "constraints": "**Constraints:**\n\n\n* `1 <= n == nums.length <= 105`\n* `0 <= nums[i] <= 109`\n* `0 <= indexDifference <= 105`\n* `0 <= valueDifference <= 109`", "difficulty": "Medium", "tags": ["Array"], "hints": ["For each index <code>i >= indexDifference</code>, keep the indices <code>j<sub>1</sub></code> and <code>j<sub>2</sub></code> in the range <code>[0, i - indexDifference]</code> such that <code>nums[j<sub>1</sub>]</code> and <code>nums[j<sub>2</sub>]</code> are the minimum and maximum values in the index range.", "Check if <code>abs(nums[i] - nums[j<sub>1</sub>]) >= valueDifference</code> or <code>abs(nums[i] - nums[j<sub>2</sub>]) >= valueDifference</code>.", "<code>j<sub>1</sub></code> and <code>j<sub>2</sub></code> can be updated dynamically, or they can be pre-computed since they are just prefix minimum and maximum."], "templates": {"cpp": "class Solution {\npublic:\n    vector<int> findIndices(vector<int>& nums, int indexDifference, int valueDifference) {\n        \n    }\n};", "java": "class Solution {\n    public int[] findIndices(int[] nums, int indexDifference, int valueDifference) {\n        \n    }\n}", "python": "class Solution(object):\n    def findIndices(self, nums, indexDifference, valueDifference):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDifference: int\n        :type valueDifference: int\n        :rtype: List[int]\n        \"\"\"\n        ", "python3": "class Solution:\n    def findIndices(self, nums: List[int], indexDifference: int, valueDifference: int) -> List[int]:\n        ", "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* findIndices(int* nums, int numsSize, int indexDifference, int valueDifference, int* returnSize) {\n    \n}", "csharp": "public class Solution {\n    public int[] FindIndices(int[] nums, int indexDifference, int valueDifference) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @param {number} indexDifference\n * @param {number} valueDifference\n * @return {number[]}\n */\nvar findIndices = function(nums, indexDifference, valueDifference) {\n    \n};", "typescript": "function findIndices(nums: number[], indexDifference: number, valueDifference: number): number[] {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $indexDifference\n     * @param Integer $valueDifference\n     * @return Integer[]\n     */\n    function findIndices($nums, $indexDifference, $valueDifference) {\n        \n    }\n}", "swift": "class Solution {\n    func findIndices(_ nums: [Int], _ indexDifference: Int, _ valueDifference: Int) -> [Int] {\n        \n    }\n}", "kotlin": "class Solution {\n    fun findIndices(nums: IntArray, indexDifference: Int, valueDifference: Int): IntArray {\n        \n    }\n}", "dart": "class Solution {\n  List<int> findIndices(List<int> nums, int indexDifference, int valueDifference) {\n    \n  }\n}", "golang": "func findIndices(nums []int, indexDifference int, valueDifference int) []int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @param {Integer} index_difference\n# @param {Integer} value_difference\n# @return {Integer[]}\ndef find_indices(nums, index_difference, value_difference)\n    \nend", "scala": "object Solution {\n    def findIndices(nums: Array[Int], indexDifference: Int, valueDifference: Int): Array[Int] = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn find_indices(nums: Vec<i32>, index_difference: i32, value_difference: i32) -> Vec<i32> {\n        \n    }\n}", "racket": "(define/contract (find-indices nums indexDifference valueDifference)\n  (-> (listof exact-integer?) exact-integer? exact-integer? (listof exact-integer?))\n  )", "erlang": "-spec find_indices(Nums :: [integer()], IndexDifference :: integer(), ValueDifference :: integer()) -> [integer()].\nfind_indices(Nums, IndexDifference, ValueDifference) ->\n  .", "elixir": "defmodule Solution do\n  @spec find_indices(nums :: [integer], index_difference :: integer, value_difference :: integer) :: [integer]\n  def find_indices(nums, index_difference, value_difference) do\n    \n  end\nend"}}
{"id": "leetcode_2817", "url": "https://leetcode.com/problems/minimum-absolute-difference-between-elements-with-constraint/", "title": "Minimum Absolute Difference Between Elements With Constraint", "description": "You are given a **0-indexed** integer array `nums` and an integer `x`.\n\n\nFind the **minimum absolute difference** between two elements in the array that are at least `x` indices apart.\n\n\nIn other words, find two indices `i` and `j` such that `abs(i - j) >= x` and `abs(nums[i] - nums[j])` is minimized.\n\n\nReturn *an integer denoting the **minimum** absolute difference between two elements that are at least* `x` *indices apart*.", "examples": ["**Input:** nums = [4,3,2,4], x = 2\n**Output:** 0\n**Explanation:** We can select nums[0] = 4 and nums[3] = 4. \nThey are at least 2 indices apart, and their absolute difference is the minimum, 0. \nIt can be shown that 0 is the optimal answer.", "**Input:** nums = [5,3,2,10,15], x = 1\n**Output:** 1\n**Explanation:** We can select nums[1] = 3 and nums[2] = 2.\nThey are at least 1 index apart, and their absolute difference is the minimum, 1.\nIt can be shown that 1 is the optimal answer.", "**Input:** nums = [1,2,3,4], x = 3\n**Output:** 3\n**Explanation:** We can select nums[0] = 1 and nums[3] = 4.\nThey are at least 3 indices apart, and their absolute difference is the minimum, 3.\nIt can be shown that 3 is the optimal answer."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `1 <= nums[i] <= 109`\n* `0 <= x < nums.length`", "difficulty": "Medium", "tags": ["Array", "Binary Search", "Ordered Set"], "hints": ["<div class=\"_1l1MA\">Let's only consider the cases where <code>i < j</code>, as the problem is symmetric.</div>", "<div class=\"_1l1MA\">For an index <code>j</code>, we are interested in an index <code>i</code> in the range <code>[0, j - x]</code> that minimizes <code>abs(nums[i] - nums[j])</code>.</div>", "<div class=\"_1l1MA\">For every index <code>j</code>, while going from left to right, add <code>nums[j - x]</code> to a set (C++ set, Java TreeSet, and Python sorted set).</div>", "<div class=\"_1l1MA\">After inserting <code>nums[j - x]</code>, we can calculate the closest value to <code>nums[j]</code> in the set using binary search and store the absolute difference. In C++, we can achieve this by using lower_bound and/or upper_bound.</div>", "<div class=\"_1l1MA\">Calculate the minimum absolute difference among all indices.</div>"], "templates": {"cpp": "class Solution {\npublic:\n    int minAbsoluteDifference(vector<int>& nums, int x) {\n        \n    }\n};", "java": "class Solution {\n    public int minAbsoluteDifference(List<Integer> nums, int x) {\n        \n    }\n}", "python": "class Solution(object):\n    def minAbsoluteDifference(self, nums, x):\n        \"\"\"\n        :type nums: List[int]\n        :type x: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n        ", "c": "int minAbsoluteDifference(int* nums, int numsSize, int x){\n\n}", "csharp": "public class Solution {\n    public int MinAbsoluteDifference(IList<int> nums, int x) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @param {number} x\n * @return {number}\n */\nvar minAbsoluteDifference = function(nums, x) {\n    \n};", "typescript": "function minAbsoluteDifference(nums: number[], x: number): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $x\n     * @return Integer\n     */\n    function minAbsoluteDifference($nums, $x) {\n        \n    }\n}", "swift": "class Solution {\n    func minAbsoluteDifference(_ nums: [Int], _ x: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun minAbsoluteDifference(nums: List<Int>, x: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int minAbsoluteDifference(List<int> nums, int x) {\n\n  }\n}", "golang": "func minAbsoluteDifference(nums []int, x int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @param {Integer} x\n# @return {Integer}\ndef min_absolute_difference(nums, x)\n    \nend", "scala": "object Solution {\n    def minAbsoluteDifference(nums: List[Int], x: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn min_absolute_difference(nums: Vec<i32>, x: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (min-absolute-difference nums x)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n\n  )", "erlang": "-spec min_absolute_difference(Nums :: [integer()], X :: integer()) -> integer().\nmin_absolute_difference(Nums, X) ->\n  .", "elixir": "defmodule Solution do\n  @spec min_absolute_difference(nums :: [integer], x :: integer) :: integer\n  def min_absolute_difference(nums, x) do\n\n  end\nend"}}
{"id": "leetcode_2952", "url": "https://leetcode.com/problems/minimum-number-of-coins-to-be-added/", "title": "Minimum Number of Coins to be Added", "description": "You are given a **0-indexed** integer array `coins`, representing the values of the coins available, and an integer `target`.\n\n\nAn integer `x` is **obtainable** if there exists a subsequence of `coins` that sums to `x`.\n\n\nReturn *the **minimum** number of coins **of any value** that need to be added to the array so that every integer in the range* `[1, target]` *is **obtainable***.\n\n\nA **subsequence** of an array is a new **non-empty** array that is formed from the original array by deleting some (**possibly none**) of the elements without disturbing the relative positions of the remaining elements.", "examples": ["**Input:** coins = [1,4,10], target = 19\n**Output:** 2\n**Explanation:** We need to add coins 2 and 8. The resulting array will be [1,2,4,8,10].\nIt can be shown that all integers from 1 to 19 are obtainable from the resulting array, and that 2 is the minimum number of coins that need to be added to the array.", "**Input:** coins = [1,4,10,5,7,19], target = 19\n**Output:** 1\n**Explanation:** We only need to add the coin 2. The resulting array will be [1,2,4,5,7,10,19].\nIt can be shown that all integers from 1 to 19 are obtainable from the resulting array, and that 1 is the minimum number of coins that need to be added to the array.", "**Input:** coins = [1,1,1], target = 20\n**Output:** 3\n**Explanation:** We need to add coins 4, 8, and 16. The resulting array will be [1,1,1,4,8,16].\nIt can be shown that all integers from 1 to 20 are obtainable from the resulting array, and that 3 is the minimum number of coins that need to be added to the array."], "constraints": "**Constraints:**\n\n\n* `1 <= target <= 105`\n* `1 <= coins.length <= 105`\n* `1 <= coins[i] <= target`", "difficulty": "Medium", "tags": ["Array", "Greedy", "Sorting"], "hints": ["Sort the coins array and maintain the smallest sum that is unobtainable by induction.", "If we don\u2019t use any coins, the smallest integer that we cannot obtain by sum is <code>1</code>. Suppose currently, for a fixed set of the first several coins the smallest integer that we cannot obtain is <code>x + 1</code>, namely we can form all integers in the range <code>[1, x]</code> but not <code>x + 1</code>.", "If the next unused coin\u2019s value is NOT <code>x + 1</code> (note the array is sorted), we have to add <code>x + 1</code> to the array. After this addition, we can form all values from <code>x + 1</code> to <code>2 * x + 1</code> by adding <code>x + 1</code> in <code>[1, x]</code>'s formations. So now we can form all the numbers of <code>[1, 2 * x + 1]</code>. After this iteration the new value of <code>x</code> becomes <code>2 * x + 1</code>."], "templates": {"cpp": "class Solution {\npublic:\n    int minimumAddedCoins(vector<int>& coins, int target) {\n        \n    }\n};", "java": "class Solution {\n    public int minimumAddedCoins(int[] coins, int target) {\n        \n    }\n}", "python": "class Solution(object):\n    def minimumAddedCoins(self, coins, target):\n        \"\"\"\n        :type coins: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def minimumAddedCoins(self, coins: List[int], target: int) -> int:\n        ", "c": "int minimumAddedCoins(int* coins, int coinsSize, int target) {\n    \n}", "csharp": "public class Solution {\n    public int MinimumAddedCoins(int[] coins, int target) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} coins\n * @param {number} target\n * @return {number}\n */\nvar minimumAddedCoins = function(coins, target) {\n    \n};", "typescript": "function minimumAddedCoins(coins: number[], target: number): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $coins\n     * @param Integer $target\n     * @return Integer\n     */\n    function minimumAddedCoins($coins, $target) {\n        \n    }\n}", "swift": "class Solution {\n    func minimumAddedCoins(_ coins: [Int], _ target: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun minimumAddedCoins(coins: IntArray, target: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int minimumAddedCoins(List<int> coins, int target) {\n    \n  }\n}", "golang": "func minimumAddedCoins(coins []int, target int) int {\n    \n}", "ruby": "# @param {Integer[]} coins\n# @param {Integer} target\n# @return {Integer}\ndef minimum_added_coins(coins, target)\n    \nend", "scala": "object Solution {\n    def minimumAddedCoins(coins: Array[Int], target: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn minimum_added_coins(coins: Vec<i32>, target: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (minimum-added-coins coins target)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )", "erlang": "-spec minimum_added_coins(Coins :: [integer()], Target :: integer()) -> integer().\nminimum_added_coins(Coins, Target) ->\n  .", "elixir": "defmodule Solution do\n  @spec minimum_added_coins(coins :: [integer], target :: integer) :: integer\n  def minimum_added_coins(coins, target) do\n    \n  end\nend"}}
{"id": "leetcode_2944", "url": "https://leetcode.com/problems/minimum-number-of-coins-for-fruits/", "title": "Minimum Number of Coins for Fruits", "description": "You are at a fruit market with different types of exotic fruits on display.\n\n\nYou are given a **1-indexed** array `prices`, where `prices[i]` denotes the number of coins needed to purchase the `ith` fruit.\n\n\nThe fruit market has the following offer:\n\n\n* If you purchase the `ith` fruit at `prices[i]` coins, you can get the next `i` fruits for free.\n\n\n**Note** that even if you **can** take fruit `j` for free, you can still purchase it for `prices[j]` coins to receive a new offer.\n\n\nReturn *the **minimum** number of coins needed to acquire all the fruits*.", "examples": ["**Input:** prices = [3,1,2]\n**Output:** 4\n**Explanation:** You can acquire the fruits as follows:\n- Purchase the 1st fruit with 3 coins, you are allowed to take the 2nd fruit for free.\n- Purchase the 2nd fruit with 1 coin, you are allowed to take the 3rd fruit for free.\n- Take the 3rd fruit for free.\nNote that even though you were allowed to take the 2nd fruit for free, you purchased it because it is more optimal.\nIt can be proven that 4 is the minimum number of coins needed to acquire all the fruits.", "**Input:** prices = [1,10,1,1]\n**Output:** 2\n**Explanation:** You can acquire the fruits as follows:\n- Purchase the 1st fruit with 1 coin, you are allowed to take the 2nd fruit for free.\n- Take the 2nd fruit for free.\n- Purchase the 3rd fruit for 1 coin, you are allowed to take the 4th fruit for free.\n- Take the 4th fruit for free.\nIt can be proven that 2 is the minimum number of coins needed to acquire all the fruits."], "constraints": "**Constraints:**\n\n\n* `1 <= prices.length <= 1000`\n* `1 <= prices[i] <= 105`", "difficulty": "Medium", "tags": ["Array", "Dynamic Programming", "Queue", "Monotonic Queue"], "hints": ["The intended solution uses Dynamic Programming.", "Let <code>dp[i]</code> denote the minimum number of coins, such that we bought <code>i<sup>th</sup></code>\u00a0fruit and acquired all the fruits in the range <code>[i...n]</code>.", "<code>dp[i] = min(dp[i], dp[j] + prices[i]) </code>, where <code>j</code> is in the range <code>[i + 1, i + 1 + i]</code>."], "templates": {"cpp": "class Solution {\npublic:\n    int minimumCoins(vector<int>& prices) {\n        \n    }\n};", "java": "class Solution {\n    public int minimumCoins(int[] prices) {\n        \n    }\n}", "python": "class Solution(object):\n    def minimumCoins(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def minimumCoins(self, prices: List[int]) -> int:\n        ", "c": "int minimumCoins(int* prices, int pricesSize) {\n    \n}", "csharp": "public class Solution {\n    public int MinimumCoins(int[] prices) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} prices\n * @return {number}\n */\nvar minimumCoins = function(prices) {\n    \n};", "typescript": "function minimumCoins(prices: number[]): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $prices\n     * @return Integer\n     */\n    function minimumCoins($prices) {\n        \n    }\n}", "swift": "class Solution {\n    func minimumCoins(_ prices: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun minimumCoins(prices: IntArray): Int {\n        \n    }\n}", "dart": "class Solution {\n  int minimumCoins(List<int> prices) {\n    \n  }\n}", "golang": "func minimumCoins(prices []int) int {\n    \n}", "ruby": "# @param {Integer[]} prices\n# @return {Integer}\ndef minimum_coins(prices)\n    \nend", "scala": "object Solution {\n    def minimumCoins(prices: Array[Int]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn minimum_coins(prices: Vec<i32>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (minimum-coins prices)\n  (-> (listof exact-integer?) exact-integer?)\n  )", "erlang": "-spec minimum_coins(Prices :: [integer()]) -> integer().\nminimum_coins(Prices) ->\n  .", "elixir": "defmodule Solution do\n  @spec minimum_coins(prices :: [integer]) :: integer\n  def minimum_coins(prices) do\n    \n  end\nend"}}
{"id": "leetcode_2856", "url": "https://leetcode.com/problems/minimum-array-length-after-pair-removals/", "title": "Minimum Array Length After Pair Removals", "description": "You are given a **0-indexed** **sorted** array of integers `nums`.\n\n\nYou can perform the following operation any number of times:\n\n\n* Choose **two** indices, `i` and `j`, where `i < j`, such that `nums[i] < nums[j]`.\n* Then, remove the elements at indices `i` and `j` from `nums`. The remaining elements retain their original order, and the array is re-indexed.\n\n\nReturn *an integer that denotes the **minimum** length of* `nums` *after performing the operation any number of times (**including zero**).*\n\n\nNote that `nums` is sorted in **non-decreasing** order.", "examples": ["**Input:** nums = [1,3,4,9]\n**Output:** 0\n**Explanation:** Initially, nums = [1, 3, 4, 9].\nIn the first operation, we can choose index 0 and 1 because nums[0] < nums[1] <=> 1 < 3.\nRemove indices 0 and 1, and nums becomes [4, 9].\nFor the next operation, we can choose index 0 and 1 because nums[0] < nums[1] <=> 4 < 9.\nRemove indices 0 and 1, and nums becomes an empty array [].\nHence, the minimum length achievable is 0.", "**Input:** nums = [2,3,6,9]\n**Output:** 0\n**Explanation:** Initially, nums = [2, 3, 6, 9]. \nIn the first operation, we can choose index 0 and 2 because nums[0] < nums[2] <=> 2 < 6. \nRemove indices 0 and 2, and nums becomes [3, 9]. \nFor the next operation, we can choose index 0 and 1 because nums[0] < nums[1] <=> 3 < 9. \nRemove indices 0 and 1, and nums becomes an empty array []. \nHence, the minimum length achievable is 0.", "**Input:** nums = [1,1,2]\n**Output:** 1\n**Explanation:** Initially, nums = [1, 1, 2].\nIn an operation, we can choose index 0 and 2 because nums[0] < nums[2] <=> 1 < 2. \nRemove indices 0 and 2, and nums becomes [1]. \nIt is no longer possible to perform an operation on the array. \nHence, the minimum achievable length is 1."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `1 <= nums[i] <= 109`\n* `nums` is sorted in **non-decreasing** order.", "difficulty": "Medium", "tags": ["Array", "Hash Table", "Two Pointers", "Binary Search", "Greedy", "Counting"], "hints": ["To minimize the length of the array, we should maximize the number of operations performed.", "To perform <code>k</code> operations, it is optimal to use the smallest <code>k</code> values and the largest <code>k</code> values in <code>nums</code>.", "What is the best way to make pairs from the smallest <code>k</code> values and the largest <code>k</code> values so it is possible to remove all the pairs?", "If we consider the smallest <code>k</code> values and the largest <code>k</code> values as two separate <strong>sorted 0-indexed</strong> arrays, <code>a</code> and <code>b</code>, It is optimal to pair <code>a[i]</code> and <code>b[i]</code>. So, a <code>k</code> is valid if <code>a[i] < b[i]</code> for all <code>i</code> in the range <code>[0, k - 1]</code>.", "The greatest possible valid <code>k</code> can be found using binary search.", "The answer is <code>nums.length - 2 * k</code>."], "templates": {"cpp": "class Solution {\npublic:\n    int minLengthAfterRemovals(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public int minLengthAfterRemovals(List<Integer> nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def minLengthAfterRemovals(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def minLengthAfterRemovals(self, nums: List[int]) -> int:\n        ", "c": "int minLengthAfterRemovals(int* nums, int numsSize){\n\n}", "csharp": "public class Solution {\n    public int MinLengthAfterRemovals(IList<int> nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minLengthAfterRemovals = function(nums) {\n    \n};", "typescript": "function minLengthAfterRemovals(nums: number[]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function minLengthAfterRemovals($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func minLengthAfterRemovals(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun minLengthAfterRemovals(nums: List<Int>): Int {\n        \n    }\n}", "dart": "class Solution {\n  int minLengthAfterRemovals(List<int> nums) {\n\n  }\n}", "golang": "func minLengthAfterRemovals(nums []int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef min_length_after_removals(nums)\n    \nend", "scala": "object Solution {\n    def minLengthAfterRemovals(nums: List[Int]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn min_length_after_removals(nums: Vec<i32>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (min-length-after-removals nums)\n  (-> (listof exact-integer?) exact-integer?)\n\n  )", "erlang": "-spec min_length_after_removals(Nums :: [integer()]) -> integer().\nmin_length_after_removals(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec min_length_after_removals(nums :: [integer]) :: integer\n  def min_length_after_removals(nums) do\n\n  end\nend"}}
{"id": "leetcode_2786", "url": "https://leetcode.com/problems/visit-array-positions-to-maximize-score/", "title": "Visit Array Positions to Maximize Score", "description": "You are given a **0-indexed** integer array `nums` and a positive integer `x`.\n\n\nYou are **initially** at position `0` in the array and you can visit other positions according to the following rules:\n\n\n* If you are currently in position `i`, then you can move to **any** position `j` such that `i < j`.\n* For each position `i` that you visit, you get a score of `nums[i]`.\n* If you move from a position `i` to a position `j` and the **parities** of `nums[i]` and `nums[j]` differ, then you lose a score of `x`.\n\n\nReturn *the **maximum** total score you can get*.\n\n\n**Note** that initially you have `nums[0]` points.", "examples": ["**Input:** nums = [2,3,6,1,9,2], x = 5\n**Output:** 13\n**Explanation:** We can visit the following positions in the array: 0 -> 2 -> 3 -> 4.\nThe corresponding values are 2, 6, 1 and 9. Since the integers 6 and 1 have different parities, the move 2 -> 3 will make you lose a score of x = 5.\nThe total score will be: 2 + 6 + 1 + 9 - 5 = 13.", "**Input:** nums = [2,4,6,8], x = 3\n**Output:** 20\n**Explanation:** All the integers in the array have the same parities, so we can visit all of them without losing any score.\nThe total score is: 2 + 4 + 6 + 8 = 20."], "constraints": "**Constraints:**\n\n\n* `2 <= nums.length <= 105`\n* `1 <= nums[i], x <= 106`", "difficulty": "Medium", "tags": ["Array", "Dynamic Programming"], "hints": ["How can we use dynamic programming to solve the problem?", "Let dp[i] be the answer to the subarray nums[0\u2026i]. What are the transitions of this dp?"], "templates": {"cpp": "class Solution {\npublic:\n    long long maxScore(vector<int>& nums, int x) {\n        \n    }\n};", "java": "class Solution {\n    public long maxScore(int[] nums, int x) {\n        \n    }\n}", "python": "class Solution(object):\n    def maxScore(self, nums, x):\n        \"\"\"\n        :type nums: List[int]\n        :type x: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def maxScore(self, nums: List[int], x: int) -> int:\n        ", "c": "long long maxScore(int* nums, int numsSize, int x){\n\n}", "csharp": "public class Solution {\n    public long MaxScore(int[] nums, int x) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @param {number} x\n * @return {number}\n */\nvar maxScore = function(nums, x) {\n    \n};", "typescript": "function maxScore(nums: number[], x: number): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $x\n     * @return Integer\n     */\n    function maxScore($nums, $x) {\n        \n    }\n}", "swift": "class Solution {\n    func maxScore(_ nums: [Int], _ x: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun maxScore(nums: IntArray, x: Int): Long {\n        \n    }\n}", "dart": "class Solution {\n  int maxScore(List<int> nums, int x) {\n\n  }\n}", "golang": "func maxScore(nums []int, x int) int64 {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @param {Integer} x\n# @return {Integer}\ndef max_score(nums, x)\n    \nend", "scala": "object Solution {\n    def maxScore(nums: Array[Int], x: Int): Long = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn max_score(nums: Vec<i32>, x: i32) -> i64 {\n        \n    }\n}", "racket": "(define/contract (max-score nums x)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n\n  )", "erlang": "-spec max_score(Nums :: [integer()], X :: integer()) -> integer().\nmax_score(Nums, X) ->\n  .", "elixir": "defmodule Solution do\n  @spec max_score(nums :: [integer], x :: integer) :: integer\n  def max_score(nums, x) do\n\n  end\nend"}}
{"id": "leetcode_2712", "url": "https://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/", "title": "Minimum Cost to Make All Characters Equal", "description": "You are given a **0-indexed** binary string `s` of length `n` on which you can apply two types of operations:\n\n\n* Choose an index `i` and invert all characters from\u00a0index `0` to index `i`\u00a0(both inclusive), with a cost of `i + 1`\n* Choose an index `i` and invert all characters\u00a0from\u00a0index `i` to index `n - 1`\u00a0(both inclusive), with a cost of `n - i`\n\n\nReturn *the **minimum cost** to make all characters of the string **equal***.\n\n\n**Invert** a character means\u00a0if its value is '0' it becomes '1' and vice-versa.", "examples": ["**Input:** s = \"0011\"\n**Output:** 2\n**Explanation:** Apply the second operation with i = 2 to obtain s = \"0000\" for a cost of 2. It can be shown that 2 is the minimum cost to make all characters equal.", "**Input:** s = \"010101\"\n**Output:** 9\n**Explanation:** Apply the first operation with i = 2 to obtain s = \"101101\" for a cost of 3.\nApply the first operation with i = 1 to obtain s = \"011101\" for a cost of 2. \nApply the first operation with i = 0 to obtain s = \"111101\" for a cost of 1. \nApply the second operation with i = 4 to obtain s = \"111110\" for a cost of 2.\nApply the second operation with i = 5 to obtain s = \"111111\" for a cost of 1. \nThe total cost to make all characters equal is 9. It can be shown that 9 is the minimum cost to make all characters equal."], "constraints": "**Constraints:**\n\n\n* `1 <= s.length == n <= 105`\n* `s[i]` is either `'0'` or `'1'`", "difficulty": "Medium", "tags": ["String", "Dynamic Programming", "Greedy"], "hints": ["For every index i, calculate the number of operations required to make the prefix [0, i - 1] equal to the character at index i, denoted prefix[i].", "For every index i, calculate the number of operations required to make the suffix [i + 1, n - 1] equal to the character at index i, denoted suffix[i].", "The final string will contain at least one character that is left unchanged; Therefore, the answer is the minimum of prefix[i] + suffix[i] for every i in [0, n - 1]."], "templates": {"cpp": "class Solution {\npublic:\n    long long minimumCost(string s) {\n        \n    }\n};", "java": "class Solution {\n    public long minimumCost(String s) {\n        \n    }\n}", "python": "class Solution(object):\n    def minimumCost(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def minimumCost(self, s: str) -> int:\n        ", "c": "long long minimumCost(char * s){\n\n}", "csharp": "public class Solution {\n    public long MinimumCost(string s) {\n        \n    }\n}", "javascript": "/**\n * @param {string} s\n * @return {number}\n */\nvar minimumCost = function(s) {\n    \n};", "typescript": "function minimumCost(s: string): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function minimumCost($s) {\n        \n    }\n}", "swift": "class Solution {\n    func minimumCost(_ s: String) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun minimumCost(s: String): Long {\n        \n    }\n}", "dart": "class Solution {\n  int minimumCost(String s) {\n\n  }\n}", "golang": "func minimumCost(s string) int64 {\n    \n}", "ruby": "# @param {String} s\n# @return {Integer}\ndef minimum_cost(s)\n    \nend", "scala": "object Solution {\n    def minimumCost(s: String): Long = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn minimum_cost(s: String) -> i64 {\n        \n    }\n}", "racket": "(define/contract (minimum-cost s)\n  (-> string? exact-integer?)\n\n  )", "erlang": "-spec minimum_cost(S :: unicode:unicode_binary()) -> integer().\nminimum_cost(S) ->\n  .", "elixir": "defmodule Solution do\n  @spec minimum_cost(s :: String.t) :: integer\n  def minimum_cost(s) do\n\n  end\nend"}}
{"id": "leetcode_2895", "url": "https://leetcode.com/problems/minimum-processing-time/", "title": "Minimum Processing Time", "description": "You have `n` processors each having `4` cores and `n * 4` tasks that need to be executed such that each core should perform only **one** task.\n\n\nGiven a **0-indexed** integer array `processorTime` representing the time at which each processor becomes available for the first time and a **0-indexed** integer array `tasks` representing the time it takes to execute each task, return *the **minimum** time when all of the tasks have been executed by the processors.*\n\n\n**Note:** Each core executes the task independently of the others.", "examples": ["**Input:** processorTime = [8,10], tasks = [2,2,3,1,8,7,4,5]\n**Output:** 16\n**Explanation:** \nIt's optimal to assign the tasks at indexes 4, 5, 6, 7 to the first processor which becomes available at time = 8, and the tasks at indexes 0, 1, 2, 3 to the second processor which becomes available at time = 10. \nTime taken by the first processor to finish execution of all tasks = max(8 + 8, 8 + 7, 8 + 4, 8 + 5) = 16.\nTime taken by the second processor to finish execution of all tasks = max(10 + 2, 10 + 2, 10 + 3, 10 + 1) = 13.\nHence, it can be shown that the minimum time taken to execute all the tasks is 16.", "**Input:** processorTime = [10,20], tasks = [2,3,1,2,5,8,4,3]\n**Output:** 23\n**Explanation:** \nIt's optimal to assign the tasks at indexes 1, 4, 5, 6 to the first processor which becomes available at time = 10, and the tasks at indexes 0, 2, 3, 7 to the second processor which becomes available at time = 20.\nTime taken by the first processor to finish execution of all tasks = max(10 + 3, 10 + 5, 10 + 8, 10 + 4) = 18.\nTime taken by the second processor to finish execution of all tasks = max(20 + 2, 20 + 1, 20 + 2, 20 + 3) = 23.\nHence, it can be shown that the minimum time taken to execute all the tasks is 23."], "constraints": "**Constraints:**\n\n\n* `1 <= n == processorTime.length <= 25000`\n* `1 <= tasks.length <= 105`\n* `0 <= processorTime[i] <= 109`\n* `1 <= tasks[i] <= 109`\n* `tasks.length == 4 * n`", "difficulty": "Medium", "tags": ["Array", "Greedy", "Sorting"], "hints": ["It\u2019s optimal to make the processor with earlier process time run 4 longer tasks.****", "The largest <code>processTime[i] + tasks[j]</code> (when matched) is the answer."], "templates": {"cpp": "class Solution {\npublic:\n    int minProcessingTime(vector<int>& processorTime, vector<int>& tasks) {\n        \n    }\n};", "java": "class Solution {\n    public int minProcessingTime(List<Integer> processorTime, List<Integer> tasks) {\n        \n    }\n}", "python": "class Solution(object):\n    def minProcessingTime(self, processorTime, tasks):\n        \"\"\"\n        :type processorTime: List[int]\n        :type tasks: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def minProcessingTime(self, processorTime: List[int], tasks: List[int]) -> int:\n        ", "c": "int minProcessingTime(int* processorTime, int processorTimeSize, int* tasks, int tasksSize) {\n    \n}", "csharp": "public class Solution {\n    public int MinProcessingTime(IList<int> processorTime, IList<int> tasks) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} processorTime\n * @param {number[]} tasks\n * @return {number}\n */\nvar minProcessingTime = function(processorTime, tasks) {\n    \n};", "typescript": "function minProcessingTime(processorTime: number[], tasks: number[]): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $processorTime\n     * @param Integer[] $tasks\n     * @return Integer\n     */\n    function minProcessingTime($processorTime, $tasks) {\n        \n    }\n}", "swift": "class Solution {\n    func minProcessingTime(_ processorTime: [Int], _ tasks: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun minProcessingTime(processorTime: List<Int>, tasks: List<Int>): Int {\n        \n    }\n}", "dart": "class Solution {\n  int minProcessingTime(List<int> processorTime, List<int> tasks) {\n    \n  }\n}", "golang": "func minProcessingTime(processorTime []int, tasks []int) int {\n    \n}", "ruby": "# @param {Integer[]} processor_time\n# @param {Integer[]} tasks\n# @return {Integer}\ndef min_processing_time(processor_time, tasks)\n    \nend", "scala": "object Solution {\n    def minProcessingTime(processorTime: List[Int], tasks: List[Int]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn min_processing_time(processor_time: Vec<i32>, tasks: Vec<i32>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (min-processing-time processorTime tasks)\n  (-> (listof exact-integer?) (listof exact-integer?) exact-integer?)\n  )", "erlang": "-spec min_processing_time(ProcessorTime :: [integer()], Tasks :: [integer()]) -> integer().\nmin_processing_time(ProcessorTime, Tasks) ->\n  .", "elixir": "defmodule Solution do\n  @spec min_processing_time(processor_time :: [integer], tasks :: [integer]) :: integer\n  def min_processing_time(processor_time, tasks) do\n    \n  end\nend"}}
{"id": "leetcode_2745", "url": "https://leetcode.com/problems/construct-the-longest-new-string/", "title": "Construct the Longest New String", "description": "You are given three integers `x`, `y`, and `z`.\n\n\nYou have `x` strings equal to `\"AA\"`, `y` strings equal to `\"BB\"`, and `z` strings equal to `\"AB\"`. You want to choose some (possibly all or none) of these strings and concatenate them in some order to form a new string. This new string must not contain `\"AAA\"` or `\"BBB\"` as a substring.\n\n\nReturn *the maximum possible length of the new string*.\n\n\nA **substring** is a contiguous **non-empty** sequence of characters within a string.", "examples": ["**Input:** x = 2, y = 5, z = 1\n**Output:** 12\n**Explanation:** We can concactenate the strings \"BB\", \"AA\", \"BB\", \"AA\", \"BB\", and \"AB\" in that order. Then, our new string is \"BBAABBAABBAB\". \nThat string has length 12, and we can show that it is impossible to construct a string of longer length.", "**Input:** x = 3, y = 2, z = 2\n**Output:** 14\n**Explanation:** We can concactenate the strings \"AB\", \"AB\", \"AA\", \"BB\", \"AA\", \"BB\", and \"AA\" in that order. Then, our new string is \"ABABAABBAABBAA\". \nThat string has length 14, and we can show that it is impossible to construct a string of longer length."], "constraints": "**Constraints:**\n\n\n* `1 <= x, y, z <= 50`", "difficulty": "Medium", "tags": ["Math", "Greedy", "Brainteaser"], "hints": ["It can be proved that ALL \u201cAB\u201ds can be used in the optimal solution.\r\n(1) If the final string starts with 'A', we can put all unused \u201cAB\u201ds at the very beginning.\r\n(2) If the final string starts with 'B' (meaning) it starts with \u201cBB\u201d, we can put all unused \u201cAB\u201ds after the 2nd 'B'.", "Using \u201cAB\u201d doesn\u2019t increase the number of \u201cAA\u201ds or \u201cBB\u201ds we can use.\r\nIf we put an \u201cAB\u201d after \u201cBB\u201d, then we still need to append \u201cAA\u201d as before, so it doesn\u2019t change the state.", "We only need to consider strings \u201cAA\u201d and \u201cBB\u201d; we can either use the pattern \u201cAABBAABB\u2026\u201d or the pattern \u201cBBAABBAA\u2026\u201d, depending on which one of x and y is larger."], "templates": {"cpp": "class Solution {\npublic:\n    int longestString(int x, int y, int z) {\n        \n    }\n};", "java": "class Solution {\n    public int longestString(int x, int y, int z) {\n        \n    }\n}", "python": "class Solution(object):\n    def longestString(self, x, y, z):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :type z: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def longestString(self, x: int, y: int, z: int) -> int:\n        ", "c": "int longestString(int x, int y, int z){\n\n}", "csharp": "public class Solution {\n    public int LongestString(int x, int y, int z) {\n        \n    }\n}", "javascript": "/**\n * @param {number} x\n * @param {number} y\n * @param {number} z\n * @return {number}\n */\nvar longestString = function(x, y, z) {\n    \n};", "typescript": "function longestString(x: number, y: number, z: number): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer $x\n     * @param Integer $y\n     * @param Integer $z\n     * @return Integer\n     */\n    function longestString($x, $y, $z) {\n        \n    }\n}", "swift": "class Solution {\n    func longestString(_ x: Int, _ y: Int, _ z: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun longestString(x: Int, y: Int, z: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int longestString(int x, int y, int z) {\n\n  }\n}", "golang": "func longestString(x int, y int, z int) int {\n    \n}", "ruby": "# @param {Integer} x\n# @param {Integer} y\n# @param {Integer} z\n# @return {Integer}\ndef longest_string(x, y, z)\n    \nend", "scala": "object Solution {\n    def longestString(x: Int, y: Int, z: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn longest_string(x: i32, y: i32, z: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (longest-string x y z)\n  (-> exact-integer? exact-integer? exact-integer? exact-integer?)\n\n  )", "erlang": "-spec longest_string(X :: integer(), Y :: integer(), Z :: integer()) -> integer().\nlongest_string(X, Y, Z) ->\n  .", "elixir": "defmodule Solution do\n  @spec longest_string(x :: integer, y :: integer, z :: integer) :: integer\n  def longest_string(x, y, z) do\n\n  end\nend"}}
{"id": "leetcode_2909", "url": "https://leetcode.com/problems/minimum-sum-of-mountain-triplets-ii/", "title": "Minimum Sum of Mountain Triplets II", "description": "You are given a **0-indexed** array `nums` of integers.\n\n\nA triplet of indices `(i, j, k)` is a **mountain** if:\n\n\n* `i < j < k`\n* `nums[i] < nums[j]` and `nums[k] < nums[j]`\n\n\nReturn *the **minimum possible sum** of a mountain triplet of* `nums`. *If no such triplet exists, return* `-1`.", "examples": ["**Input:** nums = [8,6,1,5,3]\n**Output:** 9\n**Explanation:** Triplet (2, 3, 4) is a mountain triplet of sum 9 since: \n- 2 < 3 < 4\n- nums[2] < nums[3] and nums[4] < nums[3]\nAnd the sum of this triplet is nums[2] + nums[3] + nums[4] = 9. It can be shown that there are no mountain triplets with a sum of less than 9.", "**Input:** nums = [5,4,8,7,10,2]\n**Output:** 13\n**Explanation:** Triplet (1, 3, 5) is a mountain triplet of sum 13 since: \n- 1 < 3 < 5\n- nums[1] < nums[3] and nums[5] < nums[3]\nAnd the sum of this triplet is nums[1] + nums[3] + nums[5] = 13. It can be shown that there are no mountain triplets with a sum of less than 13.", "**Input:** nums = [6,5,4,3,4,5]\n**Output:** -1\n**Explanation:** It can be shown that there are no mountain triplets in nums."], "constraints": "**Constraints:**\n\n\n* `3 <= nums.length <= 105`\n* `1 <= nums[i] <= 108`", "difficulty": "Medium", "tags": ["Array"], "hints": ["If you fix index <code>j</code>, <code>i</code> will be the smallest integer to the left of <code>j</code>, and <code>k</code> the largest integer to the right of <code>j</code>.", "To find <code>i</code> and <code>k</code>, preprocess the prefix minimum array <code>prefix_min[i] = min(nums[0], nums[1], ..., nums[i])</code>, and the suffix minimum array <code>suffix_min[i] = min(nums[i], nums[i + 1], ..., nums[i - 1])</code>."], "templates": {"cpp": "class Solution {\npublic:\n    int minimumSum(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public int minimumSum(int[] nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def minimumSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def minimumSum(self, nums: List[int]) -> int:\n        ", "c": "int minimumSum(int* nums, int numsSize) {\n    \n}", "csharp": "public class Solution {\n    public int MinimumSum(int[] nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minimumSum = function(nums) {\n    \n};", "typescript": "function minimumSum(nums: number[]): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function minimumSum($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func minimumSum(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun minimumSum(nums: IntArray): Int {\n        \n    }\n}", "dart": "class Solution {\n  int minimumSum(List<int> nums) {\n    \n  }\n}", "golang": "func minimumSum(nums []int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef minimum_sum(nums)\n    \nend", "scala": "object Solution {\n    def minimumSum(nums: Array[Int]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn minimum_sum(nums: Vec<i32>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (minimum-sum nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )", "erlang": "-spec minimum_sum(Nums :: [integer()]) -> integer().\nminimum_sum(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec minimum_sum(nums :: [integer]) :: integer\n  def minimum_sum(nums) do\n    \n  end\nend"}}
{"id": "leetcode_2698", "url": "https://leetcode.com/problems/find-the-punishment-number-of-an-integer/", "title": "Find the Punishment Number of an Integer", "description": "Given a positive integer `n`, return *the **punishment number*** of `n`.\n\n\nThe **punishment number** of `n` is defined as the sum of the squares of all integers `i` such that:\n\n\n* `1 <= i <= n`\n* The decimal representation of `i * i` can be partitioned into contiguous substrings such that the sum of the integer values of these substrings equals `i`.", "examples": ["**Input:** n = 10\n**Output:** 182\n**Explanation:** There are exactly 3 integers i that satisfy the conditions in the statement:\n- 1 since 1 * 1 = 1\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1.\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0.\nHence, the punishment number of 10 is 1 + 81 + 100 = 182", "**Input:** n = 37\n**Output:** 1478\n**Explanation:** There are exactly 4 integers i that satisfy the conditions in the statement:\n- 1 since 1 * 1 = 1. \n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. \n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. \n- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.\nHence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478"], "constraints": "**Constraints:**\n\n\n* `1 <= n <= 1000`", "difficulty": "Medium", "tags": ["Math", "Backtracking"], "hints": ["Can we generate all possible partitions of a number?", "Use a recursive algorithm that splits the number into two parts, generates all possible partitions of each part recursively, and then combines them in all possible ways."], "templates": {"cpp": "class Solution {\npublic:\n    int punishmentNumber(int n) {\n        \n    }\n};", "java": "class Solution {\n    public int punishmentNumber(int n) {\n        \n    }\n}", "python": "class Solution(object):\n    def punishmentNumber(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def punishmentNumber(self, n: int) -> int:\n        ", "c": "int punishmentNumber(int n){\n\n}", "csharp": "public class Solution {\n    public int PunishmentNumber(int n) {\n        \n    }\n}", "javascript": "/**\n * @param {number} n\n * @return {number}\n */\nvar punishmentNumber = function(n) {\n    \n};", "typescript": "function punishmentNumber(n: number): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return Integer\n     */\n    function punishmentNumber($n) {\n        \n    }\n}", "swift": "class Solution {\n    func punishmentNumber(_ n: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun punishmentNumber(n: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int punishmentNumber(int n) {\n\n  }\n}", "golang": "func punishmentNumber(n int) int {\n    \n}", "ruby": "# @param {Integer} n\n# @return {Integer}\ndef punishment_number(n)\n    \nend", "scala": "object Solution {\n    def punishmentNumber(n: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn punishment_number(n: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (punishment-number n)\n  (-> exact-integer? exact-integer?)\n\n  )", "erlang": "-spec punishment_number(N :: integer()) -> integer().\npunishment_number(N) ->\n  .", "elixir": "defmodule Solution do\n  @spec punishment_number(n :: integer) :: integer\n  def punishment_number(n) do\n\n  end\nend"}}
{"id": "leetcode_2948", "url": "https://leetcode.com/problems/make-lexicographically-smallest-array-by-swapping-elements/", "title": "Make Lexicographically Smallest Array by Swapping Elements", "description": "You are given a **0-indexed** array of **positive** integers `nums` and a **positive** integer `limit`.\n\n\nIn one operation, you can choose any two indices `i` and `j` and swap `nums[i]` and `nums[j]` **if** `|nums[i] - nums[j]| <= limit`.\n\n\nReturn *the **lexicographically smallest array** that can be obtained by performing the operation any number of times*.\n\n\nAn array `a` is lexicographically smaller than an array `b` if in the first position where `a` and `b` differ, array `a` has an element that is less than the corresponding element in `b`. For example, the array `[2,10,3]` is lexicographically smaller than the array `[10,2,3]` because they differ at index `0` and `2 < 10`.", "examples": ["**Input:** nums = [1,5,3,9,8], limit = 2\n**Output:** [1,3,5,8,9]\n**Explanation:** Apply the operation 2 times:\n- Swap nums[1] with nums[2]. The array becomes [1,3,5,9,8]\n- Swap nums[3] with nums[4]. The array becomes [1,3,5,8,9]\nWe cannot obtain a lexicographically smaller array by applying any more operations.\nNote that it may be possible to get the same result by doing different operations.", "**Input:** nums = [1,7,6,18,2,1], limit = 3\n**Output:** [1,6,7,18,1,2]\n**Explanation:** Apply the operation 3 times:\n- Swap nums[1] with nums[2]. The array becomes [1,6,7,18,2,1]\n- Swap nums[0] with nums[4]. The array becomes [2,6,7,18,1,1]\n- Swap nums[0] with nums[5]. The array becomes [1,6,7,18,1,2]\nWe cannot obtain a lexicographically smaller array by applying any more operations.", "**Input:** nums = [1,7,28,19,10], limit = 3\n**Output:** [1,7,28,19,10]\n**Explanation:** [1,7,28,19,10] is the lexicographically smallest array we can obtain because we cannot apply the operation on any two indices."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `1 <= nums[i] <= 109`\n* `1 <= limit <= 109`", "difficulty": "Medium", "tags": ["Array", "Union Find", "Sorting"], "hints": ["Construct a virtual graph where all elements in <code>nums</code> are nodes and the pairs satisfying the condition have an edge between them.", "Instead of constructing all edges, we only care about the connected components.", "Can we use DSU?", "Sort <code>nums</code>. Now we just need to consider if the consecutive elements have an edge to check if they belong to the same connected component. Hence, all connected components become a list of position-consecutive elements after sorting.", "For each index of <code>nums</code> from <code>0</code> to <code>nums.length - 1</code> we can change it to the current minimum value we have in its connected component and remove that value from the connected component."], "templates": {"cpp": "class Solution {\npublic:\n    vector<int> lexicographicallySmallestArray(vector<int>& nums, int limit) {\n        \n    }\n};", "java": "class Solution {\n    public int[] lexicographicallySmallestArray(int[] nums, int limit) {\n        \n    }\n}", "python": "class Solution(object):\n    def lexicographicallySmallestArray(self, nums, limit):\n        \"\"\"\n        :type nums: List[int]\n        :type limit: int\n        :rtype: List[int]\n        \"\"\"\n        ", "python3": "class Solution:\n    def lexicographicallySmallestArray(self, nums: List[int], limit: int) -> List[int]:\n        ", "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* lexicographicallySmallestArray(int* nums, int numsSize, int limit, int* returnSize) {\n    \n}", "csharp": "public class Solution {\n    public int[] LexicographicallySmallestArray(int[] nums, int limit) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @param {number} limit\n * @return {number[]}\n */\nvar lexicographicallySmallestArray = function(nums, limit) {\n    \n};", "typescript": "function lexicographicallySmallestArray(nums: number[], limit: number): number[] {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $limit\n     * @return Integer[]\n     */\n    function lexicographicallySmallestArray($nums, $limit) {\n        \n    }\n}", "swift": "class Solution {\n    func lexicographicallySmallestArray(_ nums: [Int], _ limit: Int) -> [Int] {\n        \n    }\n}", "kotlin": "class Solution {\n    fun lexicographicallySmallestArray(nums: IntArray, limit: Int): IntArray {\n        \n    }\n}", "dart": "class Solution {\n  List<int> lexicographicallySmallestArray(List<int> nums, int limit) {\n    \n  }\n}", "golang": "func lexicographicallySmallestArray(nums []int, limit int) []int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @param {Integer} limit\n# @return {Integer[]}\ndef lexicographically_smallest_array(nums, limit)\n    \nend", "scala": "object Solution {\n    def lexicographicallySmallestArray(nums: Array[Int], limit: Int): Array[Int] = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn lexicographically_smallest_array(nums: Vec<i32>, limit: i32) -> Vec<i32> {\n        \n    }\n}", "racket": "(define/contract (lexicographically-smallest-array nums limit)\n  (-> (listof exact-integer?) exact-integer? (listof exact-integer?))\n  )", "erlang": "-spec lexicographically_smallest_array(Nums :: [integer()], Limit :: integer()) -> [integer()].\nlexicographically_smallest_array(Nums, Limit) ->\n  .", "elixir": "defmodule Solution do\n  @spec lexicographically_smallest_array(nums :: [integer], limit :: integer) :: [integer]\n  def lexicographically_smallest_array(nums, limit) do\n    \n  end\nend"}}
{"id": "leetcode_2933", "url": "https://leetcode.com/problems/high-access-employees/", "title": "High-Access Employees", "description": "You are given a 2D **0-indexed** array of strings, `access_times`, with size `n`. For each `i` where `0 <= i <= n - 1`, `access_times[i][0]` represents the name of an employee, and `access_times[i][1]` represents the access time of that employee. All entries in `access_times` are within the same day.\n\n\nThe access time is represented as **four digits** using a **24-hour** time format, for example, `\"0800\"` or `\"2250\"`.\n\n\nAn employee is said to be **high-access** if he has accessed the system **three or more** times within a **one-hour period**.\n\n\nTimes with exactly one hour of difference are **not** considered part of the same one-hour period. For example, `\"0815\"` and `\"0915\"` are not part of the same one-hour period.\n\n\nAccess times at the start and end of the day are **not** counted within the same one-hour period. For example, `\"0005\"` and `\"2350\"` are not part of the same one-hour period.\n\n\nReturn *a list that contains the names of **high-access** employees with any order you want.*", "examples": ["**Input:** access_times = [[\"a\",\"0549\"],[\"b\",\"0457\"],[\"a\",\"0532\"],[\"a\",\"0621\"],[\"b\",\"0540\"]]\n**Output:** [\"a\"]\n**Explanation:** \"a\" has three access times in the one-hour period of [05:32, 06:31] which are 05:32, 05:49, and 06:21.\nBut \"b\" does not have more than two access times at all.\nSo the answer is [\"a\"].", "**Input:** access_times = [[\"d\",\"0002\"],[\"c\",\"0808\"],[\"c\",\"0829\"],[\"e\",\"0215\"],[\"d\",\"1508\"],[\"d\",\"1444\"],[\"d\",\"1410\"],[\"c\",\"0809\"]]\n**Output:** [\"c\",\"d\"]\n**Explanation:** \"c\" has three access times in the one-hour period of [08:08, 09:07] which are 08:08, 08:09, and 08:29.\n\"d\" has also three access times in the one-hour period of [14:10, 15:09] which are 14:10, 14:44, and 15:08.\nHowever, \"e\" has just one access time, so it can not be in the answer and the final answer is [\"c\",\"d\"].", "**Input:** access_times = [[\"cd\",\"1025\"],[\"ab\",\"1025\"],[\"cd\",\"1046\"],[\"cd\",\"1055\"],[\"ab\",\"1124\"],[\"ab\",\"1120\"]]\n**Output:** [\"ab\",\"cd\"]\n**Explanation:** \"ab\" has three access times in the one-hour period of [10:25, 11:24] which are 10:25, 11:20, and 11:24.\n\"cd\" has also three access times in the one-hour period of [10:25, 11:24] which are 10:25, 10:46, and 10:55.\nSo the answer is [\"ab\",\"cd\"]."], "constraints": "**Constraints:**\n\n\n* `1 <= access_times.length <= 100`\n* `access_times[i].length == 2`\n* `1 <= access_times[i][0].length <= 10`\n* `access_times[i][0]` consists only of English small letters.\n* `access_times[i][1].length == 4`\n* `access_times[i][1]` is in 24-hour time format.\n* `access_times[i][1]` consists only of `'0'` to `'9'`.", "difficulty": "Medium", "tags": ["Array", "Hash Table", "String", "Sorting"], "hints": ["Sort the access times in each person\u2019s list.", "A person\u2019s name should be in the answer list if there are <code>2</code> access times in his/her access time list (after sorting), where the index difference is at least <code>2</code> and the time difference is strictly less than <code>60</code> minutes."], "templates": {"cpp": "class Solution {\npublic:\n    vector<string> findHighAccessEmployees(vector<vector<string>>& access_times) {\n        \n    }\n};", "java": "class Solution {\n    public List<String> findHighAccessEmployees(List<List<String>> access_times) {\n        \n    }\n}", "python": "class Solution(object):\n    def findHighAccessEmployees(self, access_times):\n        \"\"\"\n        :type access_times: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        ", "python3": "class Solution:\n    def findHighAccessEmployees(self, access_times: List[List[str]]) -> List[str]:\n        ", "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar** findHighAccessEmployees(char*** access_times, int access_timesSize, int* access_timesColSize, int* returnSize) {\n    \n}", "csharp": "public class Solution {\n    public IList<string> FindHighAccessEmployees(IList<IList<string>> access_times) {\n        \n    }\n}", "javascript": "/**\n * @param {string[][]} access_times\n * @return {string[]}\n */\nvar findHighAccessEmployees = function(access_times) {\n    \n};", "typescript": "function findHighAccessEmployees(access_times: string[][]): string[] {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param String[][] $access_times\n     * @return String[]\n     */\n    function findHighAccessEmployees($access_times) {\n        \n    }\n}", "swift": "class Solution {\n    func findHighAccessEmployees(_ access_times: [[String]]) -> [String] {\n        \n    }\n}", "kotlin": "class Solution {\n    fun findHighAccessEmployees(access_times: List<List<String>>): List<String> {\n        \n    }\n}", "dart": "class Solution {\n  List<String> findHighAccessEmployees(List<List<String>> access_times) {\n    \n  }\n}", "golang": "func findHighAccessEmployees(access_times [][]string) []string {\n    \n}", "ruby": "# @param {String[][]} access_times\n# @return {String[]}\ndef find_high_access_employees(access_times)\n    \nend", "scala": "object Solution {\n    def findHighAccessEmployees(access_times: List[List[String]]): List[String] = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn find_high_access_employees(access_times: Vec<Vec<String>>) -> Vec<String> {\n        \n    }\n}", "racket": "(define/contract (find-high-access-employees access_times)\n  (-> (listof (listof string?)) (listof string?))\n  )", "erlang": "-spec find_high_access_employees(Access_times :: [[unicode:unicode_binary()]]) -> [unicode:unicode_binary()].\nfind_high_access_employees(Access_times) ->\n  .", "elixir": "defmodule Solution do\n  @spec find_high_access_employees(access_times :: [[String.t]]) :: [String.t]\n  def find_high_access_employees(access_times) do\n    \n  end\nend"}}
{"id": "leetcode_2708", "url": "https://leetcode.com/problems/maximum-strength-of-a-group/", "title": "Maximum Strength of a Group", "description": "You are given a **0-indexed** integer array `nums` representing the score of students in an exam. The teacher would like to form one **non-empty** group of students with maximal **strength**, where the strength of a group of students of indices `i0`, `i1`, `i2`, ... , `ik` is defined as `nums[i0] * nums[i1] * nums[i2] * ... * nums[ik\u200b]`.\n\n\nReturn *the maximum strength of a group the teacher can create*.", "examples": ["**Input:** nums = [3,-1,-5,2,5,-9]\n**Output:** 1350\n**Explanation:** One way to form a group of maximal strength is to group the students at indices [0,2,3,4,5]. Their strength is 3 * (-5) * 2 * 5 * (-9) = 1350, which we can show is optimal.", "**Input:** nums = [-4,-5,-4]\n**Output:** 20\n**Explanation:** Group the students at indices [0, 1] . Then, we\u2019ll have a resulting strength of 20. We cannot achieve greater strength."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 13`\n* `-9 <= nums[i] <= 9`", "difficulty": "Medium", "tags": ["Array", "Backtracking", "Greedy", "Sorting"], "hints": ["Try to generate all pairs of subsets and check which group provides maximal strength.", "It can also be solved in O(NlogN) by sorting the array and using all positive integers.", "Use negative integers only in pairs such that their product becomes positive."], "templates": {"cpp": "class Solution {\npublic:\n    long long maxStrength(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public long maxStrength(int[] nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def maxStrength(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def maxStrength(self, nums: List[int]) -> int:\n        ", "c": "long long maxStrength(int* nums, int numsSize){\n\n}", "csharp": "public class Solution {\n    public long MaxStrength(int[] nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxStrength = function(nums) {\n    \n};", "typescript": "function maxStrength(nums: number[]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function maxStrength($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func maxStrength(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun maxStrength(nums: IntArray): Long {\n        \n    }\n}", "dart": "class Solution {\n  int maxStrength(List<int> nums) {\n\n  }\n}", "golang": "func maxStrength(nums []int) int64 {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef max_strength(nums)\n    \nend", "scala": "object Solution {\n    def maxStrength(nums: Array[Int]): Long = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn max_strength(nums: Vec<i32>) -> i64 {\n        \n    }\n}", "racket": "(define/contract (max-strength nums)\n  (-> (listof exact-integer?) exact-integer?)\n\n  )", "erlang": "-spec max_strength(Nums :: [integer()]) -> integer().\nmax_strength(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec max_strength(nums :: [integer]) :: integer\n  def max_strength(nums) do\n\n  end\nend"}}
{"id": "leetcode_2861", "url": "https://leetcode.com/problems/maximum-number-of-alloys/", "title": "Maximum Number of Alloys", "description": "You are the owner of a company that creates alloys using various types of metals. There are `n` different types of metals available, and you have access to `k` machines that can be used to create alloys. Each machine requires a specific amount of each metal type to create an alloy.\n\n\nFor the `ith` machine to create an alloy, it needs `composition[i][j]` units of metal of type `j`. Initially, you have `stock[i]` units of metal type `i`, and purchasing one unit of metal type `i` costs `cost[i]` coins.\n\n\nGiven integers `n`, `k`, `budget`, a **1-indexed** 2D array `composition`, and **1-indexed** arrays `stock` and `cost`, your goal is to **maximize** the number of alloys the company can create while staying within the budget of `budget` coins.\n\n\n**All alloys must be created with the same machine.**\n\n\nReturn *the maximum number of alloys that the company can create*.", "examples": ["**Input:** n = 3, k = 2, budget = 15, composition = [[1,1,1],[1,1,10]], stock = [0,0,0], cost = [1,2,3]\n**Output:** 2\n**Explanation:** It is optimal to use the 1st machine to create alloys.\nTo create 2 alloys we need to buy the:\n- 2 units of metal of the 1st type.\n- 2 units of metal of the 2nd type.\n- 2 units of metal of the 3rd type.\nIn total, we need 2 * 1 + 2 * 2 + 2 * 3 = 12 coins, which is smaller than or equal to budget = 15.\nNotice that we have 0 units of metal of each type and we have to buy all the required units of metal.\nIt can be proven that we can create at most 2 alloys.", "**Input:** n = 3, k = 2, budget = 15, composition = [[1,1,1],[1,1,10]], stock = [0,0,100], cost = [1,2,3]\n**Output:** 5\n**Explanation:** It is optimal to use the 2nd machine to create alloys.\nTo create 5 alloys we need to buy:\n- 5 units of metal of the 1st type.\n- 5 units of metal of the 2nd type.\n- 0 units of metal of the 3rd type.\nIn total, we need 5 * 1 + 5 * 2 + 0 * 3 = 15 coins, which is smaller than or equal to budget = 15.\nIt can be proven that we can create at most 5 alloys.", "**Input:** n = 2, k = 3, budget = 10, composition = [[2,1],[1,2],[1,1]], stock = [1,1], cost = [5,5]\n**Output:** 2\n**Explanation:** It is optimal to use the 3rd machine to create alloys.\nTo create 2 alloys we need to buy the:\n- 1 unit of metal of the 1st type.\n- 1 unit of metal of the 2nd type.\nIn total, we need 1 * 5 + 1 * 5 = 10 coins, which is smaller than or equal to budget = 10.\nIt can be proven that we can create at most 2 alloys."], "constraints": "**Constraints:**\n\n\n* `1 <= n, k <= 100`\n* `0 <= budget <= 108`\n* `composition.length == k`\n* `composition[i].length == n`\n* `1 <= composition[i][j] <= 100`\n* `stock.length == cost.length == n`\n* `0 <= stock[i] <= 108`\n* `1 <= cost[i] <= 100`", "difficulty": "Medium", "tags": ["Array", "Binary Search"], "hints": ["Use binary search to find the answer."], "templates": {"cpp": "class Solution {\npublic:\n    int maxNumberOfAlloys(int n, int k, int budget, vector<vector<int>>& composition, vector<int>& stock, vector<int>& cost) {\n        \n    }\n};", "java": "class Solution {\n    public int maxNumberOfAlloys(int n, int k, int budget, List<List<Integer>> composition, List<Integer> stock, List<Integer> cost) {\n        \n    }\n}", "python": "class Solution(object):\n    def maxNumberOfAlloys(self, n, k, budget, composition, stock, cost):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :type budget: int\n        :type composition: List[List[int]]\n        :type stock: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def maxNumberOfAlloys(self, n: int, k: int, budget: int, composition: List[List[int]], stock: List[int], cost: List[int]) -> int:\n        ", "c": "int maxNumberOfAlloys(int n, int k, int budget, int** composition, int compositionSize, int* compositionColSize, int* stock, int stockSize, int* cost, int costSize){\n\n}", "csharp": "public class Solution {\n    public int MaxNumberOfAlloys(int n, int k, int budget, IList<IList<int>> composition, IList<int> stock, IList<int> cost) {\n        \n    }\n}", "javascript": "/**\n * @param {number} n\n * @param {number} k\n * @param {number} budget\n * @param {number[][]} composition\n * @param {number[]} stock\n * @param {number[]} cost\n * @return {number}\n */\nvar maxNumberOfAlloys = function(n, k, budget, composition, stock, cost) {\n    \n};", "typescript": "function maxNumberOfAlloys(n: number, k: number, budget: number, composition: number[][], stock: number[], cost: number[]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer $k\n     * @param Integer $budget\n     * @param Integer[][] $composition\n     * @param Integer[] $stock\n     * @param Integer[] $cost\n     * @return Integer\n     */\n    function maxNumberOfAlloys($n, $k, $budget, $composition, $stock, $cost) {\n        \n    }\n}", "swift": "class Solution {\n    func maxNumberOfAlloys(_ n: Int, _ k: Int, _ budget: Int, _ composition: [[Int]], _ stock: [Int], _ cost: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun maxNumberOfAlloys(n: Int, k: Int, budget: Int, composition: List<List<Int>>, stock: List<Int>, cost: List<Int>): Int {\n        \n    }\n}", "dart": "class Solution {\n  int maxNumberOfAlloys(int n, int k, int budget, List<List<int>> composition, List<int> stock, List<int> cost) {\n\n  }\n}", "golang": "func maxNumberOfAlloys(n int, k int, budget int, composition [][]int, stock []int, cost []int) int {\n    \n}", "ruby": "# @param {Integer} n\n# @param {Integer} k\n# @param {Integer} budget\n# @param {Integer[][]} composition\n# @param {Integer[]} stock\n# @param {Integer[]} cost\n# @return {Integer}\ndef max_number_of_alloys(n, k, budget, composition, stock, cost)\n    \nend", "scala": "object Solution {\n    def maxNumberOfAlloys(n: Int, k: Int, budget: Int, composition: List[List[Int]], stock: List[Int], cost: List[Int]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn max_number_of_alloys(n: i32, k: i32, budget: i32, composition: Vec<Vec<i32>>, stock: Vec<i32>, cost: Vec<i32>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (max-number-of-alloys n k budget composition stock cost)\n  (-> exact-integer? exact-integer? exact-integer? (listof (listof exact-integer?)) (listof exact-integer?) (listof exact-integer?) exact-integer?)\n\n  )", "erlang": "-spec max_number_of_alloys(N :: integer(), K :: integer(), Budget :: integer(), Composition :: [[integer()]], Stock :: [integer()], Cost :: [integer()]) -> integer().\nmax_number_of_alloys(N, K, Budget, Composition, Stock, Cost) ->\n  .", "elixir": "defmodule Solution do\n  @spec max_number_of_alloys(n :: integer, k :: integer, budget :: integer, composition :: [[integer]], stock :: [integer], cost :: [integer]) :: integer\n  def max_number_of_alloys(n, k, budget, composition, stock, cost) do\n\n  end\nend"}}
{"id": "leetcode_2772", "url": "https://leetcode.com/problems/apply-operations-to-make-all-array-elements-equal-to-zero/", "title": "Apply Operations to Make All Array Elements Equal to Zero", "description": "You are given a **0-indexed** integer array `nums` and a positive integer `k`.\n\n\nYou can apply the following operation on the array **any** number of times:\n\n\n* Choose **any** subarray of size `k` from the array and **decrease** all its elements by `1`.\n\n\nReturn `true` *if you can make all the array elements equal to* `0`*, or* `false` *otherwise*.\n\n\nA **subarray** is a contiguous non-empty part of an array.", "examples": ["**Input:** nums = [2,2,3,1,1,0], k = 3\n**Output:** true\n**Explanation:** We can do the following operations:\n- Choose the subarray [2,2,3]. The resulting array will be nums = [**1**,**1**,**2**,1,1,0].\n- Choose the subarray [2,1,1]. The resulting array will be nums = [1,1,**1**,**0**,**0**,0].\n- Choose the subarray [1,1,1]. The resulting array will be nums = [**0**,**0**,**0**,0,0,0].", "**Input:** nums = [1,3,1,1], k = 2\n**Output:** false\n**Explanation:** It is not possible to make all the array elements equal to 0."], "constraints": "**Constraints:**\n\n\n* `1 <= k <= nums.length <= 105`\n* `0 <= nums[i] <= 106`", "difficulty": "Medium", "tags": ["Array", "Prefix Sum"], "hints": ["In case it is possible, then how can you do the operations? which subarrays do you choose and in what order?", "The order of the chosen subarrays should be from the left to the right of the array"], "templates": {"cpp": "class Solution {\npublic:\n    bool checkArray(vector<int>& nums, int k) {\n        \n    }\n};", "java": "class Solution {\n    public boolean checkArray(int[] nums, int k) {\n        \n    }\n}", "python": "class Solution(object):\n    def checkArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        ", "python3": "class Solution:\n    def checkArray(self, nums: List[int], k: int) -> bool:\n        ", "c": "bool checkArray(int* nums, int numsSize, int k){\n\n}", "csharp": "public class Solution {\n    public bool CheckArray(int[] nums, int k) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {boolean}\n */\nvar checkArray = function(nums, k) {\n    \n};", "typescript": "function checkArray(nums: number[], k: number): boolean {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Boolean\n     */\n    function checkArray($nums, $k) {\n        \n    }\n}", "swift": "class Solution {\n    func checkArray(_ nums: [Int], _ k: Int) -> Bool {\n        \n    }\n}", "kotlin": "class Solution {\n    fun checkArray(nums: IntArray, k: Int): Boolean {\n        \n    }\n}", "dart": "class Solution {\n  bool checkArray(List<int> nums, int k) {\n\n  }\n}", "golang": "func checkArray(nums []int, k int) bool {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Boolean}\ndef check_array(nums, k)\n    \nend", "scala": "object Solution {\n    def checkArray(nums: Array[Int], k: Int): Boolean = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn check_array(nums: Vec<i32>, k: i32) -> bool {\n        \n    }\n}", "racket": "(define/contract (check-array nums k)\n  (-> (listof exact-integer?) exact-integer? boolean?)\n\n  )", "erlang": "-spec check_array(Nums :: [integer()], K :: integer()) -> boolean().\ncheck_array(Nums, K) ->\n  .", "elixir": "defmodule Solution do\n  @spec check_array(nums :: [integer], k :: integer) :: boolean\n  def check_array(nums, k) do\n\n  end\nend"}}
{"id": "leetcode_2787", "url": "https://leetcode.com/problems/ways-to-express-an-integer-as-sum-of-powers/", "title": "Ways to Express an Integer as Sum of Powers", "description": "Given two **positive** integers `n` and `x`.\n\n\nReturn *the number of ways* `n` *can be expressed as the sum of the* `xth` *power of **unique** positive integers, in other words, the number of sets of unique integers* `[n1, n2, ..., nk]` *where* `n = n1x + n2x + ... + nkx`*.*\n\n\nSince the result can be very large, return it modulo `109 + 7`.\n\n\nFor example, if `n = 160` and `x = 3`, one way to express `n` is `n = 23 + 33 + 53`.", "examples": ["**Input:** n = 10, x = 2\n**Output:** 1\n**Explanation:** We can express n as the following: n = 32 + 12 = 10.\nIt can be shown that it is the only way to express 10 as the sum of the 2nd power of unique integers.", "**Input:** n = 4, x = 1\n**Output:** 2\n**Explanation:** We can express n in the following ways:\n- n = 41 = 4.\n- n = 31 + 11 = 4."], "constraints": "**Constraints:**\n\n\n* `1 <= n <= 300`\n* `1 <= x <= 5`", "difficulty": "Medium", "tags": ["Dynamic Programming"], "hints": ["You can use dynamic programming, where dp[k][j] represents the number of ways to express k as the sum of the x-th power of unique positive integers such that the biggest possible number we use is j.", "To calculate dp[k][j], you can iterate over the numbers smaller than j and try to use each one as a power of x to make our sum k."], "templates": {"cpp": "class Solution {\npublic:\n    int numberOfWays(int n, int x) {\n        \n    }\n};", "java": "class Solution {\n    public int numberOfWays(int n, int x) {\n        \n    }\n}", "python": "class Solution(object):\n    def numberOfWays(self, n, x):\n        \"\"\"\n        :type n: int\n        :type x: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def numberOfWays(self, n: int, x: int) -> int:\n        ", "c": "int numberOfWays(int n, int x){\n\n}", "csharp": "public class Solution {\n    public int NumberOfWays(int n, int x) {\n        \n    }\n}", "javascript": "/**\n * @param {number} n\n * @param {number} x\n * @return {number}\n */\nvar numberOfWays = function(n, x) {\n    \n};", "typescript": "function numberOfWays(n: number, x: number): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer $x\n     * @return Integer\n     */\n    function numberOfWays($n, $x) {\n        \n    }\n}", "swift": "class Solution {\n    func numberOfWays(_ n: Int, _ x: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun numberOfWays(n: Int, x: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int numberOfWays(int n, int x) {\n\n  }\n}", "golang": "func numberOfWays(n int, x int) int {\n    \n}", "ruby": "# @param {Integer} n\n# @param {Integer} x\n# @return {Integer}\ndef number_of_ways(n, x)\n    \nend", "scala": "object Solution {\n    def numberOfWays(n: Int, x: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn number_of_ways(n: i32, x: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (number-of-ways n x)\n  (-> exact-integer? exact-integer? exact-integer?)\n\n  )", "erlang": "-spec number_of_ways(N :: integer(), X :: integer()) -> integer().\nnumber_of_ways(N, X) ->\n  .", "elixir": "defmodule Solution do\n  @spec number_of_ways(n :: integer, x :: integer) :: integer\n  def number_of_ways(n, x) do\n\n  end\nend"}}
{"id": "leetcode_2857", "url": "https://leetcode.com/problems/count-pairs-of-points-with-distance-k/", "title": "Count Pairs of Points With Distance k", "description": "You are given a **2D** integer array `coordinates` and an integer `k`, where `coordinates[i] = [xi, yi]` are the coordinates of the `ith` point in a 2D plane.\n\n\nWe define the **distance** between two points `(x1, y1)` and `(x2, y2)` as `(x1 XOR x2) + (y1 XOR y2)` where `XOR` is the bitwise `XOR` operation.\n\n\nReturn *the number of pairs* `(i, j)` *such that* `i < j` *and the distance between points* `i` *and* `j` *is equal to* `k`.", "examples": ["**Input:** coordinates = [[1,2],[4,2],[1,3],[5,2]], k = 5\n**Output:** 2\n**Explanation:** We can choose the following pairs:\n- (0,1): Because we have (1 XOR 4) + (2 XOR 2) = 5.\n- (2,3): Because we have (1 XOR 5) + (3 XOR 2) = 5.", "**Input:** coordinates = [[1,3],[1,3],[1,3],[1,3],[1,3]], k = 0\n**Output:** 10\n**Explanation:** Any two chosen pairs will have a distance of 0. There are 10 ways to choose two pairs."], "constraints": "**Constraints:**\n\n\n* `2 <= coordinates.length <= 50000`\n* `0 <= xi, yi <= 106`\n* `0 <= k <= 100`", "difficulty": "Medium", "tags": ["Array", "Hash Table", "Bit Manipulation"], "hints": ["<div class=\"_1l1MA\">Suppose that <code>x = x<sub>1</sub> XOR x<sub>2</sub></code> and y = y<sub>1</sub> XOR y<sub>2</sub> then we can get <code>x<sub>2</sub> = x XOR x<sub>1</sub></code> and <code>y<sub>2</sub> = y XOR y<sub>1</sub></code>.</div>", "<div class=\"_1l1MA\">We are supposed to have\u00a0k = x + y so we can get\u00a0<code>x<sub>2</sub> = x XOR x<sub>1</sub></code>\u00a0and\u00a0<code>y<sub>2</sub> = (k - x)\u00a0XOR y<sub>1</sub></code>.</div>", "<div class=\"_1l1MA\">We can iterate over all possible values of <code>x</code> and count the number of points\u00a0<code>(x<sub>1</sub>, x<sub>2</sub>)</code> and <code>(x<sub>2</sub>, y<sub>2</sub>)</code>.</div>"], "templates": {"cpp": "class Solution {\npublic:\n    int countPairs(vector<vector<int>>& coordinates, int k) {\n        \n    }\n};", "java": "class Solution {\n    public int countPairs(List<List<Integer>> coordinates, int k) {\n        \n    }\n}", "python": "class Solution(object):\n    def countPairs(self, coordinates, k):\n        \"\"\"\n        :type coordinates: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def countPairs(self, coordinates: List[List[int]], k: int) -> int:\n        ", "c": "int countPairs(int** coordinates, int coordinatesSize, int* coordinatesColSize, int k){\n\n}", "csharp": "public class Solution {\n    public int CountPairs(IList<IList<int>> coordinates, int k) {\n        \n    }\n}", "javascript": "/**\n * @param {number[][]} coordinates\n * @param {number} k\n * @return {number}\n */\nvar countPairs = function(coordinates, k) {\n    \n};", "typescript": "function countPairs(coordinates: number[][], k: number): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[][] $coordinates\n     * @param Integer $k\n     * @return Integer\n     */\n    function countPairs($coordinates, $k) {\n        \n    }\n}", "swift": "class Solution {\n    func countPairs(_ coordinates: [[Int]], _ k: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun countPairs(coordinates: List<List<Int>>, k: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int countPairs(List<List<int>> coordinates, int k) {\n\n  }\n}", "golang": "func countPairs(coordinates [][]int, k int) int {\n    \n}", "ruby": "# @param {Integer[][]} coordinates\n# @param {Integer} k\n# @return {Integer}\ndef count_pairs(coordinates, k)\n    \nend", "scala": "object Solution {\n    def countPairs(coordinates: List[List[Int]], k: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn count_pairs(coordinates: Vec<Vec<i32>>, k: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (count-pairs coordinates k)\n  (-> (listof (listof exact-integer?)) exact-integer? exact-integer?)\n\n  )", "erlang": "-spec count_pairs(Coordinates :: [[integer()]], K :: integer()) -> integer().\ncount_pairs(Coordinates, K) ->\n  .", "elixir": "defmodule Solution do\n  @spec count_pairs(coordinates :: [[integer]], k :: integer) :: integer\n  def count_pairs(coordinates, k) do\n\n  end\nend"}}
{"id": "leetcode_2800", "url": "https://leetcode.com/problems/shortest-string-that-contains-three-strings/", "title": "Shortest String That Contains Three Strings", "description": "Given three strings `a`, `b`, and `c`, your task is to find a string that has the **minimum** length and contains all three strings as **substrings**.\nIf there are multiple such strings, return the**lexicographicallysmallest** one.\n\n\nReturn *a string denoting the answer to the problem.*\n\n\n**Notes**\n\n\n* A string `a` is **lexicographically smaller** than a string `b` (of the same length) if in the first position where `a` and `b` differ, string `a` has a letter that appears **earlier** in the alphabet than the corresponding letter in `b`.\n* A **substring** is a contiguous sequence of characters within a string.", "examples": ["**Input:** a = \"abc\", b = \"bca\", c = \"aaa\"\n**Output:** \"aaabca\"\n**Explanation:**  We show that \"aaabca\" contains all the given strings: a = ans[2...4], b = ans[3..5], c = ans[0..2]. It can be shown that the length of the resulting string would be at least 6 and \"aaabca\" is the lexicographically smallest one.", "**Input:** a = \"ab\", b = \"ba\", c = \"aba\"\n**Output:** \"aba\"\n**Explanation:** We show that the string \"aba\" contains all the given strings: a = ans[0..1], b = ans[1..2], c = ans[0..2]. Since the length of c is 3, the length of the resulting string would be at least 3. It can be shown that \"aba\" is the lexicographically smallest one."], "constraints": "**Constraints:**\n\n\n* `1 <= a.length, b.length, c.length <= 100`\n* `a`, `b`, `c` consist only of lowercase English letters.", "difficulty": "Medium", "tags": ["String", "Greedy", "Enumeration"], "hints": ["Think about how you can generate all possible strings that contain all three input strings as substrings. Can you come up with an efficient algorithm to do this?", "Check all permutations of the words a, b, and c. For each permutation, begin by appending some letters to the end of the first word to form the second word. Then, proceed to add more letters to generate the third word."], "templates": {"cpp": "class Solution {\npublic:\n    string minimumString(string a, string b, string c) {\n        \n    }\n};", "java": "class Solution {\n    public String minimumString(String a, String b, String c) {\n        \n    }\n}", "python": "class Solution(object):\n    def minimumString(self, a, b, c):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :type c: str\n        :rtype: str\n        \"\"\"\n        ", "python3": "class Solution:\n    def minimumString(self, a: str, b: str, c: str) -> str:\n        ", "c": "char * minimumString(char * a, char * b, char * c){\n\n}", "csharp": "public class Solution {\n    public string MinimumString(string a, string b, string c) {\n        \n    }\n}", "javascript": "/**\n * @param {string} a\n * @param {string} b\n * @param {string} c\n * @return {string}\n */\nvar minimumString = function(a, b, c) {\n    \n};", "typescript": "function minimumString(a: string, b: string, c: string): string {\n\n};", "php": "class Solution {\n\n    /**\n     * @param String $a\n     * @param String $b\n     * @param String $c\n     * @return String\n     */\n    function minimumString($a, $b, $c) {\n        \n    }\n}", "swift": "class Solution {\n    func minimumString(_ a: String, _ b: String, _ c: String) -> String {\n        \n    }\n}", "kotlin": "class Solution {\n    fun minimumString(a: String, b: String, c: String): String {\n        \n    }\n}", "dart": "class Solution {\n  String minimumString(String a, String b, String c) {\n\n  }\n}", "golang": "func minimumString(a string, b string, c string) string {\n    \n}", "ruby": "# @param {String} a\n# @param {String} b\n# @param {String} c\n# @return {String}\ndef minimum_string(a, b, c)\n    \nend", "scala": "object Solution {\n    def minimumString(a: String, b: String, c: String): String = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn minimum_string(a: String, b: String, c: String) -> String {\n        \n    }\n}", "racket": "(define/contract (minimum-string a b c)\n  (-> string? string? string? string?)\n\n  )", "erlang": "-spec minimum_string(A :: unicode:unicode_binary(), B :: unicode:unicode_binary(), C :: unicode:unicode_binary()) -> unicode:unicode_binary().\nminimum_string(A, B, C) ->\n  .", "elixir": "defmodule Solution do\n  @spec minimum_string(a :: String.t, b :: String.t, c :: String.t) :: String.t\n  def minimum_string(a, b, c) do\n\n  end\nend"}}
{"id": "leetcode_2683", "url": "https://leetcode.com/problems/neighboring-bitwise-xor/", "title": "Neighboring Bitwise XOR", "description": "A **0-indexed** array `derived` with length `n` is derived by computing the **bitwise XOR**\u00a0(\u2295) of adjacent values in a **binary array** `original` of length `n`.\n\n\nSpecifically, for each index `i` in the range `[0, n - 1]`:\n\n\n* If `i = n - 1`, then `derived[i] = original[i] \u2295 original[0]`.\n* Otherwise, `derived[i] = original[i] \u2295 original[i + 1]`.\n\n\nGiven an array `derived`, your task is to determine whether there exists a **valid binary array** `original` that could have formed `derived`.\n\n\nReturn ***true** if such an array exists or **false** otherwise.*\n\n\n* A binary array is an array containing only **0's** and **1's**", "examples": ["**Input:** derived = [1,1,0]\n**Output:** true\n**Explanation:** A valid original array that gives derived is [0,1,0].\nderived[0] = original[0] \u2295 original[1] = 0 \u2295 1 = 1 \nderived[1] = original[1] \u2295 original[2] = 1 \u2295 0 = 1\nderived[2] = original[2] \u2295 original[0] = 0 \u2295 0 = 0", "**Input:** derived = [1,1]\n**Output:** true\n**Explanation:** A valid original array that gives derived is [0,1].\nderived[0] = original[0] \u2295 original[1] = 1\nderived[1] = original[1] \u2295 original[0] = 1", "**Input:** derived = [1,0]\n**Output:** false\n**Explanation:** There is no valid original array that gives derived."], "constraints": "**Constraints:**\n\n\n* `n == derived.length`\n* `1 <= n\u00a0<= 105`\n* The values in `derived`\u00a0are either **0's** or **1's**", "difficulty": "Medium", "tags": ["Array", "Bit Manipulation"], "hints": ["Understand that from the original element, we are using each element twice to construct the derived array", "The xor-sum of the derived array should be 0 since there is always a duplicate occurrence of each element."], "templates": {"cpp": "class Solution {\npublic:\n    bool doesValidArrayExist(vector<int>& derived) {\n        \n    }\n};", "java": "class Solution {\n    public boolean doesValidArrayExist(int[] derived) {\n        \n    }\n}", "python": "class Solution(object):\n    def doesValidArrayExist(self, derived):\n        \"\"\"\n        :type derived: List[int]\n        :rtype: bool\n        \"\"\"\n        ", "python3": "class Solution:\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\n        ", "c": "bool doesValidArrayExist(int* derived, int derivedSize){\n\n}", "csharp": "public class Solution {\n    public bool DoesValidArrayExist(int[] derived) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} derived\n * @return {boolean}\n */\nvar doesValidArrayExist = function(derived) {\n    \n};", "typescript": "function doesValidArrayExist(derived: number[]): boolean {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $derived\n     * @return Boolean\n     */\n    function doesValidArrayExist($derived) {\n        \n    }\n}", "swift": "class Solution {\n    func doesValidArrayExist(_ derived: [Int]) -> Bool {\n        \n    }\n}", "kotlin": "class Solution {\n    fun doesValidArrayExist(derived: IntArray): Boolean {\n        \n    }\n}", "dart": "class Solution {\n  bool doesValidArrayExist(List<int> derived) {\n\n  }\n}", "golang": "func doesValidArrayExist(derived []int) bool {\n    \n}", "ruby": "# @param {Integer[]} derived\n# @return {Boolean}\ndef does_valid_array_exist(derived)\n    \nend", "scala": "object Solution {\n    def doesValidArrayExist(derived: Array[Int]): Boolean = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn does_valid_array_exist(derived: Vec<i32>) -> bool {\n        \n    }\n}", "racket": "(define/contract (does-valid-array-exist derived)\n  (-> (listof exact-integer?) boolean?)\n\n  )", "erlang": "-spec does_valid_array_exist(Derived :: [integer()]) -> boolean().\ndoes_valid_array_exist(Derived) ->\n  .", "elixir": "defmodule Solution do\n  @spec does_valid_array_exist(derived :: [integer]) :: boolean\n  def does_valid_array_exist(derived) do\n\n  end\nend"}}
{"id": "leetcode_2841", "url": "https://leetcode.com/problems/maximum-sum-of-almost-unique-subarray/", "title": "Maximum Sum of Almost Unique Subarray", "description": "You are given an integer array `nums` and two positive integers `m` and `k`.\n\n\nReturn *the **maximum sum** out of all **almost unique** subarrays of length* `k` *of* `nums`. If no such subarray exists, return `0`.\n\n\nA subarray of `nums` is **almost unique** if it contains at least `m` distinct elements.\n\n\nA subarray is a contiguous **non-empty** sequence of elements within an array.", "examples": ["**Input:** nums = [2,6,7,3,1,7], m = 3, k = 4\n**Output:** 18\n**Explanation:** There are 3 almost unique subarrays of size k = 4. These subarrays are [2, 6, 7, 3], [6, 7, 3, 1], and [7, 3, 1, 7]. Among these subarrays, the one with the maximum sum is [2, 6, 7, 3] which has a sum of 18.", "**Input:** nums = [5,9,9,2,4,5,4], m = 1, k = 3\n**Output:** 23\n**Explanation:** There are 5 almost unique subarrays of size k. These subarrays are [5, 9, 9], [9, 9, 2], [9, 2, 4], [2, 4, 5], and [4, 5, 4]. Among these subarrays, the one with the maximum sum is [5, 9, 9] which has a sum of 23.", "**Input:** nums = [1,2,1,2,1,2,1], m = 3, k = 3\n**Output:** 0\n**Explanation:** There are no subarrays of size k = 3 that contain at least m = 3 distinct elements in the given array [1,2,1,2,1,2,1]. Therefore, no almost unique subarrays exist, and the maximum sum is 0."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 2 * 104`\n* `1 <= m <= k <= nums.length`\n* `1 <= nums[i] <= 109`", "difficulty": "Medium", "tags": ["Array", "Hash Table", "Sliding Window"], "hints": ["Use a set or map to keep track of the number of distinct elements.", "Use 2-pointers to maintain the size, the number of unique elements, and the sum of all the elements in all subarrays of size k from left to right dynamically.****"], "templates": {"cpp": "class Solution {\npublic:\n    long long maxSum(vector<int>& nums, int m, int k) {\n        \n    }\n};", "java": "class Solution {\n    public long maxSum(List<Integer> nums, int m, int k) {\n        \n    }\n}", "python": "class Solution(object):\n    def maxSum(self, nums, m, k):\n        \"\"\"\n        :type nums: List[int]\n        :type m: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def maxSum(self, nums: List[int], m: int, k: int) -> int:\n        ", "c": "long long maxSum(int* nums, int numsSize, int m, int k){\n\n}", "csharp": "public class Solution {\n    public long MaxSum(IList<int> nums, int m, int k) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @param {number} m\n * @param {number} k\n * @return {number}\n */\nvar maxSum = function(nums, m, k) {\n    \n};", "typescript": "function maxSum(nums: number[], m: number, k: number): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $m\n     * @param Integer $k\n     * @return Integer\n     */\n    function maxSum($nums, $m, $k) {\n        \n    }\n}", "swift": "class Solution {\n    func maxSum(_ nums: [Int], _ m: Int, _ k: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun maxSum(nums: List<Int>, m: Int, k: Int): Long {\n        \n    }\n}", "dart": "class Solution {\n  int maxSum(List<int> nums, int m, int k) {\n\n  }\n}", "golang": "func maxSum(nums []int, m int, k int) int64 {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @param {Integer} m\n# @param {Integer} k\n# @return {Integer}\ndef max_sum(nums, m, k)\n    \nend", "scala": "object Solution {\n    def maxSum(nums: List[Int], m: Int, k: Int): Long = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn max_sum(nums: Vec<i32>, m: i32, k: i32) -> i64 {\n        \n    }\n}", "racket": "(define/contract (max-sum nums m k)\n  (-> (listof exact-integer?) exact-integer? exact-integer? exact-integer?)\n\n  )", "erlang": "-spec max_sum(Nums :: [integer()], M :: integer(), K :: integer()) -> integer().\nmax_sum(Nums, M, K) ->\n  .", "elixir": "defmodule Solution do\n  @spec max_sum(nums :: [integer], m :: integer, k :: integer) :: integer\n  def max_sum(nums, m, k) do\n\n  end\nend"}}
{"id": "leetcode_2904", "url": "https://leetcode.com/problems/shortest-and-lexicographically-smallest-beautiful-string/", "title": "Shortest and Lexicographically Smallest Beautiful String", "description": "You are given a binary string `s` and a positive integer `k`.\n\n\nA substring of `s` is **beautiful** if the number of `1`'s in it is exactly `k`.\n\n\nLet `len` be the length of the **shortest** beautiful substring.\n\n\nReturn *the lexicographically **smallest** beautiful substring of string* `s` *with length equal to* `len`. If `s` doesn't contain a beautiful substring, return *an **empty** string*.\n\n\nA string `a` is lexicographically **larger** than a string `b` (of the same length) if in the first position where `a` and `b` differ, `a` has a character strictly larger than the corresponding character in `b`.\n\n\n* For example, `\"abcd\"` is lexicographically larger than `\"abcc\"` because the first position they differ is at the fourth character, and `d` is greater than `c`.", "examples": ["**Input:** s = \"100011001\", k = 3\n**Output:** \"11001\"\n**Explanation:** There are 7 beautiful substrings in this example:\n1. The substring \"100011001\".\n2. The substring \"100011001\".\n3. The substring \"100011001\".\n4. The substring \"100011001\".\n5. The substring \"100011001\".\n6. The substring \"100011001\".\n7. The substring \"100011001\".\nThe length of the shortest beautiful substring is 5.\nThe lexicographically smallest beautiful substring with length 5 is the substring \"11001\".", "**Input:** s = \"1011\", k = 2\n**Output:** \"11\"\n**Explanation:** There are 3 beautiful substrings in this example:\n1. The substring \"1011\".\n2. The substring \"1011\".\n3. The substring \"1011\".\nThe length of the shortest beautiful substring is 2.\nThe lexicographically smallest beautiful substring with length 2 is the substring \"11\".", "**Input:** s = \"000\", k = 1\n**Output:** \"\"\n**Explanation:** There are no beautiful substrings in this example."], "constraints": "**Constraints:**\n\n\n* `1 <= s.length <= 100`\n* `1 <= k <= s.length`", "difficulty": "Medium", "tags": ["String", "Sliding Window"], "hints": ["Notice that if we consider that index <code>i</code> is the leftmost index of a beautiful substring, it has only one candidate <code>j</code>, such that <code>s[i:j]</code> is beautiful and shortest too.", "We can iterate over all possibilities of leftmost index <code>i</code> take <code>s[i:j]</code> and compare with the shortest and the lexicographically smallest beautiful string we could get before index <code>i</code>."], "templates": {"cpp": "class Solution {\npublic:\n    string shortestBeautifulSubstring(string s, int k) {\n        \n    }\n};", "java": "class Solution {\n    public String shortestBeautifulSubstring(String s, int k) {\n        \n    }\n}", "python": "class Solution(object):\n    def shortestBeautifulSubstring(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        ", "python3": "class Solution:\n    def shortestBeautifulSubstring(self, s: str, k: int) -> str:\n        ", "c": "char* shortestBeautifulSubstring(char* s, int k){\n\n}", "csharp": "public class Solution {\n    public string ShortestBeautifulSubstring(string s, int k) {\n        \n    }\n}", "javascript": "/**\n * @param {string} s\n * @param {number} k\n * @return {string}\n */\nvar shortestBeautifulSubstring = function(s, k) {\n    \n};", "typescript": "function shortestBeautifulSubstring(s: string, k: number): string {\n\n};", "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @param Integer $k\n     * @return String\n     */\n    function shortestBeautifulSubstring($s, $k) {\n        \n    }\n}", "swift": "class Solution {\n    func shortestBeautifulSubstring(_ s: String, _ k: Int) -> String {\n        \n    }\n}", "kotlin": "class Solution {\n    fun shortestBeautifulSubstring(s: String, k: Int): String {\n        \n    }\n}", "dart": "class Solution {\n  String shortestBeautifulSubstring(String s, int k) {\n\n  }\n}", "golang": "func shortestBeautifulSubstring(s string, k int) string {\n    \n}", "ruby": "# @param {String} s\n# @param {Integer} k\n# @return {String}\ndef shortest_beautiful_substring(s, k)\n    \nend", "scala": "object Solution {\n    def shortestBeautifulSubstring(s: String, k: Int): String = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn shortest_beautiful_substring(s: String, k: i32) -> String {\n        \n    }\n}", "racket": "(define/contract (shortest-beautiful-substring s k)\n  (-> string? exact-integer? string?)\n\n  )", "erlang": "-spec shortest_beautiful_substring(S :: unicode:unicode_binary(), K :: integer()) -> unicode:unicode_binary().\nshortest_beautiful_substring(S, K) ->\n  .", "elixir": "defmodule Solution do\n  @spec shortest_beautiful_substring(s :: String.t, k :: integer) :: String.t\n  def shortest_beautiful_substring(s, k) do\n\n  end\nend"}}
{"id": "leetcode_2958", "url": "https://leetcode.com/problems/length-of-longest-subarray-with-at-most-k-frequency/", "title": "Length of Longest Subarray With at Most K Frequency", "description": "You are given an integer array `nums` and an integer `k`.\n\n\nThe **frequency** of an element `x` is the number of times it occurs in an array.\n\n\nAn array is called **good** if the frequency of each element in this array is **less than or equal** to `k`.\n\n\nReturn *the length of the **longest** **good** subarray of* `nums`*.*\n\n\nA **subarray** is a contiguous non-empty sequence of elements within an array.", "examples": ["**Input:** nums = [1,2,3,1,2,3,1,2], k = 2\n**Output:** 6\n**Explanation:** The longest possible good subarray is [1,2,3,1,2,3] since the values 1, 2, and 3 occur at most twice in this subarray. Note that the subarrays [2,3,1,2,3,1] and [3,1,2,3,1,2] are also good.\nIt can be shown that there are no good subarrays with length more than 6.", "**Input:** nums = [1,2,1,2,1,2,1,2], k = 1\n**Output:** 2\n**Explanation:** The longest possible good subarray is [1,2] since the values 1 and 2 occur at most once in this subarray. Note that the subarray [2,1] is also good.\nIt can be shown that there are no good subarrays with length more than 2.", "**Input:** nums = [5,5,5,5,5,5,5], k = 4\n**Output:** 4\n**Explanation:** The longest possible good subarray is [5,5,5,5] since the value 5 occurs 4 times in this subarray.\nIt can be shown that there are no good subarrays with length more than 4."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `1 <= nums[i] <= 109`\n* `1 <= k <= nums.length`", "difficulty": "Medium", "tags": ["Array", "Hash Table", "Sliding Window"], "hints": ["For each index <code>i</code>, find the rightmost index <code>j >= i</code> such that the frequency of each element in the subarray <code>[i, j]</code> is at most <code>k</code>.", "We can use 2 pointers / sliding window to achieve it."], "templates": {"cpp": "class Solution {\npublic:\n    int maxSubarrayLength(vector<int>& nums, int k) {\n        \n    }\n};", "java": "class Solution {\n    public int maxSubarrayLength(int[] nums, int k) {\n        \n    }\n}", "python": "class Solution(object):\n    def maxSubarrayLength(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def maxSubarrayLength(self, nums: List[int], k: int) -> int:\n        ", "c": "int maxSubarrayLength(int* nums, int numsSize, int k) {\n    \n}", "csharp": "public class Solution {\n    public int MaxSubarrayLength(int[] nums, int k) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maxSubarrayLength = function(nums, k) {\n    \n};", "typescript": "function maxSubarrayLength(nums: number[], k: number): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer\n     */\n    function maxSubarrayLength($nums, $k) {\n        \n    }\n}", "swift": "class Solution {\n    func maxSubarrayLength(_ nums: [Int], _ k: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun maxSubarrayLength(nums: IntArray, k: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int maxSubarrayLength(List<int> nums, int k) {\n    \n  }\n}", "golang": "func maxSubarrayLength(nums []int, k int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer}\ndef max_subarray_length(nums, k)\n    \nend", "scala": "object Solution {\n    def maxSubarrayLength(nums: Array[Int], k: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn max_subarray_length(nums: Vec<i32>, k: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (max-subarray-length nums k)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )", "erlang": "-spec max_subarray_length(Nums :: [integer()], K :: integer()) -> integer().\nmax_subarray_length(Nums, K) ->\n  .", "elixir": "defmodule Solution do\n  @spec max_subarray_length(nums :: [integer], k :: integer) :: integer\n  def max_subarray_length(nums, k) do\n    \n  end\nend"}}
{"id": "leetcode_2734", "url": "https://leetcode.com/problems/lexicographically-smallest-string-after-substring-operation/", "title": "Lexicographically Smallest String After Substring Operation", "description": "You are given a string `s` consisting of only lowercase English letters. In one operation, you can do the following:\n\n\n* Select any non-empty substring of `s`, possibly the entire string, then replace each one of its characters with the previous character of the English alphabet. For example, 'b' is converted to 'a', and 'a' is converted to 'z'.\n\n\nReturn *the **lexicographically smallest** string you can obtain after performing the above operation **exactly once**.*\n\n\nA **substring** is a contiguous sequence of characters in a string.\n\n\nA string `x` is **lexicographically smaller** than a string `y` of the same length if `x[i]` comes before `y[i]` in alphabetic order for the first position `i` such that `x[i] != y[i]`.", "examples": ["**Input:** s = \"cbabc\"\n**Output:** \"baabc\"\n**Explanation:** We apply the operation on the substring starting at index 0, and ending at index 1 inclusive. \nIt can be proven that the resulting string is the lexicographically smallest.", "**Input:** s = \"acbbc\"\n**Output:** \"abaab\"\n**Explanation:** We apply the operation on the substring starting at index 1, and ending at index 4 inclusive. \nIt can be proven that the resulting string is the lexicographically smallest.", "**Input:** s = \"leetcode\"\n**Output:** \"kddsbncd\"\n**Explanation:** We apply the operation on the entire string. \nIt can be proven that the resulting string is the lexicographically smallest."], "constraints": "**Constraints:**\n\n\n* `1 <= s.length <= 3 * 105`\n* `s` consists of lowercase English letters", "difficulty": "Medium", "tags": ["String", "Greedy"], "hints": ["When a character is replaced by the one that comes before it on the alphabet, it makes the string lexicographically smaller, except for \u2018a'.", "Find the leftmost substring that doesn\u2019t contain the character 'a' and change all characters in it."], "templates": {"cpp": "class Solution {\npublic:\n    string smallestString(string s) {\n        \n    }\n};", "java": "class Solution {\n    public String smallestString(String s) {\n        \n    }\n}", "python": "class Solution(object):\n    def smallestString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        ", "python3": "class Solution:\n    def smallestString(self, s: str) -> str:\n        ", "c": "char * smallestString(char * s){\n\n}", "csharp": "public class Solution {\n    public string SmallestString(string s) {\n        \n    }\n}", "javascript": "/**\n * @param {string} s\n * @return {string}\n */\nvar smallestString = function(s) {\n    \n};", "typescript": "function smallestString(s: string): string {\n\n};", "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @return String\n     */\n    function smallestString($s) {\n        \n    }\n}", "swift": "class Solution {\n    func smallestString(_ s: String) -> String {\n        \n    }\n}", "kotlin": "class Solution {\n    fun smallestString(s: String): String {\n        \n    }\n}", "dart": "class Solution {\n  String smallestString(String s) {\n\n  }\n}", "golang": "func smallestString(s string) string {\n    \n}", "ruby": "# @param {String} s\n# @return {String}\ndef smallest_string(s)\n    \nend", "scala": "object Solution {\n    def smallestString(s: String): String = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn smallest_string(s: String) -> String {\n        \n    }\n}", "racket": "(define/contract (smallest-string s)\n  (-> string? string?)\n\n  )", "erlang": "-spec smallest_string(S :: unicode:unicode_binary()) -> unicode:unicode_binary().\nsmallest_string(S) ->\n  .", "elixir": "defmodule Solution do\n  @spec smallest_string(s :: String.t) :: String.t\n  def smallest_string(s) do\n\n  end\nend"}}
{"id": "leetcode_2671", "url": "https://leetcode.com/problems/frequency-tracker/", "title": "Frequency Tracker", "description": "Design a data structure that keeps track of the values in it and answers some queries regarding their frequencies.\n\n\nImplement the `FrequencyTracker` class.\n\n\n* `FrequencyTracker()`: Initializes the `FrequencyTracker` object with an empty array initially.\n* `void add(int number)`: Adds `number` to the data structure.\n* `void deleteOne(int number)`: Deletes **one** occurrence of `number` from the data structure. The data structure **may not contain** `number`, and in this case nothing is deleted.\n* `bool hasFrequency(int frequency)`: Returns `true` if there is a number in the data structure that occurs `frequency` number of times, otherwise, it returns `false`.", "examples": ["**Input**\n[\"FrequencyTracker\", \"add\", \"add\", \"hasFrequency\"]\n[[], [3], [3], [2]]\n**Output**\n[null, null, null, true]\n\n**Explanation**\nFrequencyTracker frequencyTracker = new FrequencyTracker();\nfrequencyTracker.add(3); // The data structure now contains [3]\nfrequencyTracker.add(3); // The data structure now contains [3, 3]\nfrequencyTracker.hasFrequency(2); // Returns true, because 3 occurs twice", "**Input**\n[\"FrequencyTracker\", \"add\", \"deleteOne\", \"hasFrequency\"]\n[[], [1], [1], [1]]\n**Output**\n[null, null, null, false]\n\n**Explanation**\nFrequencyTracker frequencyTracker = new FrequencyTracker();\nfrequencyTracker.add(1); // The data structure now contains [1]\nfrequencyTracker.deleteOne(1); // The data structure becomes empty []\nfrequencyTracker.hasFrequency(1); // Returns false, because the data structure is empty", "**Input**\n[\"FrequencyTracker\", \"hasFrequency\", \"add\", \"hasFrequency\"]\n[[], [2], [3], [1]]\n**Output**\n[null, false, null, true]\n\n**Explanation**\nFrequencyTracker frequencyTracker = new FrequencyTracker();\nfrequencyTracker.hasFrequency(2); // Returns false, because the data structure is empty\nfrequencyTracker.add(3); // The data structure now contains [3]\nfrequencyTracker.hasFrequency(1); // Returns true, because 3 occurs once"], "constraints": "**Constraints:**\n\n\n* `1 <= number <= 105`\n* `1 <= frequency <= 105`\n* At most, `2 *\u00a0105`\u00a0calls will be made to `add`, `deleteOne`, and `hasFrequency`\u00a0in **total**.", "difficulty": "Medium", "tags": ["Hash Table", "Design"], "hints": ["Put all the numbers in a hash map (or just an integer array given the number range is small) to maintain each number\u2019s frequency dynamically.", "Put each frequency in another hash map (or just an integer array given the range is small, note there are only 200000 calls in total) to maintain each kind of frequency dynamically.", "Keep the 2 hash maps in sync."], "templates": {"cpp": "class FrequencyTracker {\npublic:\n    FrequencyTracker() {\n        \n    }\n    \n    void add(int number) {\n        \n    }\n    \n    void deleteOne(int number) {\n        \n    }\n    \n    bool hasFrequency(int frequency) {\n        \n    }\n};\n\n/**\n * Your FrequencyTracker object will be instantiated and called as such:\n * FrequencyTracker* obj = new FrequencyTracker();\n * obj->add(number);\n * obj->deleteOne(number);\n * bool param_3 = obj->hasFrequency(frequency);\n */", "java": "class FrequencyTracker {\n\n    public FrequencyTracker() {\n        \n    }\n    \n    public void add(int number) {\n        \n    }\n    \n    public void deleteOne(int number) {\n        \n    }\n    \n    public boolean hasFrequency(int frequency) {\n        \n    }\n}\n\n/**\n * Your FrequencyTracker object will be instantiated and called as such:\n * FrequencyTracker obj = new FrequencyTracker();\n * obj.add(number);\n * obj.deleteOne(number);\n * boolean param_3 = obj.hasFrequency(frequency);\n */", "python": "class FrequencyTracker(object):\n\n    def __init__(self):\n        \n\n    def add(self, number):\n        \"\"\"\n        :type number: int\n        :rtype: None\n        \"\"\"\n        \n\n    def deleteOne(self, number):\n        \"\"\"\n        :type number: int\n        :rtype: None\n        \"\"\"\n        \n\n    def hasFrequency(self, frequency):\n        \"\"\"\n        :type frequency: int\n        :rtype: bool\n        \"\"\"\n        \n\n\n# Your FrequencyTracker object will be instantiated and called as such:\n# obj = FrequencyTracker()\n# obj.add(number)\n# obj.deleteOne(number)\n# param_3 = obj.hasFrequency(frequency)", "python3": "class FrequencyTracker:\n\n    def __init__(self):\n        \n\n    def add(self, number: int) -> None:\n        \n\n    def deleteOne(self, number: int) -> None:\n        \n\n    def hasFrequency(self, frequency: int) -> bool:\n        \n\n\n# Your FrequencyTracker object will be instantiated and called as such:\n# obj = FrequencyTracker()\n# obj.add(number)\n# obj.deleteOne(number)\n# param_3 = obj.hasFrequency(frequency)", "c": "\n\n\ntypedef struct {\n    \n} FrequencyTracker;\n\n\nFrequencyTracker* frequencyTrackerCreate() {\n    \n}\n\nvoid frequencyTrackerAdd(FrequencyTracker* obj, int number) {\n  \n}\n\nvoid frequencyTrackerDeleteOne(FrequencyTracker* obj, int number) {\n  \n}\n\nbool frequencyTrackerHasFrequency(FrequencyTracker* obj, int frequency) {\n  \n}\n\nvoid frequencyTrackerFree(FrequencyTracker* obj) {\n    \n}\n\n/**\n * Your FrequencyTracker struct will be instantiated and called as such:\n * FrequencyTracker* obj = frequencyTrackerCreate();\n * frequencyTrackerAdd(obj, number);\n \n * frequencyTrackerDeleteOne(obj, number);\n \n * bool param_3 = frequencyTrackerHasFrequency(obj, frequency);\n \n * frequencyTrackerFree(obj);\n*/", "csharp": "public class FrequencyTracker {\n\n    public FrequencyTracker() {\n        \n    }\n    \n    public void Add(int number) {\n        \n    }\n    \n    public void DeleteOne(int number) {\n        \n    }\n    \n    public bool HasFrequency(int frequency) {\n        \n    }\n}\n\n/**\n * Your FrequencyTracker object will be instantiated and called as such:\n * FrequencyTracker obj = new FrequencyTracker();\n * obj.Add(number);\n * obj.DeleteOne(number);\n * bool param_3 = obj.HasFrequency(frequency);\n */", "javascript": "\nvar FrequencyTracker = function() {\n    \n};\n\n/** \n * @param {number} number\n * @return {void}\n */\nFrequencyTracker.prototype.add = function(number) {\n    \n};\n\n/** \n * @param {number} number\n * @return {void}\n */\nFrequencyTracker.prototype.deleteOne = function(number) {\n    \n};\n\n/** \n * @param {number} frequency\n * @return {boolean}\n */\nFrequencyTracker.prototype.hasFrequency = function(frequency) {\n    \n};\n\n/** \n * Your FrequencyTracker object will be instantiated and called as such:\n * var obj = new FrequencyTracker()\n * obj.add(number)\n * obj.deleteOne(number)\n * var param_3 = obj.hasFrequency(frequency)\n */", "typescript": "class FrequencyTracker {\n    constructor() {\n\n    }\n\n    add(number: number): void {\n\n    }\n\n    deleteOne(number: number): void {\n\n    }\n\n    hasFrequency(frequency: number): boolean {\n\n    }\n}\n\n/**\n * Your FrequencyTracker object will be instantiated and called as such:\n * var obj = new FrequencyTracker()\n * obj.add(number)\n * obj.deleteOne(number)\n * var param_3 = obj.hasFrequency(frequency)\n */", "php": "class FrequencyTracker {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param Integer $number\n     * @return NULL\n     */\n    function add($number) {\n        \n    }\n  \n    /**\n     * @param Integer $number\n     * @return NULL\n     */\n    function deleteOne($number) {\n        \n    }\n  \n    /**\n     * @param Integer $frequency\n     * @return Boolean\n     */\n    function hasFrequency($frequency) {\n        \n    }\n}\n\n/**\n * Your FrequencyTracker object will be instantiated and called as such:\n * $obj = FrequencyTracker();\n * $obj->add($number);\n * $obj->deleteOne($number);\n * $ret_3 = $obj->hasFrequency($frequency);\n */", "swift": "\nclass FrequencyTracker {\n\n    init() {\n        \n    }\n    \n    func add(_ number: Int) {\n        \n    }\n    \n    func deleteOne(_ number: Int) {\n        \n    }\n    \n    func hasFrequency(_ frequency: Int) -> Bool {\n        \n    }\n}\n\n/**\n * Your FrequencyTracker object will be instantiated and called as such:\n * let obj = FrequencyTracker()\n * obj.add(number)\n * obj.deleteOne(number)\n * let ret_3: Bool = obj.hasFrequency(frequency)\n */", "kotlin": "class FrequencyTracker() {\n\n    fun add(number: Int) {\n        \n    }\n\n    fun deleteOne(number: Int) {\n        \n    }\n\n    fun hasFrequency(frequency: Int): Boolean {\n        \n    }\n\n}\n\n/**\n * Your FrequencyTracker object will be instantiated and called as such:\n * var obj = FrequencyTracker()\n * obj.add(number)\n * obj.deleteOne(number)\n * var param_3 = obj.hasFrequency(frequency)\n */", "dart": "class FrequencyTracker {\n\n  FrequencyTracker() {\n\n  }\n  \n  void add(int number) {\n\n  }\n  \n  void deleteOne(int number) {\n\n  }\n  \n  bool hasFrequency(int frequency) {\n\n  }\n}\n\n/**\n * Your FrequencyTracker object will be instantiated and called as such:\n * FrequencyTracker obj = FrequencyTracker();\n * obj.add(number);\n * obj.deleteOne(number);\n * bool param3 = obj.hasFrequency(frequency);\n */", "golang": "type FrequencyTracker struct {\n    \n}\n\n\nfunc Constructor() FrequencyTracker {\n    \n}\n\n\nfunc (this *FrequencyTracker) Add(number int)  {\n    \n}\n\n\nfunc (this *FrequencyTracker) DeleteOne(number int)  {\n    \n}\n\n\nfunc (this *FrequencyTracker) HasFrequency(frequency int) bool {\n    \n}\n\n\n/**\n * Your FrequencyTracker object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Add(number);\n * obj.DeleteOne(number);\n * param_3 := obj.HasFrequency(frequency);\n */", "ruby": "class FrequencyTracker\n    def initialize()\n        \n    end\n\n\n=begin\n    :type number: Integer\n    :rtype: Void\n=end\n    def add(number)\n        \n    end\n\n\n=begin\n    :type number: Integer\n    :rtype: Void\n=end\n    def delete_one(number)\n        \n    end\n\n\n=begin\n    :type frequency: Integer\n    :rtype: Boolean\n=end\n    def has_frequency(frequency)\n        \n    end\n\n\nend\n\n# Your FrequencyTracker object will be instantiated and called as such:\n# obj = FrequencyTracker.new()\n# obj.add(number)\n# obj.delete_one(number)\n# param_3 = obj.has_frequency(frequency)", "scala": "class FrequencyTracker() {\n\n    def add(number: Int) {\n        \n    }\n\n    def deleteOne(number: Int) {\n        \n    }\n\n    def hasFrequency(frequency: Int): Boolean = {\n        \n    }\n\n}\n\n/**\n * Your FrequencyTracker object will be instantiated and called as such:\n * var obj = new FrequencyTracker()\n * obj.add(number)\n * obj.deleteOne(number)\n * var param_3 = obj.hasFrequency(frequency)\n */", "rust": "struct FrequencyTracker {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl FrequencyTracker {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn add(&self, number: i32) {\n        \n    }\n    \n    fn delete_one(&self, number: i32) {\n        \n    }\n    \n    fn has_frequency(&self, frequency: i32) -> bool {\n        \n    }\n}\n\n/**\n * Your FrequencyTracker object will be instantiated and called as such:\n * let obj = FrequencyTracker::new();\n * obj.add(number);\n * obj.delete_one(number);\n * let ret_3: bool = obj.has_frequency(frequency);\n */", "racket": "(define frequency-tracker%\n  (class object%\n    (super-new)\n    \n    (init-field)\n    \n    ; add : exact-integer? -> void?\n    (define/public (add number)\n\n      )\n    ; delete-one : exact-integer? -> void?\n    (define/public (delete-one number)\n\n      )\n    ; has-frequency : exact-integer? -> boolean?\n    (define/public (has-frequency frequency)\n\n      )))\n\n;; Your frequency-tracker% object will be instantiated and called as such:\n;; (define obj (new frequency-tracker%))\n;; (send obj add number)\n;; (send obj delete-one number)\n;; (define param_3 (send obj has-frequency frequency))", "erlang": "-spec frequency_tracker_init_() -> any().\nfrequency_tracker_init_() ->\n  .\n\n-spec frequency_tracker_add(Number :: integer()) -> any().\nfrequency_tracker_add(Number) ->\n  .\n\n-spec frequency_tracker_delete_one(Number :: integer()) -> any().\nfrequency_tracker_delete_one(Number) ->\n  .\n\n-spec frequency_tracker_has_frequency(Frequency :: integer()) -> boolean().\nfrequency_tracker_has_frequency(Frequency) ->\n  .\n\n\n%% Your functions will be called as such:\n%% frequency_tracker_init_(),\n%% frequency_tracker_add(Number),\n%% frequency_tracker_delete_one(Number),\n%% Param_3 = frequency_tracker_has_frequency(Frequency),\n\n%% frequency_tracker_init_ will be called before every test case, in which you can do some necessary initializations.", "elixir": "defmodule FrequencyTracker do\n  @spec init_() :: any\n  def init_() do\n\n  end\n\n  @spec add(number :: integer) :: any\n  def add(number) do\n\n  end\n\n  @spec delete_one(number :: integer) :: any\n  def delete_one(number) do\n\n  end\n\n  @spec has_frequency(frequency :: integer) :: boolean\n  def has_frequency(frequency) do\n\n  end\nend\n\n# Your functions will be called as such:\n# FrequencyTracker.init_()\n# FrequencyTracker.add(number)\n# FrequencyTracker.delete_one(number)\n# param_3 = FrequencyTracker.has_frequency(frequency)\n\n# FrequencyTracker.init_ will be called before every test case, in which you can do some necessary initializations."}}
{"id": "leetcode_2919", "url": "https://leetcode.com/problems/minimum-increment-operations-to-make-array-beautiful/", "title": "Minimum Increment Operations to Make Array Beautiful", "description": "You are given a **0-indexed** integer array `nums` having length `n`, and an integer `k`.\n\n\nYou can perform the following **increment** operation **any** number of times (**including zero**):\n\n\n* Choose an index `i` in the range `[0, n - 1]`, and increase `nums[i]` by `1`.\n\n\nAn array is considered **beautiful** if, for any **subarray** with a size of `3` or **more**, its **maximum** element is **greater than or equal** to `k`.\n\n\nReturn *an integer denoting the **minimum** number of increment operations needed to make* `nums` ***beautiful**.*\n\n\nA subarray is a contiguous **non-empty** sequence of elements within an array.", "examples": ["**Input:** nums = [2,3,0,0,2], k = 4\n**Output:** 3\n**Explanation:** We can perform the following increment operations to make nums beautiful:\nChoose index i = 1 and increase nums[1] by 1 -> [2,4,0,0,2].\nChoose index i = 4 and increase nums[4] by 1 -> [2,4,0,0,3].\nChoose index i = 4 and increase nums[4] by 1 -> [2,4,0,0,4].\nThe subarrays with a size of 3 or more are: [2,4,0], [4,0,0], [0,0,4], [2,4,0,0], [4,0,0,4], [2,4,0,0,4].\nIn all the subarrays, the maximum element is equal to k = 4, so nums is now beautiful.\nIt can be shown that nums cannot be made beautiful with fewer than 3 increment operations.\nHence, the answer is 3.", "**Input:** nums = [0,1,3,3], k = 5\n**Output:** 2\n**Explanation:** We can perform the following increment operations to make nums beautiful:\nChoose index i = 2 and increase nums[2] by 1 -> [0,1,4,3].\nChoose index i = 2 and increase nums[2] by 1 -> [0,1,5,3].\nThe subarrays with a size of 3 or more are: [0,1,5], [1,5,3], [0,1,5,3].\nIn all the subarrays, the maximum element is equal to k = 5, so nums is now beautiful.\nIt can be shown that nums cannot be made beautiful with fewer than 2 increment operations.\nHence, the answer is 2.", "**Input:** nums = [1,1,2], k = 1\n**Output:** 0\n**Explanation:** The only subarray with a size of 3 or more in this example is [1,1,2].\nThe maximum element, 2, is already greater than k = 1, so we don't need any increment operation.\nHence, the answer is 0."], "constraints": "**Constraints:**\n\n\n* `3 <= n == nums.length <= 105`\n* `0 <= nums[i] <= 109`\n* `0 <= k <= 109`", "difficulty": "Medium", "tags": ["Array", "Dynamic Programming"], "hints": ["There needs to be at least one value among <code>3</code> consecutive values in the array that is greater than or equal to <code>k</code>.", "The problem can be solved using dynamic programming.", "Let <code>dp[i]</code> be the minimum number of increment operations required to make the subarray consisting of the first <code>i</code> values beautiful, while also having the value at <code>nums[i] >= k</code>.", "<code>dp[0] = max(0, k - nums[0])</code>, <code>dp[1] = max(0, k - nums[1])</code>, and <code>dp[2] = max(0, k - nums[2])</code>.", "<code>dp[i] = max(0, k - nums[i]) + min(dp[i - 1], dp[i - 2], dp[i - 3])</code> for <code>i</code> in the range <code>[3, n - 1]</code>.", "The answer to the problem is <code>min(dp[n - 1], dp[n - 2], dp[n - 3])</code>."], "templates": {"cpp": "class Solution {\npublic:\n    long long minIncrementOperations(vector<int>& nums, int k) {\n        \n    }\n};", "java": "class Solution {\n    public long minIncrementOperations(int[] nums, int k) {\n        \n    }\n}", "python": "class Solution(object):\n    def minIncrementOperations(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def minIncrementOperations(self, nums: List[int], k: int) -> int:\n        ", "c": "long long minIncrementOperations(int* nums, int numsSize, int k) {\n    \n}", "csharp": "public class Solution {\n    public long MinIncrementOperations(int[] nums, int k) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minIncrementOperations = function(nums, k) {\n    \n};", "typescript": "function minIncrementOperations(nums: number[], k: number): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer\n     */\n    function minIncrementOperations($nums, $k) {\n        \n    }\n}", "swift": "class Solution {\n    func minIncrementOperations(_ nums: [Int], _ k: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun minIncrementOperations(nums: IntArray, k: Int): Long {\n        \n    }\n}", "dart": "class Solution {\n  int minIncrementOperations(List<int> nums, int k) {\n    \n  }\n}", "golang": "func minIncrementOperations(nums []int, k int) int64 {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer}\ndef min_increment_operations(nums, k)\n    \nend", "scala": "object Solution {\n    def minIncrementOperations(nums: Array[Int], k: Int): Long = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn min_increment_operations(nums: Vec<i32>, k: i32) -> i64 {\n        \n    }\n}", "racket": "(define/contract (min-increment-operations nums k)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )", "erlang": "-spec min_increment_operations(Nums :: [integer()], K :: integer()) -> integer().\nmin_increment_operations(Nums, K) ->\n  .", "elixir": "defmodule Solution do\n  @spec min_increment_operations(nums :: [integer], k :: integer) :: integer\n  def min_increment_operations(nums, k) do\n    \n  end\nend"}}
{"id": "leetcode_2962", "url": "https://leetcode.com/problems/count-subarrays-where-max-element-appears-at-least-k-times/", "title": "Count Subarrays Where Max Element Appears at Least K Times", "description": "You are given an integer array `nums` and a **positive** integer `k`.\n\n\nReturn *the number of subarrays where the **maximum** element of* `nums` *appears **at least*** `k` *times in that subarray.*\n\n\nA **subarray** is a contiguous sequence of elements within an array.", "examples": ["**Input:** nums = [1,3,2,3,3], k = 2\n**Output:** 6\n**Explanation:** The subarrays that contain the element 3 at least 2 times are: [1,3,2,3], [1,3,2,3,3], [3,2,3], [3,2,3,3], [2,3,3] and [3,3].", "**Input:** nums = [1,4,2,1], k = 3\n**Output:** 0\n**Explanation:** No subarray contains the element 4 at least 3 times."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `1 <= nums[i] <= 106`\n* `1 <= k <= 105`", "difficulty": "Medium", "tags": ["Array", "Sliding Window"], "hints": [], "templates": {"cpp": "class Solution {\npublic:\n    long long countSubarrays(vector<int>& nums, int k) {\n        \n    }\n};", "java": "class Solution {\n    public long countSubarrays(int[] nums, int k) {\n        \n    }\n}", "python": "class Solution(object):\n    def countSubarrays(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        ", "c": "long long countSubarrays(int* nums, int numsSize, int k) {\n    \n}", "csharp": "public class Solution {\n    public long CountSubarrays(int[] nums, int k) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar countSubarrays = function(nums, k) {\n    \n};", "typescript": "function countSubarrays(nums: number[], k: number): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer\n     */\n    function countSubarrays($nums, $k) {\n        \n    }\n}", "swift": "class Solution {\n    func countSubarrays(_ nums: [Int], _ k: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun countSubarrays(nums: IntArray, k: Int): Long {\n        \n    }\n}", "dart": "class Solution {\n  int countSubarrays(List<int> nums, int k) {\n    \n  }\n}", "golang": "func countSubarrays(nums []int, k int) int64 {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer}\ndef count_subarrays(nums, k)\n    \nend", "scala": "object Solution {\n    def countSubarrays(nums: Array[Int], k: Int): Long = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn count_subarrays(nums: Vec<i32>, k: i32) -> i64 {\n        \n    }\n}", "racket": "(define/contract (count-subarrays nums k)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )", "erlang": "-spec count_subarrays(Nums :: [integer()], K :: integer()) -> integer().\ncount_subarrays(Nums, K) ->\n  .", "elixir": "defmodule Solution do\n  @spec count_subarrays(nums :: [integer], k :: integer) :: integer\n  def count_subarrays(nums, k) do\n    \n  end\nend"}}
{"id": "leetcode_2870", "url": "https://leetcode.com/problems/minimum-number-of-operations-to-make-array-empty/", "title": "Minimum Number of Operations to Make Array Empty", "description": "You are given a **0-indexed** array `nums` consisting of positive integers.\n\n\nThere are two types of operations that you can apply on the array **any** number of times:\n\n\n* Choose **two** elements with **equal** values and **delete** them from the array.\n* Choose **three** elements with **equal** values and **delete** them from the array.\n\n\nReturn *the **minimum** number of operations required to make the array empty, or* `-1` *if it is not possible*.", "examples": ["**Input:** nums = [2,3,3,2,2,4,2,3,4]\n**Output:** 4\n**Explanation:** We can apply the following operations to make the array empty:\n- Apply the first operation on the elements at indices 0 and 3. The resulting array is nums = [3,3,2,4,2,3,4].\n- Apply the first operation on the elements at indices 2 and 4. The resulting array is nums = [3,3,4,3,4].\n- Apply the second operation on the elements at indices 0, 1, and 3. The resulting array is nums = [4,4].\n- Apply the first operation on the elements at indices 0 and 1. The resulting array is nums = [].\nIt can be shown that we cannot make the array empty in less than 4 operations.", "**Input:** nums = [2,1,2,2,3,3]\n**Output:** -1\n**Explanation:** It is impossible to empty the array."], "constraints": "**Constraints:**\n\n\n* `2 <= nums.length <= 105`\n* `1 <= nums[i] <= 106`", "difficulty": "Medium", "tags": ["Array", "Hash Table", "Greedy", "Counting"], "hints": [], "templates": {"cpp": "class Solution {\npublic:\n    int minOperations(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public int minOperations(int[] nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def minOperations(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ", "c": "int minOperations(int* nums, int numsSize){\n\n}", "csharp": "public class Solution {\n    public int MinOperations(int[] nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minOperations = function(nums) {\n    \n};", "typescript": "function minOperations(nums: number[]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function minOperations($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func minOperations(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun minOperations(nums: IntArray): Int {\n        \n    }\n}", "dart": "class Solution {\n  int minOperations(List<int> nums) {\n\n  }\n}", "golang": "func minOperations(nums []int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef min_operations(nums)\n    \nend", "scala": "object Solution {\n    def minOperations(nums: Array[Int]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn min_operations(nums: Vec<i32>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (min-operations nums)\n  (-> (listof exact-integer?) exact-integer?)\n\n  )", "erlang": "-spec min_operations(Nums :: [integer()]) -> integer().\nmin_operations(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec min_operations(nums :: [integer]) :: integer\n  def min_operations(nums) do\n\n  end\nend"}}
{"id": "leetcode_2866", "url": "https://leetcode.com/problems/beautiful-towers-ii/", "title": "Beautiful Towers II", "description": "You are given a **0-indexed** array `maxHeights` of `n` integers.\n\n\nYou are tasked with building `n` towers in the coordinate line. The `ith` tower is built at coordinate `i` and has a height of `heights[i]`.\n\n\nA configuration of towers is **beautiful** if the following conditions hold:\n\n\n1. `1 <= heights[i] <= maxHeights[i]`\n2. `heights` is a **mountain** array.\n\n\nArray `heights` is a **mountain** if there exists an index `i` such that:\n\n\n* For all `0 < j <= i`, `heights[j - 1] <= heights[j]`\n* For all `i <= k < n - 1`, `heights[k + 1] <= heights[k]`\n\n\nReturn *the **maximum possible sum of heights** of a beautiful configuration of towers*.", "examples": ["**Input:** maxHeights = [5,3,4,1,1]\n**Output:** 13\n**Explanation:** One beautiful configuration with a maximum sum is heights = [5,3,3,1,1]. This configuration is beautiful since:\n- 1 <= heights[i] <= maxHeights[i]  \n- heights is a mountain of peak i = 0.\nIt can be shown that there exists no other beautiful configuration with a sum of heights greater than 13.", "**Input:** maxHeights = [6,5,3,9,2,7]\n**Output:** 22\n**Explanation:** One beautiful configuration with a maximum sum is heights = [3,3,3,9,2,2]. This configuration is beautiful since:\n- 1 <= heights[i] <= maxHeights[i]\n- heights is a mountain of peak i = 3.\nIt can be shown that there exists no other beautiful configuration with a sum of heights greater than 22.", "**Input:** maxHeights = [3,2,5,5,2,3]\n**Output:** 18\n**Explanation:** One beautiful configuration with a maximum sum is heights = [2,2,5,5,2,2]. This configuration is beautiful since:\n- 1 <= heights[i] <= maxHeights[i]\n- heights is a mountain of peak i = 2. \nNote that, for this configuration, i = 3 can also be considered a peak.\nIt can be shown that there exists no other beautiful configuration with a sum of heights greater than 18."], "constraints": "**Constraints:**\n\n\n* `1 <= n == maxHeights\u00a0<= 105`\n* `1 <= maxHeights[i] <= 109`", "difficulty": "Medium", "tags": ["Array", "Stack", "Monotonic Stack"], "hints": ["Try all the possible indices <code>i</code> as the peak.", "Let <code>left[i]</code> be the maximum sum of heights for the prefix <code>0, \u2026, i</code> when index <code>i</code> is the peak.", "Let <code>right[i]</code> be the maximum sum of heights for suffix <code>i, \u2026, (n - 1)</code> when <code>i</code> is the peak", "Compute values of <code>left[i]</code> from left to right using DP.\r\nFor each <code>i</code> from <code>0</code> to <code>n - 1</code>, <code>left[i] = maxHeights * (i - j) + answer[j]</code>, where <code>j</code> is the rightmost index to the left of <code>i</code> such that <code>maxHeights[j] < maxHeights[i] </code>.", "For each <code>i</code> from <code>n - 1</code> to <code>0</code>, <code>right[i] = maxHeights * (j - i) + answer[j]</code>, where <code>j</code> is the leftmost index to the right of <code>i</code> such that <code>maxHeights[j] < maxHeights[i] </code>."], "templates": {"cpp": "class Solution {\npublic:\n    long long maximumSumOfHeights(vector<int>& maxHeights) {\n        \n    }\n};", "java": "class Solution {\n    public long maximumSumOfHeights(List<Integer> maxHeights) {\n        \n    }\n}", "python": "class Solution(object):\n    def maximumSumOfHeights(self, maxHeights):\n        \"\"\"\n        :type maxHeights: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def maximumSumOfHeights(self, maxHeights: List[int]) -> int:\n        ", "c": "long long maximumSumOfHeights(int* maxHeights, int maxHeightsSize){\n\n}", "csharp": "public class Solution {\n    public long MaximumSumOfHeights(IList<int> maxHeights) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} maxHeights\n * @return {number}\n */\nvar maximumSumOfHeights = function(maxHeights) {\n    \n};", "typescript": "function maximumSumOfHeights(maxHeights: number[]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $maxHeights\n     * @return Integer\n     */\n    function maximumSumOfHeights($maxHeights) {\n        \n    }\n}", "swift": "class Solution {\n    func maximumSumOfHeights(_ maxHeights: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun maximumSumOfHeights(maxHeights: List<Int>): Long {\n        \n    }\n}", "dart": "class Solution {\n  int maximumSumOfHeights(List<int> maxHeights) {\n\n  }\n}", "golang": "func maximumSumOfHeights(maxHeights []int) int64 {\n    \n}", "ruby": "# @param {Integer[]} max_heights\n# @return {Integer}\ndef maximum_sum_of_heights(max_heights)\n    \nend", "scala": "object Solution {\n    def maximumSumOfHeights(maxHeights: List[Int]): Long = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn maximum_sum_of_heights(max_heights: Vec<i32>) -> i64 {\n        \n    }\n}", "racket": "(define/contract (maximum-sum-of-heights maxHeights)\n  (-> (listof exact-integer?) exact-integer?)\n\n  )", "erlang": "-spec maximum_sum_of_heights(MaxHeights :: [integer()]) -> integer().\nmaximum_sum_of_heights(MaxHeights) ->\n  .", "elixir": "defmodule Solution do\n  @spec maximum_sum_of_heights(max_heights :: [integer]) :: integer\n  def maximum_sum_of_heights(max_heights) do\n\n  end\nend"}}
{"id": "leetcode_2831", "url": "https://leetcode.com/problems/find-the-longest-equal-subarray/", "title": "Find the Longest Equal Subarray", "description": "You are given a **0-indexed** integer array `nums` and an integer `k`.\n\n\nA subarray is called **equal** if all of its elements are equal. Note that the empty subarray is an **equal** subarray.\n\n\nReturn *the length of the **longest** possible equal subarray after deleting **at most*** `k` *elements from* `nums`.\n\n\nA **subarray** is a contiguous, possibly empty sequence of elements within an array.", "examples": ["**Input:** nums = [1,3,2,3,1,3], k = 3\n**Output:** 3\n**Explanation:** It's optimal to delete the elements at index 2 and index 4.\nAfter deleting them, nums becomes equal to [1, 3, 3, 3].\nThe longest equal subarray starts at i = 1 and ends at j = 3 with length equal to 3.\nIt can be proven that no longer equal subarrays can be created.", "**Input:** nums = [1,1,2,2,1,1], k = 2\n**Output:** 4\n**Explanation:** It's optimal to delete the elements at index 2 and index 3.\nAfter deleting them, nums becomes equal to [1, 1, 1, 1].\nThe array itself is an equal subarray, so the answer is 4.\nIt can be proven that no longer equal subarrays can be created."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `1 <= nums[i] <= nums.length`\n* `0 <= k <= nums.length`", "difficulty": "Medium", "tags": ["Array", "Hash Table", "Binary Search", "Sliding Window"], "hints": ["<div class=\"_1l1MA\">For each number <code>x</code> in <code>nums</code>, create a sorted list <code>indices<sub>x</sub></code> of all indices <code>i</code> such that <code>nums[i] == x</code>.</div>", "<div class=\"_1l1MA\">On every <code>indices<sub>x</sub></code>, execute a sliding window technique.</div>", "<div class=\"_1l1MA\">For each <code>indices<sub>x</sub></code>, find <code>i, j</code> such that <code>(indices<sub>x</sub>[j] - indices<sub>x</sub>[i]) - (j - i) <= k</code> and <code>j - i + 1</code> is maximized.</div>", "<div class=\"_1l1MA\">The answer would be the maximum of <code>j - i + 1</code> for all <code>indices<sub>x</sub></code>.</div>"], "templates": {"cpp": "class Solution {\npublic:\n    int longestEqualSubarray(vector<int>& nums, int k) {\n        \n    }\n};", "java": "class Solution {\n    public int longestEqualSubarray(List<Integer> nums, int k) {\n        \n    }\n}", "python": "class Solution(object):\n    def longestEqualSubarray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def longestEqualSubarray(self, nums: List[int], k: int) -> int:\n        ", "c": "int longestEqualSubarray(int* nums, int numsSize, int k){\n\n}", "csharp": "public class Solution {\n    public int LongestEqualSubarray(IList<int> nums, int k) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar longestEqualSubarray = function(nums, k) {\n    \n};", "typescript": "function longestEqualSubarray(nums: number[], k: number): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer\n     */\n    function longestEqualSubarray($nums, $k) {\n        \n    }\n}", "swift": "class Solution {\n    func longestEqualSubarray(_ nums: [Int], _ k: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun longestEqualSubarray(nums: List<Int>, k: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int longestEqualSubarray(List<int> nums, int k) {\n\n  }\n}", "golang": "func longestEqualSubarray(nums []int, k int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer}\ndef longest_equal_subarray(nums, k)\n    \nend", "scala": "object Solution {\n    def longestEqualSubarray(nums: List[Int], k: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn longest_equal_subarray(nums: Vec<i32>, k: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (longest-equal-subarray nums k)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n\n  )", "erlang": "-spec longest_equal_subarray(Nums :: [integer()], K :: integer()) -> integer().\nlongest_equal_subarray(Nums, K) ->\n  .", "elixir": "defmodule Solution do\n  @spec longest_equal_subarray(nums :: [integer], k :: integer) :: integer\n  def longest_equal_subarray(nums, k) do\n\n  end\nend"}}
{"id": "leetcode_2779", "url": "https://leetcode.com/problems/maximum-beauty-of-an-array-after-applying-operation/", "title": "Maximum Beauty of an Array After Applying Operation", "description": "You are given a **0-indexed** array `nums` and a **non-negative** integer `k`.\n\n\nIn one operation, you can do the following:\n\n\n* Choose an index `i` that **hasn't been chosen before** from the range `[0, nums.length - 1]`.\n* Replace `nums[i]` with any integer from the range `[nums[i] - k, nums[i] + k]`.\n\n\nThe **beauty** of the array is the length of the longest subsequence consisting of equal elements.\n\n\nReturn *the **maximum** possible beauty of the array* `nums` *after applying the operation any number of times.*\n\n\n**Note** that you can apply the operation to each index **only once**.\n\n\nA\u00a0**subsequence** of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the order of the remaining elements.", "examples": ["**Input:** nums = [4,6,1,2], k = 2\n**Output:** 3\n**Explanation:** In this example, we apply the following operations:\n- Choose index 1, replace it with 4 (from range [4,8]), nums = [4,4,1,2].\n- Choose index 3, replace it with 4 (from range [0,4]), nums = [4,4,1,4].\nAfter the applied operations, the beauty of the array nums is 3 (subsequence consisting of indices 0, 1, and 3).\nIt can be proven that 3 is the maximum possible length we can achieve.", "**Input:** nums = [1,1,1,1], k = 10\n**Output:** 4\n**Explanation:** In this example we don't have to apply any operations.\nThe beauty of the array nums is 4 (whole array)."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `0 <= nums[i], k <= 105`", "difficulty": "Medium", "tags": ["Array", "Binary Search", "Sliding Window", "Sorting"], "hints": ["Sort the array.", "The problem becomes the following: find maximum subarray A[i \u2026 j] such that A[j] - A[i] \u2264 2 * k."], "templates": {"cpp": "class Solution {\npublic:\n    int maximumBeauty(vector<int>& nums, int k) {\n        \n    }\n};", "java": "class Solution {\n    public int maximumBeauty(int[] nums, int k) {\n        \n    }\n}", "python": "class Solution(object):\n    def maximumBeauty(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def maximumBeauty(self, nums: List[int], k: int) -> int:\n        ", "c": "int maximumBeauty(int* nums, int numsSize, int k){\n\n}", "csharp": "public class Solution {\n    public int MaximumBeauty(int[] nums, int k) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maximumBeauty = function(nums, k) {\n    \n};", "typescript": "function maximumBeauty(nums: number[], k: number): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer\n     */\n    function maximumBeauty($nums, $k) {\n        \n    }\n}", "swift": "class Solution {\n    func maximumBeauty(_ nums: [Int], _ k: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun maximumBeauty(nums: IntArray, k: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int maximumBeauty(List<int> nums, int k) {\n\n  }\n}", "golang": "func maximumBeauty(nums []int, k int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer}\ndef maximum_beauty(nums, k)\n    \nend", "scala": "object Solution {\n    def maximumBeauty(nums: Array[Int], k: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn maximum_beauty(nums: Vec<i32>, k: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (maximum-beauty nums k)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n\n  )", "erlang": "-spec maximum_beauty(Nums :: [integer()], K :: integer()) -> integer().\nmaximum_beauty(Nums, K) ->\n  .", "elixir": "defmodule Solution do\n  @spec maximum_beauty(nums :: [integer], k :: integer) :: integer\n  def maximum_beauty(nums, k) do\n\n  end\nend"}}
{"id": "leetcode_2811", "url": "https://leetcode.com/problems/check-if-it-is-possible-to-split-array/", "title": "Check if it is Possible to Split Array", "description": "You are given an array `nums` of length `n` and an integer `m`. You need to determine if it is possible to split the array into `n` **non-empty** arrays by performing a series of steps.\n\n\nIn each step, you can select an existing array (which may be the result of previous steps) with a length of **at least two** and split it into **two** subarrays, if, **for each** resulting subarray, **at least** one of the following holds:\n\n\n* The length of the subarray is one, or\n* The sum of elements of the subarray is **greater than or equal** to `m`.\n\n\nReturn `true` *if you can split the given array into* `n` *arrays, otherwise return* `false`.\n\n\n**Note:** A subarray is *a contiguous non-empty sequence of elements within an array*.", "examples": ["**Input:** nums = [2, 2, 1], m = 4\n**Output:** true\n**Explanation:** We can split the array into [2, 2] and [1] in the first step. Then, in the second step, we can split [2, 2] into [2] and [2]. As a result, the answer is true.", "**Input:** nums = [2, 1, 3], m = 5 \n**Output:** false\n**Explanation:** We can try splitting the array in two different ways: the first way is to have [2, 1] and [3], and the second way is to have [2] and [1, 3]. However, both of these ways are not valid. So, the answer is false.", "**Input:** nums = [2, 3, 3, 2, 3], m = 6\n**Output:** true\n**Explanation:** We can split the array into [2, 3, 3, 2] and [3] in the first step. Then, in the second step, we can split [2, 3, 3, 2] into [2, 3, 3] and [2]. Then, in the third step, we can split [2, 3, 3] into [2] and [3, 3]. And in the last step we can split [3, 3] into [3] and [3]. As a result, the answer is true."], "constraints": "**Constraints:**\n\n\n* `1 <= n == nums.length <= 100`\n* `1 <= nums[i] <= 100`\n* `1 <= m <= 200`", "difficulty": "Medium", "tags": ["Array", "Dynamic Programming", "Greedy"], "hints": ["It can be proven that if you can split more than one element as a subarray, then you can split exactly one element."], "templates": {"cpp": "class Solution {\npublic:\n    bool canSplitArray(vector<int>& nums, int m) {\n        \n    }\n};", "java": "class Solution {\n    public boolean canSplitArray(List<Integer> nums, int m) {\n        \n    }\n}", "python": "class Solution(object):\n    def canSplitArray(self, nums, m):\n        \"\"\"\n        :type nums: List[int]\n        :type m: int\n        :rtype: bool\n        \"\"\"\n        ", "python3": "class Solution:\n    def canSplitArray(self, nums: List[int], m: int) -> bool:\n        ", "c": "bool canSplitArray(int* nums, int numsSize, int m){\n\n}", "csharp": "public class Solution {\n    public bool CanSplitArray(IList<int> nums, int m) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @param {number} m\n * @return {boolean}\n */\nvar canSplitArray = function(nums, m) {\n    \n};", "typescript": "function canSplitArray(nums: number[], m: number): boolean {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $m\n     * @return Boolean\n     */\n    function canSplitArray($nums, $m) {\n        \n    }\n}", "swift": "class Solution {\n    func canSplitArray(_ nums: [Int], _ m: Int) -> Bool {\n        \n    }\n}", "kotlin": "class Solution {\n    fun canSplitArray(nums: List<Int>, m: Int): Boolean {\n        \n    }\n}", "dart": "class Solution {\n  bool canSplitArray(List<int> nums, int m) {\n\n  }\n}", "golang": "func canSplitArray(nums []int, m int) bool {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @param {Integer} m\n# @return {Boolean}\ndef can_split_array(nums, m)\n    \nend", "scala": "object Solution {\n    def canSplitArray(nums: List[Int], m: Int): Boolean = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn can_split_array(nums: Vec<i32>, m: i32) -> bool {\n        \n    }\n}", "racket": "(define/contract (can-split-array nums m)\n  (-> (listof exact-integer?) exact-integer? boolean?)\n\n  )", "erlang": "-spec can_split_array(Nums :: [integer()], M :: integer()) -> boolean().\ncan_split_array(Nums, M) ->\n  .", "elixir": "defmodule Solution do\n  @spec can_split_array(nums :: [integer], m :: integer) :: boolean\n  def can_split_array(nums, m) do\n\n  end\nend"}}
{"id": "leetcode_2915", "url": "https://leetcode.com/problems/length-of-the-longest-subsequence-that-sums-to-target/", "title": "Length of the Longest Subsequence That Sums to Target", "description": "You are given a **0-indexed** array of integers `nums`, and an integer `target`.\n\n\nReturn *the **length of the longest subsequence** of* `nums` *that sums up to* `target`. *If no such subsequence exists, return* `-1`.\n\n\nA **subsequence** is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.", "examples": ["**Input:** nums = [1,2,3,4,5], target = 9\n**Output:** 3\n**Explanation:** There are 3 subsequences with a sum equal to 9: [4,5], [1,3,5], and [2,3,4]. The longest subsequences are [1,3,5], and [2,3,4]. Hence, the answer is 3.", "**Input:** nums = [4,1,3,2,1,5], target = 7\n**Output:** 4\n**Explanation:** There are 5 subsequences with a sum equal to 7: [4,3], [4,1,2], [4,2,1], [1,1,5], and [1,3,2,1]. The longest subsequence is [1,3,2,1]. Hence, the answer is 4.", "**Input:** nums = [1,1,5,4,5], target = 3\n**Output:** -1\n**Explanation:** It can be shown that nums has no subsequence that sums up to 3."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 1000`\n* `1 <= nums[i] <= 1000`\n* `1 <= target <= 1000`", "difficulty": "Medium", "tags": ["Array", "Dynamic Programming"], "hints": ["Use dynamic programming.", "Let <code>dp[i][j]</code> be the maximum length of any subsequence of <code>nums[0..i - 1]</code> that sums to <code>j</code>.", "<code>dp[0][0] = 1</code>, and <code>dp[0][j] = 1</code> for all <code>target \u2265 j > 0</code>.", "<code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - nums[i -1])</code> for all <code>n \u2265 i > 0</code> and <code>target \u2265 j > nums[i - 1]</code>."], "templates": {"cpp": "class Solution {\npublic:\n    int lengthOfLongestSubsequence(vector<int>& nums, int target) {\n        \n    }\n};", "java": "class Solution {\n    public int lengthOfLongestSubsequence(List<Integer> nums, int target) {\n        \n    }\n}", "python": "class Solution(object):\n    def lengthOfLongestSubsequence(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:\n        ", "c": "int lengthOfLongestSubsequence(int* nums, int numsSize, int target){\n\n}", "csharp": "public class Solution {\n    public int LengthOfLongestSubsequence(IList<int> nums, int target) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar lengthOfLongestSubsequence = function(nums, target) {\n    \n};", "typescript": "function lengthOfLongestSubsequence(nums: number[], target: number): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $target\n     * @return Integer\n     */\n    function lengthOfLongestSubsequence($nums, $target) {\n        \n    }\n}", "swift": "class Solution {\n    func lengthOfLongestSubsequence(_ nums: [Int], _ target: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun lengthOfLongestSubsequence(nums: List<Int>, target: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int lengthOfLongestSubsequence(List<int> nums, int target) {\n\n  }\n}", "golang": "func lengthOfLongestSubsequence(nums []int, target int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @param {Integer} target\n# @return {Integer}\ndef length_of_longest_subsequence(nums, target)\n    \nend", "scala": "object Solution {\n    def lengthOfLongestSubsequence(nums: List[Int], target: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn length_of_longest_subsequence(nums: Vec<i32>, target: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (length-of-longest-subsequence nums target)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n\n  )", "erlang": "-spec length_of_longest_subsequence(Nums :: [integer()], Target :: integer()) -> integer().\nlength_of_longest_subsequence(Nums, Target) ->\n  .", "elixir": "defmodule Solution do\n  @spec length_of_longest_subsequence(nums :: [integer], target :: integer) :: integer\n  def length_of_longest_subsequence(nums, target) do\n\n  end\nend"}}
{"id": "leetcode_2780", "url": "https://leetcode.com/problems/minimum-index-of-a-valid-split/", "title": "Minimum Index of a Valid Split", "description": "An element `x` of an integer array `arr` of length `m` is **dominant** if `freq(x) * 2 > m`, where `freq(x)` is the number of occurrences of `x` in `arr`. Note that this definition implies that `arr` can have **at most one** dominant element.\n\n\nYou are given a **0-indexed** integer array `nums` of length `n` with one dominant element.\n\n\nYou can split `nums` at an index `i` into two arrays `nums[0, ..., i]` and `nums[i + 1, ..., n - 1]`, but the split is only **valid** if:\n\n\n* `0 <= i < n - 1`\n* `nums[0, ..., i]`, and `nums[i + 1, ..., n - 1]` have the same dominant element.\n\n\nHere, `nums[i, ..., j]` denotes the subarray of `nums` starting at index `i` and ending at index `j`, both ends being inclusive. Particularly, if `j < i` then `nums[i, ..., j]` denotes an empty subarray.\n\n\nReturn *the **minimum** index of a **valid split***. If no valid split exists, return `-1`.", "examples": ["**Input:** nums = [1,2,2,2]\n**Output:** 2\n**Explanation:** We can split the array at index 2 to obtain arrays [1,2,2] and [2]. \nIn array [1,2,2], element 2 is dominant since it occurs twice in the array and 2 * 2 > 3. \nIn array [2], element 2 is dominant since it occurs once in the array and 1 * 2 > 1.\nBoth [1,2,2] and [2] have the same dominant element as nums, so this is a valid split. \nIt can be shown that index 2 is the minimum index of a valid split.", "**Input:** nums = [2,1,3,1,1,1,7,1,2,1]\n**Output:** 4\n**Explanation:** We can split the array at index 4 to obtain arrays [2,1,3,1,1] and [1,7,1,2,1].\nIn array [2,1,3,1,1], element 1 is dominant since it occurs thrice in the array and 3 * 2 > 5.\nIn array [1,7,1,2,1], element 1 is dominant since it occurs thrice in the array and 3 * 2 > 5.\nBoth [2,1,3,1,1] and [1,7,1,2,1] have the same dominant element as nums, so this is a valid split.\nIt can be shown that index 4 is the minimum index of a valid split.", "**Input:** nums = [3,3,3,3,7,2,2]\n**Output:** -1\n**Explanation:** It can be shown that there is no valid split."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `1 <= nums[i] <= 109`\n* `nums` has exactly one dominant element.", "difficulty": "Medium", "tags": ["Array", "Hash Table", "Sorting"], "hints": ["Find the dominant element of nums by using a hashmap to maintain element frequency, we denote the dominant element as x and its frequency as f.", "For each index in [0, n - 2], calculate f1, x\u2019s frequency in the subarray [0, i] when looping the index. And f2, x\u2019s frequency in the subarray [i + 1, n - 1] which is equal to f - f1. Then we can check whether x is dominant in both subarrays."], "templates": {"cpp": "class Solution {\npublic:\n    int minimumIndex(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public int minimumIndex(List<Integer> nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def minimumIndex(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def minimumIndex(self, nums: List[int]) -> int:\n        ", "c": "int minimumIndex(int* nums, int numsSize){\n\n}", "csharp": "public class Solution {\n    public int MinimumIndex(IList<int> nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minimumIndex = function(nums) {\n    \n};", "typescript": "function minimumIndex(nums: number[]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function minimumIndex($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func minimumIndex(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun minimumIndex(nums: List<Int>): Int {\n        \n    }\n}", "dart": "class Solution {\n  int minimumIndex(List<int> nums) {\n\n  }\n}", "golang": "func minimumIndex(nums []int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef minimum_index(nums)\n    \nend", "scala": "object Solution {\n    def minimumIndex(nums: List[Int]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn minimum_index(nums: Vec<i32>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (minimum-index nums)\n  (-> (listof exact-integer?) exact-integer?)\n\n  )", "erlang": "-spec minimum_index(Nums :: [integer()]) -> integer().\nminimum_index(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec minimum_index(nums :: [integer]) :: integer\n  def minimum_index(nums) do\n\n  end\nend"}}
{"id": "leetcode_2939", "url": "https://leetcode.com/problems/maximum-xor-product/", "title": "Maximum Xor Product", "description": "Given three integers `a`, `b`, and `n`, return *the **maximum value** of* `(a XOR x) * (b XOR x)` *where* `0 <= x < 2n`.\n\n\nSince the answer may be too large, return it **modulo** `109 + 7`.\n\n\n**Note** that `XOR` is the bitwise XOR operation.", "examples": ["**Input:** a = 12, b = 5, n = 4\n**Output:** 98\n**Explanation:** For x = 2, (a XOR x) = 14 and (b XOR x) = 7. Hence, (a XOR x) * (b XOR x) = 98. \nIt can be shown that 98 is the maximum value of (a XOR x) * (b XOR x) for all 0 <= x < 2n.", "**Input:** a = 6, b = 7 , n = 5\n**Output:** 930\n**Explanation:** For x = 25, (a XOR x) = 31 and (b XOR x) = 30. Hence, (a XOR x) * (b XOR x) = 930.\nIt can be shown that 930 is the maximum value of (a XOR x) * (b XOR x) for all 0 <= x < 2n.", "**Input:** a = 1, b = 6, n = 3\n**Output:** 12\n**Explanation:** For x = 5, (a XOR x) = 4 and (b XOR x) = 3. Hence, (a XOR x) * (b XOR x) = 12.\nIt can be shown that 12 is the maximum value of (a XOR x) * (b XOR x) for all 0 <= x < 2n."], "constraints": "**Constraints:**\n\n\n* `0 <= a, b < 250`\n* `0 <= n <= 50`", "difficulty": "Medium", "tags": ["Math", "Greedy", "Bit Manipulation"], "hints": ["Iterate over bits from most significant to least significant.", "For the <code>i<sup>th</sup></code> bit, if both <code>a</code> and <code>b</code> have the same value, we can always make <code>x</code>\u2019s <code>i<sup>th</sup></code> bit different from <code>a</code> and <code>b</code>, so <code>a ^ x</code> and <code>b ^ x</code> both have the <code>i<sup>th</sup></cod> bit set.", "Otherwise, we can only set the <code>i<sup>th</sup></code> bit of one of <code>a ^ x</code> or <code>b ^ x</code>. Depending on the previous bits of  <code>a ^ x</code> or <code>b ^ x</code>, we should set the smaller value\u2019s <code>i<sup>th</sup></code> bit."], "templates": {"cpp": "class Solution {\npublic:\n    int maximumXorProduct(long long a, long long b, int n) {\n        \n    }\n};", "java": "class Solution {\n    public int maximumXorProduct(long a, long b, int n) {\n        \n    }\n}", "python": "class Solution(object):\n    def maximumXorProduct(self, a, b, n):\n        \"\"\"\n        :type a: int\n        :type b: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def maximumXorProduct(self, a: int, b: int, n: int) -> int:\n        ", "c": "int maximumXorProduct(long long a, long long b, int n) {\n    \n}", "csharp": "public class Solution {\n    public int MaximumXorProduct(long a, long b, int n) {\n        \n    }\n}", "javascript": "/**\n * @param {number} a\n * @param {number} b\n * @param {number} n\n * @return {number}\n */\nvar maximumXorProduct = function(a, b, n) {\n    \n};", "typescript": "function maximumXorProduct(a: number, b: number, n: number): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer $a\n     * @param Integer $b\n     * @param Integer $n\n     * @return Integer\n     */\n    function maximumXorProduct($a, $b, $n) {\n        \n    }\n}", "swift": "class Solution {\n    func maximumXorProduct(_ a: Int, _ b: Int, _ n: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun maximumXorProduct(a: Long, b: Long, n: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int maximumXorProduct(int a, int b, int n) {\n    \n  }\n}", "golang": "func maximumXorProduct(a int64, b int64, n int) int {\n    \n}", "ruby": "# @param {Integer} a\n# @param {Integer} b\n# @param {Integer} n\n# @return {Integer}\ndef maximum_xor_product(a, b, n)\n    \nend", "scala": "object Solution {\n    def maximumXorProduct(a: Long, b: Long, n: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn maximum_xor_product(a: i64, b: i64, n: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (maximum-xor-product a b n)\n  (-> exact-integer? exact-integer? exact-integer? exact-integer?)\n  )", "erlang": "-spec maximum_xor_product(A :: integer(), B :: integer(), N :: integer()) -> integer().\nmaximum_xor_product(A, B, N) ->\n  .", "elixir": "defmodule Solution do\n  @spec maximum_xor_product(a :: integer, b :: integer, n :: integer) :: integer\n  def maximum_xor_product(a, b, n) do\n    \n  end\nend"}}
{"id": "leetcode_2938", "url": "https://leetcode.com/problems/separate-black-and-white-balls/", "title": "Separate Black and White Balls", "description": "There are `n` balls on a table, each ball has a color black or white.\n\n\nYou are given a **0-indexed** binary string `s` of length `n`, where `1` and `0` represent black and white balls, respectively.\n\n\nIn each step, you can choose two adjacent balls and swap them.\n\n\nReturn *the **minimum** number of steps to group all the black balls to the right and all the white balls to the left*.", "examples": ["**Input:** s = \"101\"\n**Output:** 1\n**Explanation:** We can group all the black balls to the right in the following way:\n- Swap s[0] and s[1], s = \"011\".\nInitially, 1s are not grouped together, requiring at least 1 step to group them to the right.", "**Input:** s = \"100\"\n**Output:** 2\n**Explanation:** We can group all the black balls to the right in the following way:\n- Swap s[0] and s[1], s = \"010\".\n- Swap s[1] and s[2], s = \"001\".\nIt can be proven that the minimum number of steps needed is 2.", "**Input:** s = \"0111\"\n**Output:** 0\n**Explanation:** All the black balls are already grouped to the right."], "constraints": "**Constraints:**\n\n\n* `1 <= n == s.length <= 105`\n* `s[i]` is either `'0'` or `'1'`.", "difficulty": "Medium", "tags": ["Two Pointers", "String", "Greedy"], "hints": ["Every <code>1</code> in the string <code>s</code> should be swapped with every <code>0</code> on its right side.", "Iterate right to left and count the number of <code>0</code> that have already occurred, whenever you iterate on <code>1</code> add that counter to the answer."], "templates": {"cpp": "class Solution {\npublic:\n    long long minimumSteps(string s) {\n        \n    }\n};", "java": "class Solution {\n    public long minimumSteps(String s) {\n        \n    }\n}", "python": "class Solution(object):\n    def minimumSteps(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def minimumSteps(self, s: str) -> int:\n        ", "c": "long long minimumSteps(char* s) {\n    \n}", "csharp": "public class Solution {\n    public long MinimumSteps(string s) {\n        \n    }\n}", "javascript": "/**\n * @param {string} s\n * @return {number}\n */\nvar minimumSteps = function(s) {\n    \n};", "typescript": "function minimumSteps(s: string): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function minimumSteps($s) {\n        \n    }\n}", "swift": "class Solution {\n    func minimumSteps(_ s: String) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun minimumSteps(s: String): Long {\n        \n    }\n}", "dart": "class Solution {\n  int minimumSteps(String s) {\n    \n  }\n}", "golang": "func minimumSteps(s string) int64 {\n    \n}", "ruby": "# @param {String} s\n# @return {Integer}\ndef minimum_steps(s)\n    \nend", "scala": "object Solution {\n    def minimumSteps(s: String): Long = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn minimum_steps(s: String) -> i64 {\n        \n    }\n}", "racket": "(define/contract (minimum-steps s)\n  (-> string? exact-integer?)\n  )", "erlang": "-spec minimum_steps(S :: unicode:unicode_binary()) -> integer().\nminimum_steps(S) ->\n  .", "elixir": "defmodule Solution do\n  @spec minimum_steps(s :: String.t) :: integer\n  def minimum_steps(s) do\n    \n  end\nend"}}
{"id": "leetcode_2914", "url": "https://leetcode.com/problems/minimum-number-of-changes-to-make-binary-string-beautiful/", "title": "Minimum Number of Changes to Make Binary String Beautiful", "description": "You are given a **0-indexed** binary string `s` having an even length.\n\n\nA string is **beautiful** if it's possible to partition it into one or more substrings such that:\n\n\n* Each substring has an **even length**.\n* Each substring contains **only** `1`'s or **only** `0`'s.\n\n\nYou can change any character in `s` to `0` or `1`.\n\n\nReturn *the **minimum** number of changes required to make the string* `s` *beautiful*.", "examples": ["**Input:** s = \"1001\"\n**Output:** 2\n**Explanation:** We change s[1] to 1 and s[3] to 0 to get string \"1100\".\nIt can be seen that the string \"1100\" is beautiful because we can partition it into \"11|00\".\nIt can be proven that 2 is the minimum number of changes needed to make the string beautiful.", "**Input:** s = \"10\"\n**Output:** 1\n**Explanation:** We change s[1] to 1 to get string \"11\".\nIt can be seen that the string \"11\" is beautiful because we can partition it into \"11\".\nIt can be proven that 1 is the minimum number of changes needed to make the string beautiful.", "**Input:** s = \"0000\"\n**Output:** 0\n**Explanation:** We don't need to make any changes as the string \"0000\" is beautiful already."], "constraints": "**Constraints:**\n\n\n* `2 <= s.length <= 105`\n* `s` has an even length.\n* `s[i]` is either `'0'` or `'1'`.", "difficulty": "Medium", "tags": ["String"], "hints": ["For any valid partition, since each part consists of an even number of the same characters, we can further partition each part into lengths of exactly <code>2</code>.", "After noticing the first hint, we can decompose the whole string into disjoint blocks of size <code>2</code> and find the minimum number of changes required to make those blocks beautiful."], "templates": {"cpp": "class Solution {\npublic:\n    int minChanges(string s) {\n        \n    }\n};", "java": "class Solution {\n    public int minChanges(String s) {\n        \n    }\n}", "python": "class Solution(object):\n    def minChanges(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def minChanges(self, s: str) -> int:\n        ", "c": "int minChanges(char* s) {\n    \n}", "csharp": "public class Solution {\n    public int MinChanges(string s) {\n        \n    }\n}", "javascript": "/**\n * @param {string} s\n * @return {number}\n */\nvar minChanges = function(s) {\n    \n};", "typescript": "function minChanges(s: string): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function minChanges($s) {\n        \n    }\n}", "swift": "class Solution {\n    func minChanges(_ s: String) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun minChanges(s: String): Int {\n        \n    }\n}", "dart": "class Solution {\n  int minChanges(String s) {\n    \n  }\n}", "golang": "func minChanges(s string) int {\n    \n}", "ruby": "# @param {String} s\n# @return {Integer}\ndef min_changes(s)\n    \nend", "scala": "object Solution {\n    def minChanges(s: String): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn min_changes(s: String) -> i32 {\n        \n    }\n}", "racket": "(define/contract (min-changes s)\n  (-> string? exact-integer?)\n  )", "erlang": "-spec min_changes(S :: unicode:unicode_binary()) -> integer().\nmin_changes(S) ->\n  .", "elixir": "defmodule Solution do\n  @spec min_changes(s :: String.t) :: integer\n  def min_changes(s) do\n    \n  end\nend"}}
{"id": "leetcode_2830", "url": "https://leetcode.com/problems/maximize-the-profit-as-the-salesman/", "title": "Maximize the Profit as the Salesman", "description": "You are given an integer `n` representing the number of houses on a number line, numbered from `0` to `n - 1`.\n\n\nAdditionally, you are given a 2D integer array `offers` where `offers[i] = [starti, endi, goldi]`, indicating that `ith` buyer wants to buy all the houses from `starti` to `endi` for `goldi` amount of gold.\n\n\nAs a salesman, your goal is to **maximize** your earnings by strategically selecting and selling houses to buyers.\n\n\nReturn *the maximum amount of gold you can earn*.\n\n\n**Note** that different buyers can't buy the same house, and some houses may remain unsold.", "examples": ["**Input:** n = 5, offers = [[0,0,1],[0,2,2],[1,3,2]]\n**Output:** 3\n**Explanation:** There are 5 houses numbered from 0 to 4 and there are 3 purchase offers.\nWe sell houses in the range [0,0] to 1st buyer for 1 gold and houses in the range [1,3] to 3rd buyer for 2 golds.\nIt can be proven that 3 is the maximum amount of gold we can achieve.", "**Input:** n = 5, offers = [[0,0,1],[0,2,10],[1,3,2]]\n**Output:** 10\n**Explanation:** There are 5 houses numbered from 0 to 4 and there are 3 purchase offers.\nWe sell houses in the range [0,2] to 2nd buyer for 10 golds.\nIt can be proven that 10 is the maximum amount of gold we can achieve."], "constraints": "**Constraints:**\n\n\n* `1 <= n <= 105`\n* `1 <= offers.length <= 105`\n* `offers[i].length == 3`\n* `0 <= starti <= endi <= n - 1`\n* `1 <= goldi <= 103`", "difficulty": "Medium", "tags": ["Array", "Binary Search", "Dynamic Programming", "Sorting"], "hints": ["<div class=\"_1l1MA\">The intended solution uses a dynamic programming approach to solve the problem.</div>", "<div class=\"_1l1MA\">Sort the array offers by <code>start<sub>i</sub></code>.</div>", "<div class=\"_1l1MA\">Let <code>dp[i]</code> = { the maximum amount of gold if the sold houses are in the range <code>[0 \u2026 i]</code> }.</div>"], "templates": {"cpp": "class Solution {\npublic:\n    int maximizeTheProfit(int n, vector<vector<int>>& offers) {\n        \n    }\n};", "java": "class Solution {\n    public int maximizeTheProfit(int n, List<List<Integer>> offers) {\n        \n    }\n}", "python": "class Solution(object):\n    def maximizeTheProfit(self, n, offers):\n        \"\"\"\n        :type n: int\n        :type offers: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def maximizeTheProfit(self, n: int, offers: List[List[int]]) -> int:\n        ", "c": "int maximizeTheProfit(int n, int** offers, int offersSize, int* offersColSize){\n\n}", "csharp": "public class Solution {\n    public int MaximizeTheProfit(int n, IList<IList<int>> offers) {\n        \n    }\n}", "javascript": "/**\n * @param {number} n\n * @param {number[][]} offers\n * @return {number}\n */\nvar maximizeTheProfit = function(n, offers) {\n    \n};", "typescript": "function maximizeTheProfit(n: number, offers: number[][]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $offers\n     * @return Integer\n     */\n    function maximizeTheProfit($n, $offers) {\n        \n    }\n}", "swift": "class Solution {\n    func maximizeTheProfit(_ n: Int, _ offers: [[Int]]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun maximizeTheProfit(n: Int, offers: List<List<Int>>): Int {\n        \n    }\n}", "dart": "class Solution {\n  int maximizeTheProfit(int n, List<List<int>> offers) {\n\n  }\n}", "golang": "func maximizeTheProfit(n int, offers [][]int) int {\n    \n}", "ruby": "# @param {Integer} n\n# @param {Integer[][]} offers\n# @return {Integer}\ndef maximize_the_profit(n, offers)\n    \nend", "scala": "object Solution {\n    def maximizeTheProfit(n: Int, offers: List[List[Int]]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn maximize_the_profit(n: i32, offers: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (maximize-the-profit n offers)\n  (-> exact-integer? (listof (listof exact-integer?)) exact-integer?)\n\n  )", "erlang": "-spec maximize_the_profit(N :: integer(), Offers :: [[integer()]]) -> integer().\nmaximize_the_profit(N, Offers) ->\n  .", "elixir": "defmodule Solution do\n  @spec maximize_the_profit(n :: integer, offers :: [[integer]]) :: integer\n  def maximize_the_profit(n, offers) do\n\n  end\nend"}}
{"id": "leetcode_2934", "url": "https://leetcode.com/problems/minimum-operations-to-maximize-last-elements-in-arrays/", "title": "Minimum Operations to Maximize Last Elements in Arrays", "description": "You are given two **0-indexed** integer arrays, `nums1` and `nums2`, both having length `n`.\n\n\nYou are allowed to perform a series of **operations** (**possibly none**).\n\n\nIn an operation, you select an index `i` in the range `[0, n - 1]` and **swap** the values of `nums1[i]` and `nums2[i]`.\n\n\nYour task is to find the **minimum** number of operations required to satisfy the following conditions:\n\n\n* `nums1[n - 1]` is equal to the **maximum value** among all elements of `nums1`, i.e., `nums1[n - 1] = max(nums1[0], nums1[1], ..., nums1[n - 1])`.\n* `nums2[n - 1]` is equal to the **maximum** **value** among all elements of `nums2`, i.e., `nums2[n - 1] = max(nums2[0], nums2[1], ..., nums2[n - 1])`.\n\n\nReturn *an integer denoting the **minimum** number of operations needed to meet **both** conditions*, *or* `-1` *if it is **impossible** to satisfy both conditions.*", "examples": ["**Input:** nums1 = [1,2,7], nums2 = [4,5,3]\n**Output:** 1\n**Explanation:** In this example, an operation can be performed using index i = 2.\nWhen nums1[2] and nums2[2] are swapped, nums1 becomes [1,2,3] and nums2 becomes [4,5,7].\nBoth conditions are now satisfied.\nIt can be shown that the minimum number of operations needed to be performed is 1.\nSo, the answer is 1.", "**Input:** nums1 = [2,3,4,5,9], nums2 = [8,8,4,4,4]\n**Output:** 2\n**Explanation:** In this example, the following operations can be performed:\nFirst operation using index i = 4.\nWhen nums1[4] and nums2[4] are swapped, nums1 becomes [2,3,4,5,4], and nums2 becomes [8,8,4,4,9].\nAnother operation using index i = 3.\nWhen nums1[3] and nums2[3] are swapped, nums1 becomes [2,3,4,4,4], and nums2 becomes [8,8,4,5,9].\nBoth conditions are now satisfied.\nIt can be shown that the minimum number of operations needed to be performed is 2.\nSo, the answer is 2.", "**Input:** nums1 = [1,5,4], nums2 = [2,5,3]\n**Output:** -1\n**Explanation:** In this example, it is not possible to satisfy both conditions. \nSo, the answer is -1."], "constraints": "**Constraints:**\n\n\n* `1 <= n == nums1.length == nums2.length <= 1000`\n* `1 <= nums1[i] <= 109`\n* `1 <= nums2[i] <= 109`", "difficulty": "Medium", "tags": ["Array", "Greedy"], "hints": ["Consider how to calculate the minimum number of operations when <code>nums1[n - 1]</code> and <code>nums2[n - 1]</code> are fixed (they are not swapped).", "For each index <code>i</code>, there are only <code>3</code> possibilities: <ul>\r\n<li><code>nums1[i] <= nums1[n - 1] && nums2[i] <= nums2[n - 1]</code>. We don't need to swap them.</li>\r\n<li><code>nums1[i] <= nums2[n - 1] && nums2[i] <= nums1[n - 1]</code>. We have to swap them.</li>\r\n<li>Otherwise, there is no solution.</li>\r\n</ul>", "There are <code>2</code> cases to determine the minimum number of operations: <ul>\r\n<li>The first case is the number of indices that need to be swapped when <code>nums1[n - 1]</code> and <code>nums2[n - 1]</code> are fixed.</li>\r\n<li>The second case is <code>1 +</code> the number of indices that need to be swapped when <code>nums1[n - 1]</code> and <code>nums2[n - 1]</code> are swapped.</li>\r\n</ul>", "The answer is the minimum of both cases or <code>-1</code> if there is no solution in either case."], "templates": {"cpp": "class Solution {\npublic:\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\n        \n    }\n};", "java": "class Solution {\n    public int minOperations(int[] nums1, int[] nums2) {\n        \n    }\n}", "python": "class Solution(object):\n    def minOperations(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\n        ", "c": "int minOperations(int* nums1, int nums1Size, int* nums2, int nums2Size) {\n    \n}", "csharp": "public class Solution {\n    public int MinOperations(int[] nums1, int[] nums2) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar minOperations = function(nums1, nums2) {\n    \n};", "typescript": "function minOperations(nums1: number[], nums2: number[]): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums1\n     * @param Integer[] $nums2\n     * @return Integer\n     */\n    function minOperations($nums1, $nums2) {\n        \n    }\n}", "swift": "class Solution {\n    func minOperations(_ nums1: [Int], _ nums2: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun minOperations(nums1: IntArray, nums2: IntArray): Int {\n        \n    }\n}", "dart": "class Solution {\n  int minOperations(List<int> nums1, List<int> nums2) {\n    \n  }\n}", "golang": "func minOperations(nums1 []int, nums2 []int) int {\n    \n}", "ruby": "# @param {Integer[]} nums1\n# @param {Integer[]} nums2\n# @return {Integer}\ndef min_operations(nums1, nums2)\n    \nend", "scala": "object Solution {\n    def minOperations(nums1: Array[Int], nums2: Array[Int]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn min_operations(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (min-operations nums1 nums2)\n  (-> (listof exact-integer?) (listof exact-integer?) exact-integer?)\n  )", "erlang": "-spec min_operations(Nums1 :: [integer()], Nums2 :: [integer()]) -> integer().\nmin_operations(Nums1, Nums2) ->\n  .", "elixir": "defmodule Solution do\n  @spec min_operations(nums1 :: [integer], nums2 :: [integer]) :: integer\n  def min_operations(nums1, nums2) do\n    \n  end\nend"}}
{"id": "leetcode_2871", "url": "https://leetcode.com/problems/split-array-into-maximum-number-of-subarrays/", "title": "Split Array Into Maximum Number of Subarrays", "description": "You are given an array `nums` consisting of **non-negative** integers.\n\n\nWe define the score of subarray `nums[l..r]` such that `l <= r` as `nums[l] AND nums[l + 1] AND ... AND nums[r]` where **AND** is the bitwise `AND` operation.\n\n\nConsider splitting the array into one or more subarrays such that the following conditions are satisfied:\n\n\n* **E****ach** element of the array belongs to **exactly** one subarray.\n* The sum of scores of the subarrays is the **minimum** possible.\n\n\nReturn *the **maximum** number of subarrays in a split that satisfies the conditions above.*\n\n\nA **subarray** is a contiguous part of an array.", "examples": ["**Input:** nums = [1,0,2,0,1,2]\n**Output:** 3\n**Explanation:** We can split the array into the following subarrays:\n- [1,0]. The score of this subarray is 1 AND 0 = 0.\n- [2,0]. The score of this subarray is 2 AND 0 = 0.\n- [1,2]. The score of this subarray is 1 AND 2 = 0.\nThe sum of scores is 0 + 0 + 0 = 0, which is the minimum possible score that we can obtain.\nIt can be shown that we cannot split the array into more than 3 subarrays with a total score of 0. So we return 3.", "**Input:** nums = [5,7,1,3]\n**Output:** 1\n**Explanation:** We can split the array into one subarray: [5,7,1,3] with a score of 1, which is the minimum possible score that we can obtain.\nIt can be shown that we cannot split the array into more than 1 subarray with a total score of 1. So we return 1."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `0 <= nums[i] <= 106`", "difficulty": "Medium", "tags": ["Array", "Greedy", "Bit Manipulation"], "hints": ["The minimum score will always be the bitwise <code>AND</code> of all elements of the array.", "If the minimum score is not equal to <code>0</code>, the only possible split will be to keep all elements in one subarray.", "Otherwise, all of the subarrays should have a score of <code>0</code>, we can greedily split the array while trying to make each subarray as small as possible."], "templates": {"cpp": "class Solution {\npublic:\n    int maxSubarrays(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public int maxSubarrays(int[] nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def maxSubarrays(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def maxSubarrays(self, nums: List[int]) -> int:\n        ", "c": "int maxSubarrays(int* nums, int numsSize){\n\n}", "csharp": "public class Solution {\n    public int MaxSubarrays(int[] nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxSubarrays = function(nums) {\n    \n};", "typescript": "function maxSubarrays(nums: number[]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function maxSubarrays($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func maxSubarrays(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun maxSubarrays(nums: IntArray): Int {\n        \n    }\n}", "dart": "class Solution {\n  int maxSubarrays(List<int> nums) {\n\n  }\n}", "golang": "func maxSubarrays(nums []int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef max_subarrays(nums)\n    \nend", "scala": "object Solution {\n    def maxSubarrays(nums: Array[Int]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn max_subarrays(nums: Vec<i32>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (max-subarrays nums)\n  (-> (listof exact-integer?) exact-integer?)\n\n  )", "erlang": "-spec max_subarrays(Nums :: [integer()]) -> integer().\nmax_subarrays(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec max_subarrays(nums :: [integer]) :: integer\n  def max_subarrays(nums) do\n\n  end\nend"}}
{"id": "leetcode_2826", "url": "https://leetcode.com/problems/sorting-three-groups/", "title": "Sorting Three Groups", "description": "You are given a **0-indexed** integer array `nums` of length `n`.  \n\n  \n\nThe numbers from `0` to `n - 1` are divided into three groups numbered from `1` to `3`, where number `i` belongs to group `nums[i]`. Notice that some groups may be **empty**.  \n\n  \n\nYou are allowed to perform this operation any number of times:\n\n\n* Pick number `x` and change its group. More formally, change `nums[x]` to any number from `1` to `3`.\n\n\nA new array `res` is constructed using the following procedure:\n\n\n1. Sort the numbers in each group independently.\n2. Append the elements of groups `1`, `2`, and `3` to `res` **in this order**.\n\n\nArray `nums` is called a **beautiful array** if the constructed array `res` is sorted in **non-decreasing** order.\n\n\nReturn *the **minimum** number of operations to make* `nums` *a **beautiful array***.", "examples": ["**Input:** nums = [2,1,3,2,1]\n**Output:** 3\n**Explanation:** It's optimal to perform three operations:\n1. change nums[0] to 1.\n2. change nums[2] to 1.\n3. change nums[3] to 1.\nAfter performing the operations and sorting the numbers in each group, group 1 becomes equal to [0,1,2,3,4] and group 2 and group 3 become empty. Hence, res is equal to [0,1,2,3,4] which is sorted in non-decreasing order.\nIt can be proven that there is no valid sequence of less than three operations.", "**Input:** nums = [1,3,2,1,3,3]\n**Output:** 2\n**Explanation:** It's optimal to perform two operations:\n1. change nums[1] to 1.\n2. change nums[2] to 1.\nAfter performing the operations and sorting the numbers in each group, group 1 becomes equal to [0,1,2,3], group 2 becomes empty, and group 3 becomes equal to [4,5]. Hence, res is equal to [0,1,2,3,4,5] which is sorted in non-decreasing order.\nIt can be proven that there is no valid sequence of less than two operations.", "**Input:** nums = [2,2,2,2,3,3]\n**Output:** 0\n**Explanation:** It's optimal to not perform operations.\nAfter sorting the numbers in each group, group 1 becomes empty, group 2 becomes equal to [0,1,2,3] and group 3 becomes equal to [4,5]. Hence, res is equal to [0,1,2,3,4,5] which is sorted in non-decreasing order."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 100`\n* `1 <= nums[i] <= 3`", "difficulty": "Medium", "tags": ["Array", "Dynamic Programming"], "hints": ["The problem asks to change the array nums to make it sorted (i.e., all the 1s are on the left of 2s, and all the 2s are on the left of 3s.).", "We can try all the possibilities to make nums indices range in [0, i) to 0 and [i, j) to 1 and [j, n) to 2. Note the ranges are left-close and right-open; each might be empty. Namely, 0 <= i <= j <= n.", "Count the changes we need for each possibility by comparing the expected and original values at each index position."], "templates": {"cpp": "class Solution {\npublic:\n    int minimumOperations(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public int minimumOperations(List<Integer> nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def minimumOperations(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def minimumOperations(self, nums: List[int]) -> int:\n        ", "c": "int minimumOperations(int* nums, int numsSize){\n\n}", "csharp": "public class Solution {\n    public int MinimumOperations(IList<int> nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minimumOperations = function(nums) {\n    \n};", "typescript": "function minimumOperations(nums: number[]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function minimumOperations($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func minimumOperations(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun minimumOperations(nums: List<Int>): Int {\n        \n    }\n}", "dart": "class Solution {\n  int minimumOperations(List<int> nums) {\n\n  }\n}", "golang": "func minimumOperations(nums []int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef minimum_operations(nums)\n    \nend", "scala": "object Solution {\n    def minimumOperations(nums: List[Int]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn minimum_operations(nums: Vec<i32>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (minimum-operations nums)\n  (-> (listof exact-integer?) exact-integer?)\n\n  )", "erlang": "-spec minimum_operations(Nums :: [integer()]) -> integer().\nminimum_operations(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec minimum_operations(nums :: [integer]) :: integer\n  def minimum_operations(nums) do\n\n  end\nend"}}
{"id": "leetcode_2918", "url": "https://leetcode.com/problems/minimum-equal-sum-of-two-arrays-after-replacing-zeros/", "title": "Minimum Equal Sum of Two Arrays After Replacing Zeros", "description": "You are given two arrays `nums1` and `nums2` consisting of positive integers.\n\n\nYou have to replace **all** the `0`'s in both arrays with **strictly** positive integers such that the sum of elements of both arrays becomes **equal**.\n\n\nReturn *the **minimum** equal sum you can obtain, or* `-1` *if it is impossible*.", "examples": ["**Input:** nums1 = [3,2,0,1,0], nums2 = [6,5,0]\n**Output:** 12\n**Explanation:** We can replace 0's in the following way:\n- Replace the two 0's in nums1 with the values 2 and 4. The resulting array is nums1 = [3,2,2,1,4].\n- Replace the 0 in nums2 with the value 1. The resulting array is nums2 = [6,5,1].\nBoth arrays have an equal sum of 12. It can be shown that it is the minimum sum we can obtain.", "**Input:** nums1 = [2,0,2,0], nums2 = [1,4]\n**Output:** -1\n**Explanation:** It is impossible to make the sum of both arrays equal."], "constraints": "**Constraints:**\n\n\n* `1 <= nums1.length, nums2.length <= 105`\n* `0 <= nums1[i], nums2[i] <= 106`", "difficulty": "Medium", "tags": ["Array", "Greedy"], "hints": ["Consider we replace all the 0\u2019s with 1\u2019s on both arrays, the answer will be <code>-1</code> if there was no <code>0</code> in the array with the smaller sum of elements.", "Otherwise, how can you update the value of exactly one of these <code>1</code>\u2019s to make the sum of the two arrays equal?", "Consider we replace all the 0\u2019s with 1\u2019s on both arrays, the answer will be <code>-1</code> if there was no <code>0</code> in the array with the smaller sum of elements.", "Otherwise, how can you update the value of exactly one of these <code>1</code>\u2019s to make the sum of the two arrays equal?"], "templates": {"cpp": "class Solution {\npublic:\n    long long minSum(vector<int>& nums1, vector<int>& nums2) {\n        \n    }\n};", "java": "class Solution {\n    public long minSum(int[] nums1, int[] nums2) {\n        \n    }\n}", "python": "class Solution(object):\n    def minSum(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        ", "c": "long long minSum(int* nums1, int nums1Size, int* nums2, int nums2Size) {\n    \n}", "csharp": "public class Solution {\n    public long MinSum(int[] nums1, int[] nums2) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar minSum = function(nums1, nums2) {\n    \n};", "typescript": "function minSum(nums1: number[], nums2: number[]): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums1\n     * @param Integer[] $nums2\n     * @return Integer\n     */\n    function minSum($nums1, $nums2) {\n        \n    }\n}", "swift": "class Solution {\n    func minSum(_ nums1: [Int], _ nums2: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun minSum(nums1: IntArray, nums2: IntArray): Long {\n        \n    }\n}", "dart": "class Solution {\n  int minSum(List<int> nums1, List<int> nums2) {\n    \n  }\n}", "golang": "func minSum(nums1 []int, nums2 []int) int64 {\n    \n}", "ruby": "# @param {Integer[]} nums1\n# @param {Integer[]} nums2\n# @return {Integer}\ndef min_sum(nums1, nums2)\n    \nend", "scala": "object Solution {\n    def minSum(nums1: Array[Int], nums2: Array[Int]): Long = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn min_sum(nums1: Vec<i32>, nums2: Vec<i32>) -> i64 {\n        \n    }\n}", "racket": "(define/contract (min-sum nums1 nums2)\n  (-> (listof exact-integer?) (listof exact-integer?) exact-integer?)\n  )", "erlang": "-spec min_sum(Nums1 :: [integer()], Nums2 :: [integer()]) -> integer().\nmin_sum(Nums1, Nums2) ->\n  .", "elixir": "defmodule Solution do\n  @spec min_sum(nums1 :: [integer], nums2 :: [integer]) :: integer\n  def min_sum(nums1, nums2) do\n    \n  end\nend"}}
{"id": "leetcode_2762", "url": "https://leetcode.com/problems/continuous-subarrays/", "title": "Continuous Subarrays", "description": "You are given a **0-indexed** integer array `nums`. A subarray of `nums` is called **continuous** if:\n\n\n* Let `i`, `i + 1`, ..., `j`be the indices in the subarray. Then, for each pair of indices `i <= i1, i2 <= j`, `0 <= |nums[i1] - nums[i2]| <= 2`.\n\n\nReturn *the total number of **continuous** subarrays.*\n\n\nA subarray is a contiguous **non-empty** sequence of elements within an array.", "examples": ["**Input:** nums = [5,4,2,4]\n**Output:** 8\n**Explanation:** \nContinuous subarray of size 1: [5], [4], [2], [4].\nContinuous subarray of size 2: [5,4], [4,2], [2,4].\nContinuous subarray of size 3: [4,2,4].\nThereare no subarrys of size 4.\nTotal continuous subarrays = 4 + 3 + 1 = 8.\nIt can be shown that there are no more continuous subarrays.", "**Input:** nums = [1,2,3]\n**Output:** 6\n**Explanation:** \nContinuous subarray of size 1: [1], [2], [3].\nContinuous subarray of size 2: [1,2], [2,3].\nContinuous subarray of size 3: [1,2,3].\nTotal continuous subarrays = 3 + 2 + 1 = 6."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `1 <= nums[i] <= 109`", "difficulty": "Medium", "tags": ["Array", "Queue", "Sliding Window", "Heap (Priority Queue)", "Ordered Set", "Monotonic Queue"], "hints": ["Try using the sliding window technique.", "Use a set or map to keep track of the maximum and minimum of subarrays."], "templates": {"cpp": "class Solution {\npublic:\n    long long continuousSubarrays(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public long continuousSubarrays(int[] nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def continuousSubarrays(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def continuousSubarrays(self, nums: List[int]) -> int:\n        ", "c": "long long continuousSubarrays(int* nums, int numsSize){\n\n}", "csharp": "public class Solution {\n    public long ContinuousSubarrays(int[] nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar continuousSubarrays = function(nums) {\n    \n};", "typescript": "function continuousSubarrays(nums: number[]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function continuousSubarrays($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func continuousSubarrays(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun continuousSubarrays(nums: IntArray): Long {\n        \n    }\n}", "dart": "class Solution {\n  int continuousSubarrays(List<int> nums) {\n\n  }\n}", "golang": "func continuousSubarrays(nums []int) int64 {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef continuous_subarrays(nums)\n    \nend", "scala": "object Solution {\n    def continuousSubarrays(nums: Array[Int]): Long = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn continuous_subarrays(nums: Vec<i32>) -> i64 {\n        \n    }\n}", "racket": "(define/contract (continuous-subarrays nums)\n  (-> (listof exact-integer?) exact-integer?)\n\n  )", "erlang": "-spec continuous_subarrays(Nums :: [integer()]) -> integer().\ncontinuous_subarrays(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec continuous_subarrays(nums :: [integer]) :: integer\n  def continuous_subarrays(nums) do\n\n  end\nend"}}
