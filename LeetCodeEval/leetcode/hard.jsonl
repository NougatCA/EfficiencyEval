{"id": "leetcode_2809", "url": "https://leetcode.com/problems/minimum-time-to-make-array-sum-at-most-x/", "title": "Minimum Time to Make Array Sum At Most x", "description": "You are given two **0-indexed** integer arrays `nums1` and `nums2` of equal length. Every second, for all indices `0 <= i < nums1.length`, value of `nums1[i]` is incremented by `nums2[i]`. **After** this is done, you can do the following operation:\n\n\n* Choose an index `0 <= i < nums1.length` and make `nums1[i] = 0`.\n\n\nYou are also given an integer `x`.\n\n\nReturn *the **minimum** time in which you can make the sum of all elements of* `nums1` *to be **less than or equal** to* `x`, *or* `-1` *if this is not possible.*", "examples": ["**Input:** nums1 = [1,2,3], nums2 = [1,2,3], x = 4\n**Output:** 3\n**Explanation:** \nFor the 1st second, we apply the operation on i = 0. Therefore nums1 = [0,2+2,3+3] = [0,4,6]. \nFor the 2nd second, we apply the operation on i = 1. Therefore nums1 = [0+1,0,6+3] = [1,0,9]. \nFor the 3rd second, we apply the operation on i = 2. Therefore nums1 = [1+1,0+2,0] = [2,2,0]. \nNow sum of nums1 = 4. It can be shown that these operations are optimal, so we return 3.", "**Input:** nums1 = [1,2,3], nums2 = [3,3,3], x = 4\n**Output:** -1\n**Explanation:** It can be shown that the sum of nums1 will always be greater than x, no matter which operations are performed."], "constraints": "**Constraints:**\n\n\n* `1 <= nums1.length <= 103`\n* `1 <= nums1[i] <= 103`\n* `0 <= nums2[i] <= 103`\n* `nums1.length == nums2.length`\n* `0 <= x <= 106`", "difficulty": "Hard", "tags": ["Array", "Dynamic Programming", "Sorting"], "hints": ["<div class=\"_1l1MA\">It can be proven that in the optimal solution, for each index <code>i</code>, we only need to set <code>nums1[i]</code> to <code>0</code> at most once. (If we have to set it twice, we can simply remove the earlier set and all the operations \u201cshift left\u201d by <code>1</code>.)</div>", "<div class=\"_1l1MA\">It can also be proven that if we select several indexes <code>i<sub>1</sub>, i<sub>2</sub>, ..., i<sub>k</sub></code> and set <code>nums1[i<sub>1</sub>], nums1[i<sub>2</sub>], ..., nums1[i<sub>k</sub>]</code> to <code>0</code>, it\u2019s always optimal to set them in the order of <code>nums2[i<sub>1</sub>] <= nums2[i<sub>2</sub>] <= ... <= nums2[i<sub>k</sub>]</code> (the larger the increase is, the later we should set it to <code>0</code>).</div>", "<div class=\"_1l1MA\">Let\u2019s sort all the values by <code>nums2</code> (in non-decreasing order). Let <code>dp[i][j]</code> represent the maximum total value that can be reduced if we do <code>j</code> operations on the first <code>i</code> elements. Then we have <code>dp[i][0] = 0</code> (for all <code>i = 0, 1, ..., n</code>) and <code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] + nums2[i - 1] * j + nums1[i - 1])</code> (for <code>1 <= i <= n</code> and <code>1 <= j <= i</code>).</div>", "<div class=\"_1l1MA\">The answer is the minimum value of <code>t</code>, such that <code>0 <= t <= n</code> and <code>sum(nums1) + sum(nums2) * t - dp[n][t] <= x</code>, or <code>-1</code> if it doesn\u2019t exist.</div>"], "templates": {"cpp": "class Solution {\npublic:\n    int minimumTime(vector<int>& nums1, vector<int>& nums2, int x) {\n        \n    }\n};", "java": "class Solution {\n    public int minimumTime(List<Integer> nums1, List<Integer> nums2, int x) {\n        \n    }\n}", "python": "class Solution(object):\n    def minimumTime(self, nums1, nums2, x):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type x: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def minimumTime(self, nums1: List[int], nums2: List[int], x: int) -> int:\n        ", "c": "int minimumTime(int* nums1, int nums1Size, int* nums2, int nums2Size, int x){\n\n}", "csharp": "public class Solution {\n    public int MinimumTime(IList<int> nums1, IList<int> nums2, int x) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @param {number} x\n * @return {number}\n */\nvar minimumTime = function(nums1, nums2, x) {\n    \n};", "typescript": "function minimumTime(nums1: number[], nums2: number[], x: number): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums1\n     * @param Integer[] $nums2\n     * @param Integer $x\n     * @return Integer\n     */\n    function minimumTime($nums1, $nums2, $x) {\n        \n    }\n}", "swift": "class Solution {\n    func minimumTime(_ nums1: [Int], _ nums2: [Int], _ x: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun minimumTime(nums1: List<Int>, nums2: List<Int>, x: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int minimumTime(List<int> nums1, List<int> nums2, int x) {\n\n  }\n}", "golang": "func minimumTime(nums1 []int, nums2 []int, x int) int {\n    \n}", "ruby": "# @param {Integer[]} nums1\n# @param {Integer[]} nums2\n# @param {Integer} x\n# @return {Integer}\ndef minimum_time(nums1, nums2, x)\n    \nend", "scala": "object Solution {\n    def minimumTime(nums1: List[Int], nums2: List[Int], x: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn minimum_time(nums1: Vec<i32>, nums2: Vec<i32>, x: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (minimum-time nums1 nums2 x)\n  (-> (listof exact-integer?) (listof exact-integer?) exact-integer? exact-integer?)\n\n  )", "erlang": "-spec minimum_time(Nums1 :: [integer()], Nums2 :: [integer()], X :: integer()) -> integer().\nminimum_time(Nums1, Nums2, X) ->\n  .", "elixir": "defmodule Solution do\n  @spec minimum_time(nums1 :: [integer], nums2 :: [integer], x :: integer) :: integer\n  def minimum_time(nums1, nums2, x) do\n\n  end\nend"}}
{"id": "leetcode_2736", "url": "https://leetcode.com/problems/maximum-sum-queries/", "title": "Maximum Sum Queries", "description": "You are given two **0-indexed** integer arrays `nums1` and `nums2`, each of length `n`, and a **1-indexed 2D array** `queries` where `queries[i] = [xi, yi]`.\n\n\nFor the `ith` query, find the **maximum value** of `nums1[j] + nums2[j]` among all indices `j` `(0 <= j < n)`, where `nums1[j] >= xi` and `nums2[j] >= yi`, or **-1** if there is no `j` satisfying the constraints.\n\n\nReturn *an array* `answer` *where* `answer[i]` *is the answer to the* `ith` *query.*", "examples": ["**Input:** nums1 = [4,3,1,2], nums2 = [2,4,9,5], queries = [[4,1],[1,3],[2,5]]\n**Output:** [6,10,7]\n**Explanation:** \nFor the 1st query xi = 4\u00a0and\u00a0yi = 1, we can select index\u00a0j = 0\u00a0since\u00a0nums1[j] >= 4\u00a0and\u00a0nums2[j] >= 1. The sum\u00a0nums1[j] + nums2[j]\u00a0is 6, and we can show that 6 is the maximum we can obtain.\n\nFor the 2nd query xi = 1\u00a0and\u00a0yi = 3, we can select index\u00a0j = 2\u00a0since\u00a0nums1[j] >= 1\u00a0and\u00a0nums2[j] >= 3. The sum\u00a0nums1[j] + nums2[j]\u00a0is 10, and we can show that 10 is the maximum we can obtain. \n\nFor the 3rd query xi = 2\u00a0and\u00a0yi = 5, we can select index\u00a0j = 3\u00a0since\u00a0nums1[j] >= 2\u00a0and\u00a0nums2[j] >= 5. The sum\u00a0nums1[j] + nums2[j]\u00a0is 7, and we can show that 7 is the maximum we can obtain.\n\nTherefore, we return\u00a0[6,10,7].", "**Input:** nums1 = [3,2,5], nums2 = [2,3,4], queries = [[4,4],[3,2],[1,1]]\n**Output:** [9,9,9]\n**Explanation:** For this example, we can use index\u00a0j = 2\u00a0for all the queries since it satisfies the constraints for each query.", "**Input:** nums1 = [2,1], nums2 = [2,3], queries = [[3,3]]\n**Output:** [-1]\n**Explanation:** There is one query in this example with xi = 3 and yi = 3. For every index, j, either nums1[j] < xi or nums2[j] < yi. Hence, there is no solution."], "constraints": "**Constraints:**\n\n\n* `nums1.length == nums2.length`\n* `n ==\u00a0nums1.length`\n* `1 <= n <= 105`\n* `1 <= nums1[i], nums2[i] <= 109`\n* `1 <= queries.length <= 105`\n* `queries[i].length ==\u00a02`\n* `xi\u00a0== queries[i][1]`\n* `yi == queries[i][2]`\n* `1 <= xi, yi <= 109`", "difficulty": "Hard", "tags": ["Array", "Binary Search", "Stack", "Binary Indexed Tree", "Segment Tree", "Sorting", "Monotonic Stack"], "hints": ["Sort (x, y) tuples and queries by x-coordinate descending. Don\u2019t forget to index queries before sorting so that you can answer them in the correct order.", "Before answering a query (min_x, min_y), add all (x, y) pairs with x >= min_x to some data structure.", "Use a monotone descending map to store (y, x + y) pairs. A monotone map has ascending keys and descending values. When inserting a pair (y, x + y), remove all pairs (y', x' + y') with y' < y and x' + y' <= x + y.", "To find the insertion position use binary search (built-in in many languages).", "When querying for max (x + y) over y >= y', use binary search to find the first pair (y, x + y) with y >= y'. It will have the maximum value of x + y because the map has monotone descending values."], "templates": {"cpp": "class Solution {\npublic:\n    vector<int> maximumSumQueries(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\n        \n    }\n};", "java": "class Solution {\n    public int[] maximumSumQueries(int[] nums1, int[] nums2, int[][] queries) {\n        \n    }\n}", "python": "class Solution(object):\n    def maximumSumQueries(self, nums1, nums2, queries):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        ", "python3": "class Solution:\n    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n        ", "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* maximumSumQueries(int* nums1, int nums1Size, int* nums2, int nums2Size, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\n\n}", "csharp": "public class Solution {\n    public int[] MaximumSumQueries(int[] nums1, int[] nums2, int[][] queries) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @param {number[][]} queries\n * @return {number[]}\n */\nvar maximumSumQueries = function(nums1, nums2, queries) {\n    \n};", "typescript": "function maximumSumQueries(nums1: number[], nums2: number[], queries: number[][]): number[] {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums1\n     * @param Integer[] $nums2\n     * @param Integer[][] $queries\n     * @return Integer[]\n     */\n    function maximumSumQueries($nums1, $nums2, $queries) {\n        \n    }\n}", "swift": "class Solution {\n    func maximumSumQueries(_ nums1: [Int], _ nums2: [Int], _ queries: [[Int]]) -> [Int] {\n        \n    }\n}", "kotlin": "class Solution {\n    fun maximumSumQueries(nums1: IntArray, nums2: IntArray, queries: Array<IntArray>): IntArray {\n        \n    }\n}", "dart": "class Solution {\n  List<int> maximumSumQueries(List<int> nums1, List<int> nums2, List<List<int>> queries) {\n\n  }\n}", "golang": "func maximumSumQueries(nums1 []int, nums2 []int, queries [][]int) []int {\n    \n}", "ruby": "# @param {Integer[]} nums1\n# @param {Integer[]} nums2\n# @param {Integer[][]} queries\n# @return {Integer[]}\ndef maximum_sum_queries(nums1, nums2, queries)\n    \nend", "scala": "object Solution {\n    def maximumSumQueries(nums1: Array[Int], nums2: Array[Int], queries: Array[Array[Int]]): Array[Int] = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn maximum_sum_queries(nums1: Vec<i32>, nums2: Vec<i32>, queries: Vec<Vec<i32>>) -> Vec<i32> {\n        \n    }\n}", "racket": "(define/contract (maximum-sum-queries nums1 nums2 queries)\n  (-> (listof exact-integer?) (listof exact-integer?) (listof (listof exact-integer?)) (listof exact-integer?))\n\n  )", "erlang": "-spec maximum_sum_queries(Nums1 :: [integer()], Nums2 :: [integer()], Queries :: [[integer()]]) -> [integer()].\nmaximum_sum_queries(Nums1, Nums2, Queries) ->\n  .", "elixir": "defmodule Solution do\n  @spec maximum_sum_queries(nums1 :: [integer], nums2 :: [integer], queries :: [[integer]]) :: [integer]\n  def maximum_sum_queries(nums1, nums2, queries) do\n\n  end\nend"}}
{"id": "leetcode_2940", "url": "https://leetcode.com/problems/find-building-where-alice-and-bob-can-meet/", "title": "Find Building Where Alice and Bob Can Meet", "description": "You are given a **0-indexed** array `heights` of positive integers, where `heights[i]` represents the height of the `ith` building.\n\n\nIf a person is in building `i`, they can move to any other building `j` if and only if `i < j` and `heights[i] < heights[j]`.\n\n\nYou are also given another array `queries` where `queries[i] = [ai, bi]`. On the `ith` query, Alice is in building `ai` while Bob is in building `bi`.\n\n\nReturn *an array* `ans` *where* `ans[i]` *is **the index of the leftmost building** where Alice and Bob can meet on the* `ith` *query*. *If Alice and Bob cannot move to a common building on query* `i`, *set* `ans[i]` *to* `-1`.", "examples": ["**Input:** heights = [6,4,8,5,2,7], queries = [[0,1],[0,3],[2,4],[3,4],[2,2]]\n**Output:** [2,5,-1,5,2]\n**Explanation:** In the first query, Alice and Bob can move to building 2 since heights[0] < heights[2] and heights[1] < heights[2]. \nIn the second query, Alice and Bob can move to building 5 since heights[0] < heights[5] and heights[3] < heights[5]. \nIn the third query, Alice cannot meet Bob since Alice cannot move to any other building.\nIn the fourth query, Alice and Bob can move to building 5 since heights[3] < heights[5] and heights[4] < heights[5].\nIn the fifth query, Alice and Bob are already in the same building.  \nFor ans[i] != -1, It can be shown that ans[i] is the leftmost building where Alice and Bob can meet.\nFor ans[i] == -1, It can be shown that there is no building where Alice and Bob can meet.", "**Input:** heights = [5,3,8,2,6,1,4,6], queries = [[0,7],[3,5],[5,2],[3,0],[1,6]]\n**Output:** [7,6,-1,4,6]\n**Explanation:** In the first query, Alice can directly move to Bob's building since heights[0] < heights[7].\nIn the second query, Alice and Bob can move to building 6 since heights[3] < heights[6] and heights[5] < heights[6].\nIn the third query, Alice cannot meet Bob since Bob cannot move to any other building.\nIn the fourth query, Alice and Bob can move to building 4 since heights[3] < heights[4] and heights[0] < heights[4].\nIn the fifth query, Alice can directly move to Bob's building since heights[1] < heights[6].\nFor ans[i] != -1, It can be shown that ans[i] is the leftmost building where Alice and Bob can meet.\nFor ans[i] == -1, It can be shown that there is no building where Alice and Bob can meet."], "constraints": "**Constraints:**\n\n\n* `1 <= heights.length <= 5 * 104`\n* `1 <= heights[i] <= 109`\n* `1 <= queries.length <= 5 * 104`\n* `queries[i] = [ai, bi]`\n* `0 <= ai, bi <= heights.length - 1`", "difficulty": "Hard", "tags": ["Array", "Binary Search", "Stack", "Binary Indexed Tree", "Segment Tree", "Heap (Priority Queue)", "Monotonic Stack"], "hints": ["For each query <code>[x, y]</code>, if <code>x > y</code>, swap <code>x</code> and <code>y</code>. Now, we can assume that <code>x <= y</code>.", "For each query <code>[x, y]</code>, if <code>x == y</code> or <code>heights[x] < heights[y]</code>, then the answer is <code>y</code> since <code>x \u2264 y</code>.", "Otherwise, we need to find the smallest index <code>t</code> such that <code>y < t</code> and <code>heights[x] < heights[t]</code>. Note that <code>heights[y] <= heights[x]</code>, so <code>heights[x] < heights[t]</code> is a sufficient condition.", "To find index <code>t</code> for each query, sort the queries in descending order of <code>y</code>. Iterate over the queries while maintaining a monotonic stack which we can binary search over to find index <code>t</code>."], "templates": {"cpp": "class Solution {\npublic:\n    vector<int> leftmostBuildingQueries(vector<int>& heights, vector<vector<int>>& queries) {\n        \n    }\n};", "java": "class Solution {\n    public int[] leftmostBuildingQueries(int[] heights, int[][] queries) {\n        \n    }\n}", "python": "class Solution(object):\n    def leftmostBuildingQueries(self, heights, queries):\n        \"\"\"\n        :type heights: List[int]\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        ", "python3": "class Solution:\n    def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:\n        ", "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* leftmostBuildingQueries(int* heights, int heightsSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize) {\n    \n}", "csharp": "public class Solution {\n    public int[] LeftmostBuildingQueries(int[] heights, int[][] queries) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} heights\n * @param {number[][]} queries\n * @return {number[]}\n */\nvar leftmostBuildingQueries = function(heights, queries) {\n    \n};", "typescript": "function leftmostBuildingQueries(heights: number[], queries: number[][]): number[] {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $heights\n     * @param Integer[][] $queries\n     * @return Integer[]\n     */\n    function leftmostBuildingQueries($heights, $queries) {\n        \n    }\n}", "swift": "class Solution {\n    func leftmostBuildingQueries(_ heights: [Int], _ queries: [[Int]]) -> [Int] {\n        \n    }\n}", "kotlin": "class Solution {\n    fun leftmostBuildingQueries(heights: IntArray, queries: Array<IntArray>): IntArray {\n        \n    }\n}", "dart": "class Solution {\n  List<int> leftmostBuildingQueries(List<int> heights, List<List<int>> queries) {\n    \n  }\n}", "golang": "func leftmostBuildingQueries(heights []int, queries [][]int) []int {\n    \n}", "ruby": "# @param {Integer[]} heights\n# @param {Integer[][]} queries\n# @return {Integer[]}\ndef leftmost_building_queries(heights, queries)\n    \nend", "scala": "object Solution {\n    def leftmostBuildingQueries(heights: Array[Int], queries: Array[Array[Int]]): Array[Int] = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn leftmost_building_queries(heights: Vec<i32>, queries: Vec<Vec<i32>>) -> Vec<i32> {\n        \n    }\n}", "racket": "(define/contract (leftmost-building-queries heights queries)\n  (-> (listof exact-integer?) (listof (listof exact-integer?)) (listof exact-integer?))\n  )", "erlang": "-spec leftmost_building_queries(Heights :: [integer()], Queries :: [[integer()]]) -> [integer()].\nleftmost_building_queries(Heights, Queries) ->\n  .", "elixir": "defmodule Solution do\n  @spec leftmost_building_queries(heights :: [integer], queries :: [[integer]]) :: [integer]\n  def leftmost_building_queries(heights, queries) do\n    \n  end\nend"}}
{"id": "leetcode_2813", "url": "https://leetcode.com/problems/maximum-elegance-of-a-k-length-subsequence/", "title": "Maximum Elegance of a K-Length Subsequence", "description": "You are given a **0-indexed** 2D integer array `items` of length `n` and an integer `k`.\n\n\n`items[i] = [profiti, categoryi]`, where `profiti` and `categoryi` denote the profit and category of the `ith` item respectively.\n\n\nLet's define the **elegance** of a **subsequence** of `items` as `total_profit + distinct_categories2`, where `total_profit` is the sum of all profits in the subsequence, and `distinct_categories` is the number of **distinct** categories from all the categories in the selected subsequence.\n\n\nYour task is to find the **maximum elegance** from all subsequences of size `k` in `items`.\n\n\nReturn *an integer denoting the maximum elegance of a subsequence of* `items` *with size exactly* `k`.\n\n\n**Note:** A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.", "examples": ["**Input:** items = [[3,2],[5,1],[10,1]], k = 2\n**Output:** 17\n**Explanation:** In this example, we have to select a subsequence of size 2.\nWe can select items[0] = [3,2] and items[2] = [10,1].\nThe total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].\nHence, the elegance is 13 + 22 = 17, and we can show that it is the maximum achievable elegance.", "**Input:** items = [[3,1],[3,1],[2,2],[5,3]], k = 3\n**Output:** 19\n**Explanation:** In this example, we have to select a subsequence of size 3. \nWe can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. \nThe total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. \nHence, the elegance is 10 + 32 = 19, and we can show that it is the maximum achievable elegance.", "**Input:** items = [[1,1],[2,1],[3,1]], k = 3\n**Output:** 7\n**Explanation:** In this example, we have to select a subsequence of size 3. \nWe should select all the items. \nThe total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. \nHence, the maximum elegance is 6 + 12 = 7."], "constraints": "**Constraints:**\n\n\n* `1 <= items.length == n <= 105`\n* `items[i].length == 2`\n* `items[i][0] == profiti`\n* `items[i][1] == categoryi`\n* `1 <= profiti <= 109`\n* `1 <= categoryi <= n`\n* `1 <= k <= n`", "difficulty": "Hard", "tags": ["Array", "Hash Table", "Greedy", "Sorting", "Heap (Priority Queue)"], "hints": ["<div class=\"_1l1MA\">Greedy algorithm.</div>", "<div class=\"_1l1MA\">Sort items in non-increasing order of profits.</div>", "<div class=\"_1l1MA\">Select the first <code>k</code> items (the top <code>k</code> most profitable items). Keep track of the items as the candidate set.</div>", "<div class=\"_1l1MA\">For the remaining <code>n - k</code> items sorted in non-increasing order of profits, try replacing an item in the candidate set using the current item.</div>", "<div class=\"_1l1MA\">The replacing item should add a new category to the candidate set and should remove the item with the minimum profit that occurs more than once in the candidate set.</div>"], "templates": {"cpp": "class Solution {\npublic:\n    long long findMaximumElegance(vector<vector<int>>& items, int k) {\n        \n    }\n};", "java": "class Solution {\n    public long findMaximumElegance(int[][] items, int k) {\n        \n    }\n}", "python": "class Solution(object):\n    def findMaximumElegance(self, items, k):\n        \"\"\"\n        :type items: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        ", "c": "long long findMaximumElegance(int** items, int itemsSize, int* itemsColSize, int k){\n\n}", "csharp": "public class Solution {\n    public long FindMaximumElegance(int[][] items, int k) {\n        \n    }\n}", "javascript": "/**\n * @param {number[][]} items\n * @param {number} k\n * @return {number}\n */\nvar findMaximumElegance = function(items, k) {\n    \n};", "typescript": "function findMaximumElegance(items: number[][], k: number): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[][] $items\n     * @param Integer $k\n     * @return Integer\n     */\n    function findMaximumElegance($items, $k) {\n        \n    }\n}", "swift": "class Solution {\n    func findMaximumElegance(_ items: [[Int]], _ k: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun findMaximumElegance(items: Array<IntArray>, k: Int): Long {\n        \n    }\n}", "dart": "class Solution {\n  int findMaximumElegance(List<List<int>> items, int k) {\n\n  }\n}", "golang": "func findMaximumElegance(items [][]int, k int) int64 {\n    \n}", "ruby": "# @param {Integer[][]} items\n# @param {Integer} k\n# @return {Integer}\ndef find_maximum_elegance(items, k)\n    \nend", "scala": "object Solution {\n    def findMaximumElegance(items: Array[Array[Int]], k: Int): Long = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn find_maximum_elegance(items: Vec<Vec<i32>>, k: i32) -> i64 {\n        \n    }\n}", "racket": "(define/contract (find-maximum-elegance items k)\n  (-> (listof (listof exact-integer?)) exact-integer? exact-integer?)\n\n  )", "erlang": "-spec find_maximum_elegance(Items :: [[integer()]], K :: integer()) -> integer().\nfind_maximum_elegance(Items, K) ->\n  .", "elixir": "defmodule Solution do\n  @spec find_maximum_elegance(items :: [[integer]], k :: integer) :: integer\n  def find_maximum_elegance(items, k) do\n\n  end\nend"}}
{"id": "leetcode_2916", "url": "https://leetcode.com/problems/subarrays-distinct-element-sum-of-squares-ii/", "title": "Subarrays Distinct Element Sum of Squares II", "description": "You are given a **0-indexed** integer array `nums`.\n\n\nThe **distinct count** of a subarray of `nums` is defined as:\n\n\n* Let `nums[i..j]` be a subarray of `nums` consisting of all the indices from `i` to `j` such that `0 <= i <= j < nums.length`. Then the number of distinct values in `nums[i..j]` is called the distinct count of `nums[i..j]`.\n\n\nReturn *the sum of the **squares** of **distinct counts** of all subarrays of* `nums`.\n\n\nSince the answer may be very large, return it **modulo** `109 + 7`.\n\n\nA subarray is a contiguous **non-empty** sequence of elements within an array.", "examples": ["**Input:** nums = [1,2,1]\n**Output:** 15\n**Explanation:** Six possible subarrays are:\n[1]: 1 distinct value\n[2]: 1 distinct value\n[1]: 1 distinct value\n[1,2]: 2 distinct values\n[2,1]: 2 distinct values\n[1,2,1]: 2 distinct values\nThe sum of the squares of the distinct counts in all subarrays is equal to 12 + 12 + 12 + 22 + 22 + 22 = 15.", "**Input:** nums = [2,2]\n**Output:** 3\n**Explanation:** Three possible subarrays are:\n[2]: 1 distinct value\n[2]: 1 distinct value\n[2,2]: 1 distinct value\nThe sum of the squares of the distinct counts in all subarrays is equal to 12 + 12 + 12 = 3."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `1 <= nums[i] <= 105`", "difficulty": "Hard", "tags": ["Array", "Dynamic Programming", "Binary Indexed Tree", "Segment Tree"], "hints": ["Consider the sum of the count of distinct values of subarrays ending with index <code>i</code>, let\u2019s call it <code>sum</code>. Now if you need the sum of all subarrays ending with index <code>i + 1</code> think how it can be related to <code>sum</code> and what extra will be needed to add to this.", "You can find that extra sum using the segment tree."], "templates": {"cpp": "class Solution {\npublic:\n    int sumCounts(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public int sumCounts(int[] nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def sumCounts(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n        ", "c": "int sumCounts(int* nums, int numsSize) {\n    \n}", "csharp": "public class Solution {\n    public int SumCounts(int[] nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar sumCounts = function(nums) {\n    \n};", "typescript": "function sumCounts(nums: number[]): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function sumCounts($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func sumCounts(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun sumCounts(nums: IntArray): Int {\n        \n    }\n}", "dart": "class Solution {\n  int sumCounts(List<int> nums) {\n    \n  }\n}", "golang": "func sumCounts(nums []int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef sum_counts(nums)\n    \nend", "scala": "object Solution {\n    def sumCounts(nums: Array[Int]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn sum_counts(nums: Vec<i32>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (sum-counts nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )", "erlang": "-spec sum_counts(Nums :: [integer()]) -> integer().\nsum_counts(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec sum_counts(nums :: [integer]) :: integer\n  def sum_counts(nums) do\n    \n  end\nend"}}
{"id": "leetcode_2977", "url": "https://leetcode.com/problems/minimum-cost-to-convert-string-ii/", "title": "Minimum Cost to Convert String II", "description": "You are given two **0-indexed** strings `source` and `target`, both of length `n` and consisting of **lowercase** English characters. You are also given two **0-indexed** string arrays `original` and `changed`, and an integer array `cost`, where `cost[i]` represents the cost of converting the string `original[i]` to the string `changed[i]`.\n\n\nYou start with the string `source`. In one operation, you can pick a **substring** `x` from the string, and change it to `y` at a cost of `z` **if** there exists **any** index `j` such that `cost[j] == z`, `original[j] == x`, and `changed[j] == y`. You are allowed to do **any** number of operations, but any pair of operations must satisfy **either** of these two conditions:\n\n\n* The substrings picked in the operations are `source[a..b]` and `source[c..d]` with either `b < c` **or** `d < a`. In other words, the indices picked in both operations are **disjoint**.\n* The substrings picked in the operations are `source[a..b]` and `source[c..d]` with `a == c` **and** `b == d`. In other words, the indices picked in both operations are **identical**.\n\n\nReturn *the **minimum** cost to convert the string* `source` *to the string* `target` *using **any** number of operations*. *If it is impossible to convert* `source` *to* `target`, *return* `-1`.\n\n\n**Note** that there may exist indices `i`, `j` such that `original[j] == original[i]` and `changed[j] == changed[i]`.", "examples": ["**Input:** source = \"abcd\", target = \"acbe\", original = [\"a\",\"b\",\"c\",\"c\",\"e\",\"d\"], changed = [\"b\",\"c\",\"b\",\"e\",\"b\",\"e\"], cost = [2,5,5,1,2,20]\n**Output:** 28\n**Explanation:** To convert \"abcd\" to \"acbe\", do the following operations:\n- Change substring source[1..1] from \"b\" to \"c\" at a cost of 5.\n- Change substring source[2..2] from \"c\" to \"e\" at a cost of 1.\n- Change substring source[2..2] from \"e\" to \"b\" at a cost of 2.\n- Change substring source[3..3] from \"d\" to \"e\" at a cost of 20.\nThe total cost incurred is 5 + 1 + 2 + 20 = 28. \nIt can be shown that this is the minimum possible cost.", "**Input:** source = \"abcdefgh\", target = \"acdeeghh\", original = [\"bcd\",\"fgh\",\"thh\"], changed = [\"cde\",\"thh\",\"ghh\"], cost = [1,3,5]\n**Output:** 9\n**Explanation:** To convert \"abcdefgh\" to \"acdeeghh\", do the following operations:\n- Change substring source[1..3] from \"bcd\" to \"cde\" at a cost of 1.\n- Change substring source[5..7] from \"fgh\" to \"thh\" at a cost of 3. We can do this operation because indices [5,7] are disjoint with indices picked in the first operation.\n- Change substring source[5..7] from \"thh\" to \"ghh\" at a cost of 5. We can do this operation because indices [5,7] are disjoint with indices picked in the first operation, and identical with indices picked in the second operation.\nThe total cost incurred is 1 + 3 + 5 = 9.\nIt can be shown that this is the minimum possible cost.", "**Input:** source = \"abcdefgh\", target = \"addddddd\", original = [\"bcd\",\"defgh\"], changed = [\"ddd\",\"ddddd\"], cost = [100,1578]\n**Output:** -1\n**Explanation:** It is impossible to convert \"abcdefgh\" to \"addddddd\".\nIf you select substring source[1..3] as the first operation to change \"abcdefgh\" to \"adddefgh\", you cannot select substring source[3..7] as the second operation because it has a common index, 3, with the first operation.\nIf you select substring source[3..7] as the first operation to change \"abcdefgh\" to \"abcddddd\", you cannot select substring source[1..3] as the second operation because it has a common index, 3, with the first operation."], "constraints": "**Constraints:**\n\n\n* `1 <= source.length == target.length <= 1000`\n* `source`, `target` consist only of lowercase English characters.\n* `1 <= cost.length == original.length == changed.length <= 100`\n* `1 <= original[i].length == changed[i].length <= source.length`\n* `original[i]`, `changed[i]` consist only of lowercase English characters.\n* `original[i] != changed[i]`\n* `1 <= cost[i] <= 106`", "difficulty": "Hard", "tags": [], "hints": ["Give each unique string in <code>original</code> and <code>changed</code> arrays a unique id. There are at most <code>2 * m</code> unique strings in total where <code>m</code> is the length of the arrays. We can put them into a hash map to assign ids.", "We can pre-compute the smallest costs between all pairs of unique strings using Floyd Warshall algorithm in <code>O(m ^ 3)</code> time complexity.", "Let <code>dp[i]</code> be the smallest cost to change the first <code>i</code> characters (prefix) of <code>source</code> into <code>target</code>, leaving the suffix untouched.\r\nWe have <code>dp[0] = 0</code>.\r\n<code>dp[i] = min(\r\ndp[i - 1] if (source[i - 1] == target[i - 1]),\r\ndp[j-1] + cost[x][y] where x is the id of source[j..(i - 1)] and y is the id of target e[j..(i - 1)])\r\n)</code>.\r\nIf neither of the two conditions is satisfied, <code>dp[i] = infinity</code>.", "We can use Trie to check for the second condition in <code>O(1)</code>.", "The answer is <code>dp[n]</code> where <code>n</code> is <code>source.length</code>."], "templates": {"cpp": "class Solution {\npublic:\n    long long minimumCost(string source, string target, vector<string>& original, vector<string>& changed, vector<int>& cost) {\n        \n    }\n};", "java": "class Solution {\n    public long minimumCost(String source, String target, String[] original, String[] changed, int[] cost) {\n        \n    }\n}", "python": "class Solution(object):\n    def minimumCost(self, source, target, original, changed, cost):\n        \"\"\"\n        :type source: str\n        :type target: str\n        :type original: List[str]\n        :type changed: List[str]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        ", "c": "long long minimumCost(char* source, char* target, char** original, int originalSize, char** changed, int changedSize, int* cost, int costSize) {\n    \n}", "csharp": "public class Solution {\n    public long MinimumCost(string source, string target, string[] original, string[] changed, int[] cost) {\n        \n    }\n}", "javascript": "/**\n * @param {string} source\n * @param {string} target\n * @param {string[]} original\n * @param {string[]} changed\n * @param {number[]} cost\n * @return {number}\n */\nvar minimumCost = function(source, target, original, changed, cost) {\n    \n};", "typescript": "function minimumCost(source: string, target: string, original: string[], changed: string[], cost: number[]): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param String $source\n     * @param String $target\n     * @param String[] $original\n     * @param String[] $changed\n     * @param Integer[] $cost\n     * @return Integer\n     */\n    function minimumCost($source, $target, $original, $changed, $cost) {\n        \n    }\n}", "swift": "class Solution {\n    func minimumCost(_ source: String, _ target: String, _ original: [String], _ changed: [String], _ cost: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun minimumCost(source: String, target: String, original: Array<String>, changed: Array<String>, cost: IntArray): Long {\n        \n    }\n}", "dart": "class Solution {\n  int minimumCost(String source, String target, List<String> original, List<String> changed, List<int> cost) {\n    \n  }\n}", "golang": "func minimumCost(source string, target string, original []string, changed []string, cost []int) int64 {\n    \n}", "ruby": "# @param {String} source\n# @param {String} target\n# @param {String[]} original\n# @param {String[]} changed\n# @param {Integer[]} cost\n# @return {Integer}\ndef minimum_cost(source, target, original, changed, cost)\n    \nend", "scala": "object Solution {\n    def minimumCost(source: String, target: String, original: Array[String], changed: Array[String], cost: Array[Int]): Long = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn minimum_cost(source: String, target: String, original: Vec<String>, changed: Vec<String>, cost: Vec<i32>) -> i64 {\n        \n    }\n}", "racket": "(define/contract (minimum-cost source target original changed cost)\n  (-> string? string? (listof string?) (listof string?) (listof exact-integer?) exact-integer?)\n  )", "erlang": "-spec minimum_cost(Source :: unicode:unicode_binary(), Target :: unicode:unicode_binary(), Original :: [unicode:unicode_binary()], Changed :: [unicode:unicode_binary()], Cost :: [integer()]) -> integer().\nminimum_cost(Source, Target, Original, Changed, Cost) ->\n  .", "elixir": "defmodule Solution do\n  @spec minimum_cost(source :: String.t, target :: String.t, original :: [String.t], changed :: [String.t], cost :: [integer]) :: integer\n  def minimum_cost(source, target, original, changed, cost) do\n    \n  end\nend"}}
{"id": "leetcode_2897", "url": "https://leetcode.com/problems/apply-operations-on-array-to-maximize-sum-of-squares/", "title": "Apply Operations on Array to Maximize Sum of Squares", "description": "You are given a **0-indexed** integer array `nums` and a **positive** integer `k`.\n\n\nYou can do the following operation on the array **any** number of times:\n\n\n* Choose any two distinct indices `i` and `j` and **simultaneously** update the values of `nums[i]` to `(nums[i] AND nums[j])` and `nums[j]` to `(nums[i] OR nums[j])`. Here, `OR` denotes the bitwise `OR` operation, and `AND` denotes the bitwise `AND` operation.\n\n\nYou have to choose `k` elements from the final array and calculate the sum of their **squares**.\n\n\nReturn *the **maximum** sum of squares you can achieve*.\n\n\nSince the answer can be very large, return it **modulo** `109 + 7`.", "examples": ["**Input:** nums = [2,6,5,8], k = 2\n**Output:** 261\n**Explanation:** We can do the following operations on the array:\n- Choose i = 0 and j = 3, then change nums[0] to (2 AND 8) = 0 and nums[3] to (2 OR 8) = 10. The resulting array is nums = [0,6,5,10].\n- Choose i = 2 and j = 3, then change nums[2] to (5 AND 10) = 0 and nums[3] to (5 OR 10) = 15. The resulting array is nums = [0,6,0,15].\nWe can choose the elements 15 and 6 from the final array. The sum of squares is 152 + 62 = 261.\nIt can be shown that this is the maximum value we can get.", "**Input:** nums = [4,5,4,7], k = 3\n**Output:** 90\n**Explanation:** We do not need to apply any operations.\nWe can choose the elements 7, 5, and 4 with a sum of squares: 72 + 52 + 42 = 90.\nIt can be shown that this is the maximum value we can get."], "constraints": "**Constraints:**\n\n\n* `1 <= k <= nums.length <= 105`\n* `1 <= nums[i] <= 109`", "difficulty": "Hard", "tags": ["Array", "Hash Table", "Greedy", "Bit Manipulation"], "hints": ["The operation described only transfers some bits from one element to another in their binary representation.", "To have a maximum sum of squares, it is optimal to greedily make each number as big as possible."], "templates": {"cpp": "class Solution {\npublic:\n    int maxSum(vector<int>& nums, int k) {\n        \n    }\n};", "java": "class Solution {\n    public int maxSum(List<Integer> nums, int k) {\n        \n    }\n}", "python": "class Solution(object):\n    def maxSum(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def maxSum(self, nums: List[int], k: int) -> int:\n        ", "c": "int maxSum(int* nums, int numsSize, int k){\n\n}", "csharp": "public class Solution {\n    public int MaxSum(IList<int> nums, int k) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maxSum = function(nums, k) {\n    \n};", "typescript": "function maxSum(nums: number[], k: number): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer\n     */\n    function maxSum($nums, $k) {\n        \n    }\n}", "swift": "class Solution {\n    func maxSum(_ nums: [Int], _ k: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun maxSum(nums: List<Int>, k: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int maxSum(List<int> nums, int k) {\n\n  }\n}", "golang": "func maxSum(nums []int, k int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer}\ndef max_sum(nums, k)\n    \nend", "scala": "object Solution {\n    def maxSum(nums: List[Int], k: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn max_sum(nums: Vec<i32>, k: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (max-sum nums k)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n\n  )", "erlang": "-spec max_sum(Nums :: [integer()], K :: integer()) -> integer().\nmax_sum(Nums, K) ->\n  .", "elixir": "defmodule Solution do\n  @spec max_sum(nums :: [integer], k :: integer) :: integer\n  def max_sum(nums, k) do\n\n  end\nend"}}
{"id": "leetcode_2842", "url": "https://leetcode.com/problems/count-k-subsequences-of-a-string-with-maximum-beauty/", "title": "Count K-Subsequences of a String With Maximum Beauty", "description": "You are given a string `s` and an integer `k`.\n\n\nA **k-subsequence** is a **subsequence** of `s`, having length `k`, and all its characters are **unique**, **i.e**., every character occurs once.\n\n\nLet `f(c)` denote the number of times the character `c` occurs in `s`.\n\n\nThe **beauty** of a **k-subsequence** is the **sum** of `f(c)` for every character `c` in the k-subsequence.\n\n\nFor example, consider `s = \"abbbdd\"` and `k = 2`:\n\n\n* `f('a') = 1`, `f('b') = 3`, `f('d') = 2`\n* Some k-subsequences of `s` are:\n\t+ `\"**ab**bbdd\"` -> `\"ab\"` having a beauty of `f('a') + f('b') = 4`\n\t+ `\"**a**bbb**d**d\"` -> `\"ad\"` having a beauty of `f('a') + f('d') = 3`\n\t+ `\"a**b**bb**d**d\"` -> `\"bd\"` having a beauty of `f('b') + f('d') = 5`\n\n\nReturn *an integer denoting the number of k-subsequences* *whose **beauty** is the **maximum** among all **k-subsequences***. Since the answer may be too large, return it modulo `109 + 7`.\n\n\nA subsequence of a string is a new string formed from the original string by deleting some (possibly none) of the characters without disturbing the relative positions of the remaining characters.\n\n\n**Notes**\n\n\n* `f(c)` is the number of times a character `c` occurs in `s`, not a k-subsequence.\n* Two k-subsequences are considered different if one is formed by an index that is not present in the other. So, two k-subsequences may form the same string.", "examples": ["**Input:** s = \"bcca\", k = 2\n**Output:** 4\n**Explanation:** From s we have f('a') = 1, f('b') = 1, and f('c') = 2.\nThe k-subsequences of s are: \n**bc**ca having a beauty of f('b') + f('c') = 3 \n**b**c**c**a having a beauty of f('b') + f('c') = 3 \n**b**cc**a** having a beauty of f('b') + f('a') = 2 \nb**c**c**a**having a beauty of f('c') + f('a') = 3\nbc**ca** having a beauty of f('c') + f('a') = 3 \nThere are 4 k-subsequences that have the maximum beauty, 3. \nHence, the answer is 4.", "**Input:** s = \"abbcd\", k = 4\n**Output:** 2\n**Explanation:** From s we have f('a') = 1, f('b') = 2, f('c') = 1, and f('d') = 1. \nThe k-subsequences of s are: \n**ab**b**cd** having a beauty of f('a') + f('b') + f('c') + f('d') = 5\n**a**b**bcd** having a beauty of f('a') + f('b') + f('c') + f('d') = 5 \nThere are 2 k-subsequences that have the maximum beauty, 5. \nHence, the answer is 2."], "constraints": "**Constraints:**\n\n\n* `1 <= s.length <= 2 * 105`\n* `1 <= k <= s.length`\n* `s` consists only of lowercase English letters.", "difficulty": "Hard", "tags": ["Hash Table", "Math", "String", "Greedy", "Combinatorics"], "hints": ["Since every character appears once in a k-subsequence, we can solve the following problem first: Find the total number of ways to select <code>k</code> characters such that the sum of their frequencies is maximum.", "An obvious case to eliminate is if <code>k</code> is greater than the number of distinct characters in <code>s</code>, then the answer is <code>0</code>.", "We are now interested in the top frequencies among the characters. Using a map data structure, let <code>cnt[x]</code> denote the number of characters that have a frequency of <code>x</code>.", "Starting from the maximum value <code>x</code> in <code>cnt</code>. Let <code>i = min(k, cnt[x])</code> we add to our result <code> <sup>cnt[x]</sup>C<sub>i</sub> * x<sup>i</sup></code> representing the number of ways to select <code>i</code> characters from all characters with frequency <code>x</code>, multiplied by the number of ways to choose each individual character. Subtract <code>i</code> from <code>k</code> and continue downwards to the next maximum value.", "Powers, combinations, and additions should be done modulo <code>10<sup>9</sup> + 7</code>."], "templates": {"cpp": "class Solution {\npublic:\n    int countKSubsequencesWithMaxBeauty(string s, int k) {\n        \n    }\n};", "java": "class Solution {\n    public int countKSubsequencesWithMaxBeauty(String s, int k) {\n        \n    }\n}", "python": "class Solution(object):\n    def countKSubsequencesWithMaxBeauty(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def countKSubsequencesWithMaxBeauty(self, s: str, k: int) -> int:\n        ", "c": "int countKSubsequencesWithMaxBeauty(char* s, int k){\n\n}", "csharp": "public class Solution {\n    public int CountKSubsequencesWithMaxBeauty(string s, int k) {\n        \n    }\n}", "javascript": "/**\n * @param {string} s\n * @param {number} k\n * @return {number}\n */\nvar countKSubsequencesWithMaxBeauty = function(s, k) {\n    \n};", "typescript": "function countKSubsequencesWithMaxBeauty(s: string, k: number): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @param Integer $k\n     * @return Integer\n     */\n    function countKSubsequencesWithMaxBeauty($s, $k) {\n        \n    }\n}", "swift": "class Solution {\n    func countKSubsequencesWithMaxBeauty(_ s: String, _ k: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun countKSubsequencesWithMaxBeauty(s: String, k: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int countKSubsequencesWithMaxBeauty(String s, int k) {\n\n  }\n}", "golang": "func countKSubsequencesWithMaxBeauty(s string, k int) int {\n    \n}", "ruby": "# @param {String} s\n# @param {Integer} k\n# @return {Integer}\ndef count_k_subsequences_with_max_beauty(s, k)\n    \nend", "scala": "object Solution {\n    def countKSubsequencesWithMaxBeauty(s: String, k: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn count_k_subsequences_with_max_beauty(s: String, k: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (count-k-subsequences-with-max-beauty s k)\n  (-> string? exact-integer? exact-integer?)\n\n  )", "erlang": "-spec count_k_subsequences_with_max_beauty(S :: unicode:unicode_binary(), K :: integer()) -> integer().\ncount_k_subsequences_with_max_beauty(S, K) ->\n  .", "elixir": "defmodule Solution do\n  @spec count_k_subsequences_with_max_beauty(s :: String.t, k :: integer) :: integer\n  def count_k_subsequences_with_max_beauty(s, k) do\n\n  end\nend"}}
{"id": "leetcode_2835", "url": "https://leetcode.com/problems/minimum-operations-to-form-subsequence-with-target-sum/", "title": "Minimum Operations to Form Subsequence With Target Sum", "description": "You are given a **0-indexed** array `nums` consisting of **non-negative** powers of `2`, and an integer `target`.\n\n\nIn one operation, you must apply the following changes to the array:\n\n\n* Choose any element of the array `nums[i]` such that `nums[i] > 1`.\n* Remove `nums[i]` from the array.\n* Add **two** occurrences of `nums[i] / 2` to the **end** of `nums`.\n\n\nReturn the ***minimum number of operations** you need to perform so that* `nums` *contains a **subsequence** whose elements sum to* `target`. If it is impossible to obtain such a subsequence, return `-1`.\n\n\nA **subsequence** is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.", "examples": ["**Input:** nums = [1,2,8], target = 7\n**Output:** 1\n**Explanation:** In the first operation, we choose element nums[2]. The array becomes equal to nums = [1,2,4,4].\nAt this stage, nums contains the subsequence [1,2,4] which sums up to 7.\nIt can be shown that there is no shorter sequence of operations that results in a subsequnce that sums up to 7.", "**Input:** nums = [1,32,1,2], target = 12\n**Output:** 2\n**Explanation:** In the first operation, we choose element nums[1]. The array becomes equal to nums = [1,1,2,16,16].\nIn the second operation, we choose element nums[3]. The array becomes equal to nums = [1,1,2,16,8,8]\nAt this stage, nums contains the subsequence [1,1,2,8] which sums up to 12.\nIt can be shown that there is no shorter sequence of operations that results in a subsequence that sums up to 12.", "**Input:** nums = [1,32,1], target = 35\n**Output:** -1\n**Explanation:** It can be shown that no sequence of operations results in a subsequence that sums up to 35."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 1000`\n* `1 <= nums[i] <= 230`\n* `nums` consists only of non-negative powers of two.\n* `1 <= target < 231`", "difficulty": "Hard", "tags": ["Array", "Greedy", "Bit Manipulation"], "hints": ["<div class=\"_1l1MA\">if <code>target > sum(nums[i]) </code>, return <code>-1</code>. Otherwise, an answer exists</div>", "<div class=\"_1l1MA\">Solve the problem for each set bit of <code>target</code>, independently, from least significant to most significant bit. </div>", "<div class=\"_1l1MA\">For each set <code>bit</code> of <code>target</code> from least to most significant, let <code>X = sum(nums[i])</code> for <code>nums[i] <= 2^bit</code>.</div>", "<div class=\"_1l1MA\">\r\nif <code>X >= 2^bit</code>, repeatedly select the maximum <code>nums[i]</code> such that <code>nums[i]<=2^bit</code> that has not been selected yet, until the sum of selected elements equals <code>2^bit</code>. The selected <code>nums[i]</code> will be part of the subsequence whose elements sum to target, so those elements can not be selected again.\r\n</div>", "<div class=\"_1l1MA\">Otherwise, select the smallest <code>nums[i]</code> such that <code>nums[i] > 2^bit</code>, delete <code>nums[i]</code> and add two occurences of <code>nums[i]/2</code>. Without moving to the next <code>bit</code>, go back to the step in hint 3.</div>"], "templates": {"cpp": "class Solution {\npublic:\n    int minOperations(vector<int>& nums, int target) {\n        \n    }\n};", "java": "class Solution {\n    public int minOperations(List<Integer> nums, int target) {\n        \n    }\n}", "python": "class Solution(object):\n    def minOperations(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def minOperations(self, nums: List[int], target: int) -> int:\n        ", "c": "int minOperations(int* nums, int numsSize, int target){\n\n}", "csharp": "public class Solution {\n    public int MinOperations(IList<int> nums, int target) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar minOperations = function(nums, target) {\n    \n};", "typescript": "function minOperations(nums: number[], target: number): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $target\n     * @return Integer\n     */\n    function minOperations($nums, $target) {\n        \n    }\n}", "swift": "class Solution {\n    func minOperations(_ nums: [Int], _ target: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun minOperations(nums: List<Int>, target: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int minOperations(List<int> nums, int target) {\n\n  }\n}", "golang": "func minOperations(nums []int, target int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @param {Integer} target\n# @return {Integer}\ndef min_operations(nums, target)\n    \nend", "scala": "object Solution {\n    def minOperations(nums: List[Int], target: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn min_operations(nums: Vec<i32>, target: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (min-operations nums target)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n\n  )", "erlang": "-spec min_operations(Nums :: [integer()], Target :: integer()) -> integer().\nmin_operations(Nums, Target) ->\n  .", "elixir": "defmodule Solution do\n  @spec min_operations(nums :: [integer], target :: integer) :: integer\n  def min_operations(nums, target) do\n\n  end\nend"}}
{"id": "leetcode_2862", "url": "https://leetcode.com/problems/maximum-element-sum-of-a-complete-subset-of-indices/", "title": "Maximum Element-Sum of a Complete Subset of Indices", "description": "You are given a **1****-indexed** array `nums` of `n` integers.\n\n\nA set of numbers is **complete** if the product of every pair of its elements is a perfect square.\n\n\nFor a subset of the indices set `{1, 2, ..., n}` represented as `{i1, i2, ..., ik}`, we define its **element-sum** as: `nums[i1] + nums[i2] + ... + nums[ik]`.\n\n\nReturn *the **maximum element-sum** of a **complete** subset of the indices set* `{1, 2, ..., n}`.\n\n\nA perfect square is a number that can be expressed as the product of an integer by itself.", "examples": ["**Input:** nums = [8,7,3,5,7,2,4,9]\n**Output:** 16\n**Explanation:** Apart from the subsets consisting of a single index, there are two other complete subsets of indices: {1,4} and {2,8}.\nThe sum of the elements corresponding to indices 1 and 4 is equal to nums[1] + nums[4] = 8 + 5 = 13.\nThe sum of the elements corresponding to indices 2 and 8 is equal to nums[2] + nums[8] = 7 + 9 = 16.\nHence, the maximum element-sum of a complete subset of indices is 16.", "**Input:** nums = [5,10,3,10,1,13,7,9,4]\n**Output:** 19\n**Explanation:** Apart from the subsets consisting of a single index, there are four other complete subsets of indices: {1,4}, {1,9}, {2,8}, {4,9}, and {1,4,9}.\nThe sum of the elements corresponding to indices 1 and 4 is equal to nums[1] + nums[4] = 5 + 10 = 15.\nThe sum of the elements corresponding to indices 1 and 9 is equal to nums[1] + nums[9] = 5 + 4 = 9.\nThe sum of the elements corresponding to indices 2 and 8 is equal to nums[2] + nums[8] = 10 + 9 = 19.\nThe sum of the elements corresponding to indices 4 and 9 is equal to nums[4] + nums[9] = 10 + 4 = 14.\nThe sum of the elements corresponding to indices 1, 4, and 9 is equal to nums[1] + nums[4] + nums[9] = 5 + 10 + 4 = 19.\nHence, the maximum element-sum of a complete subset of indices is 19."], "constraints": "**Constraints:**\n\n\n* `1 <= n == nums.length <= 104`\n* `1 <= nums[i] <= 109`", "difficulty": "Hard", "tags": ["Array", "Math", "Number Theory"], "hints": ["Let <code>P(x)</code> be the product of all prime numbers <code>p</code> such that <code>p</code> divides <code>x</code>, and there exists an <strong>odd</strong> <code>k</code> such that <code>p^k</code> divides <code>x</code> but <code>p^(k+1)</code> does not.", "If <code>P(nums[i]) = P(nums[j])</code>, <code>nums[i]</code> and <code>nums[j]</code> can be grouped together.", "Pick the group with the largest sum."], "templates": {"cpp": "class Solution {\npublic:\n    long long maximumSum(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public long maximumSum(List<Integer> nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def maximumSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def maximumSum(self, nums: List[int]) -> int:\n        ", "c": "long long maximumSum(int* nums, int numsSize){\n\n}", "csharp": "public class Solution {\n    public long MaximumSum(IList<int> nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maximumSum = function(nums) {\n    \n};", "typescript": "function maximumSum(nums: number[]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function maximumSum($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func maximumSum(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun maximumSum(nums: List<Int>): Long {\n        \n    }\n}", "dart": "class Solution {\n  int maximumSum(List<int> nums) {\n\n  }\n}", "golang": "func maximumSum(nums []int) int64 {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef maximum_sum(nums)\n    \nend", "scala": "object Solution {\n    def maximumSum(nums: List[Int]): Long = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn maximum_sum(nums: Vec<i32>) -> i64 {\n        \n    }\n}", "racket": "(define/contract (maximum-sum nums)\n  (-> (listof exact-integer?) exact-integer?)\n\n  )", "erlang": "-spec maximum_sum(Nums :: [integer()]) -> integer().\nmaximum_sum(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec maximum_sum(nums :: [integer]) :: integer\n  def maximum_sum(nums) do\n\n  end\nend"}}
{"id": "leetcode_2931", "url": "https://leetcode.com/problems/maximum-spending-after-buying-items/", "title": "Maximum Spending After Buying Items", "description": "You are given a **0-indexed** `m * n` integer matrix `values`, representing the values of `m * n` different items in `m` different shops. Each shop has `n` items where the `jth` item in the `ith` shop has a value of `values[i][j]`. Additionally, the items in the `ith` shop are sorted in non-increasing order of value. That is, `values[i][j] >= values[i][j + 1]` for all `0 <= j < n - 1`.\n\n\nOn each day, you would like to buy a single item from one of the shops. Specifically, On the `dth` day you can:\n\n\n* Pick any shop `i`.\n* Buy the rightmost available item `j` for the price of `values[i][j] * d`. That is, find the greatest index `j` such that item `j` was never bought before, and buy it for the price of `values[i][j] * d`.\n\n\n**Note** that all items are pairwise different. For example, if you have bought item `0` from shop `1`, you can still buy item `0` from any other shop.\n\n\nReturn *the **maximum amount of money that can be spent** on buying all*  `m * n` *products*.", "examples": ["**Input:** values = [[8,5,2],[6,4,1],[9,7,3]]\n**Output:** 285\n**Explanation:** On the first day, we buy product 2 from shop 1 for a price of values[1][2] * 1 = 1.\nOn the second day, we buy product 2 from shop 0 for a price of values[0][2] * 2 = 4.\nOn the third day, we buy product 2 from shop 2 for a price of values[2][2] * 3 = 9.\nOn the fourth day, we buy product 1 from shop 1 for a price of values[1][1] * 4 = 16.\nOn the fifth day, we buy product 1 from shop 0 for a price of values[0][1] * 5 = 25.\nOn the sixth day, we buy product 0 from shop 1 for a price of values[1][0] * 6 = 36.\nOn the seventh day, we buy product 1 from shop 2 for a price of values[2][1] * 7 = 49.\nOn the eighth day, we buy product 0 from shop 0 for a price of values[0][0] * 8 = 64.\nOn the ninth day, we buy product 0 from shop 2 for a price of values[2][0] * 9 = 81.\nHence, our total spending is equal to 285.\nIt can be shown that 285 is the maximum amount of money that can be spent buying all m * n products.", "**Input:** values = [[10,8,6,4,2],[9,7,5,3,2]]\n**Output:** 386\n**Explanation:** On the first day, we buy product 4 from shop 0 for a price of values[0][4] * 1 = 2.\nOn the second day, we buy product 4 from shop 1 for a price of values[1][4] * 2 = 4.\nOn the third day, we buy product 3 from shop 1 for a price of values[1][3] * 3 = 9.\nOn the fourth day, we buy product 3 from shop 0 for a price of values[0][3] * 4 = 16.\nOn the fifth day, we buy product 2 from shop 1 for a price of values[1][2] * 5 = 25.\nOn the sixth day, we buy product 2 from shop 0 for a price of values[0][2] * 6 = 36.\nOn the seventh day, we buy product 1 from shop 1 for a price of values[1][1] * 7 = 49.\nOn the eighth day, we buy product 1 from shop 0 for a price of values[0][1] * 8 = 64\nOn the ninth day, we buy product 0 from shop 1 for a price of values[1][0] * 9 = 81.\nOn the tenth day, we buy product 0 from shop 0 for a price of values[0][0] * 10 = 100.\nHence, our total spending is equal to 386.\nIt can be shown that 386 is the maximum amount of money that can be spent buying all m * n products."], "constraints": "**Constraints:**\n\n\n* `1 <= m == values.length <= 10`\n* `1 <= n == values[i].length <= 104`\n* `1 <= values[i][j] <= 106`\n* `values[i]` are sorted in non-increasing order.", "difficulty": "Hard", "tags": ["Array", "Greedy", "Sorting", "Heap (Priority Queue)", "Matrix"], "hints": ["Iterate on days <code>1</code> to <code>m * n</code>.", "On each day, buy the product that minimizes <code>values[i][values[i].length - 1]</code>, and pop it from <code>values[i]</code>."], "templates": {"cpp": "class Solution {\npublic:\n    long long maxSpending(vector<vector<int>>& values) {\n        \n    }\n};", "java": "class Solution {\n    public long maxSpending(int[][] values) {\n        \n    }\n}", "python": "class Solution(object):\n    def maxSpending(self, values):\n        \"\"\"\n        :type values: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def maxSpending(self, values: List[List[int]]) -> int:\n        ", "c": "long long maxSpending(int** values, int valuesSize, int* valuesColSize) {\n    \n}", "csharp": "public class Solution {\n    public long MaxSpending(int[][] values) {\n        \n    }\n}", "javascript": "/**\n * @param {number[][]} values\n * @return {number}\n */\nvar maxSpending = function(values) {\n    \n};", "typescript": "function maxSpending(values: number[][]): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[][] $values\n     * @return Integer\n     */\n    function maxSpending($values) {\n        \n    }\n}", "swift": "class Solution {\n    func maxSpending(_ values: [[Int]]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun maxSpending(values: Array<IntArray>): Long {\n        \n    }\n}", "dart": "class Solution {\n  int maxSpending(List<List<int>> values) {\n    \n  }\n}", "golang": "func maxSpending(values [][]int) int64 {\n    \n}", "ruby": "# @param {Integer[][]} values\n# @return {Integer}\ndef max_spending(values)\n    \nend", "scala": "object Solution {\n    def maxSpending(values: Array[Array[Int]]): Long = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn max_spending(values: Vec<Vec<i32>>) -> i64 {\n        \n    }\n}", "racket": "(define/contract (max-spending values)\n  (-> (listof (listof exact-integer?)) exact-integer?)\n  )", "erlang": "-spec max_spending(Values :: [[integer()]]) -> integer().\nmax_spending(Values) ->\n  .", "elixir": "defmodule Solution do\n  @spec max_spending(values :: [[integer]]) :: integer\n  def max_spending(values) do\n    \n  end\nend"}}
{"id": "leetcode_2818", "url": "https://leetcode.com/problems/apply-operations-to-maximize-score/", "title": "Apply Operations to Maximize Score", "description": "You are given an array `nums` of `n` positive integers and an integer `k`.\n\n\nInitially, you start with a score of `1`. You have to maximize your score by applying the following operation at most `k` times:\n\n\n* Choose any **non-empty** subarray `nums[l, ..., r]` that you haven't chosen previously.\n* Choose an element `x` of `nums[l, ..., r]` with the highest **prime score**. If multiple such elements exist, choose the one with the smallest index.\n* Multiply your score by `x`.\n\n\nHere, `nums[l, ..., r]` denotes the subarray of `nums` starting at index `l` and ending at the index `r`, both ends being inclusive.\n\n\nThe **prime score** of an integer `x` is equal to the number of distinct prime factors of `x`. For example, the prime score of `300` is `3` since `300 = 2 * 2 * 3 * 5 * 5`.\n\n\nReturn *the **maximum possible score** after applying at most* `k` *operations*.\n\n\nSince the answer may be large, return it modulo `109 + 7`.", "examples": ["**Input:** nums = [8,3,9,3,8], k = 2\n**Output:** 81\n**Explanation:** To get a score of 81, we can apply the following operations:\n- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.\n- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.\nIt can be proven that 81 is the highest score one can obtain.", "**Input:** nums = [19,12,14,6,10,18], k = 3\n**Output:** 4788\n**Explanation:** To get a score of 4788, we can apply the following operations: \n- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.\n- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.\n- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.\nIt can be proven that 4788 is the highest score one can obtain."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length == n <= 105`\n* `1 <= nums[i] <= 105`\n* `1 <= k <= min(n * (n + 1) / 2, 109)`", "difficulty": "Hard", "tags": ["Array", "Math", "Stack", "Greedy", "Monotonic Stack", "Number Theory"], "hints": ["<div class=\"_1l1MA\">Calculate <code>nums[i]</code>'s prime score <code>s[i]</code>\u00a0by factoring in <code>O(sqrt(nums[i]))</code> time.</div>", "<div class=\"_1l1MA\">For each <code>nums[i]</code>, find the nearest index <code>left[i]</code> on the left (if any) such that <code>s[left[i]] >= s[i]</code>.\u00a0if none is\u00a0found,\u00a0set <code>left[i]</code> to <code>-1</code>. Similarly, find the nearest index <code>right[i]</code> on the right (if any) such that <code>s[right[i]] > s[i]</code>. If none is found, set <code>right[i]</code> to <code>n</code>.</div>", "<div class=\"_1l1MA\">Use a monotonic stack to compute <code>right[i]</code> and <code>left[i]</code>.</div>", "<div class=\"_1l1MA\">For each index <code>i</code>, if <code>left[i] + 1 <= l\u00a0<= i <= r\u00a0<= right[i] - 1</code>, then <code>s[i]</code> is the maximum value in the range <code>[l, r]</code>. For this particular <code>i</code>, there are\u00a0<code>ranges[i] =\u00a0(i - left[i]) * (right[i] - i)</code> ranges where index <code>i</code> will be chosen.</div>", "<div class=\"_1l1MA\">Loop over all elements of <code>nums</code>\u00a0by non-increasing\u00a0prime score, each element will be chosen <code>min(ranges[i], remainingK)</code>\u00a0times, where <code>reaminingK</code>\u00a0denotes the number of remaining operations. Therefore, the score will be multiplied by <code>s[i]^min(ranges[i],remainingK)</code>.</div>", "<div class=\"_1l1MA\">Use fast exponentiation to quickly calculate <code>A^B mod C</code>.</div>"], "templates": {"cpp": "class Solution {\npublic:\n    int maximumScore(vector<int>& nums, int k) {\n        \n    }\n};", "java": "class Solution {\n    public int maximumScore(List<Integer> nums, int k) {\n        \n    }\n}", "python": "class Solution(object):\n    def maximumScore(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        ", "c": "int maximumScore(int* nums, int numsSize, int k){\n\n}", "csharp": "public class Solution {\n    public int MaximumScore(IList<int> nums, int k) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maximumScore = function(nums, k) {\n    \n};", "typescript": "function maximumScore(nums: number[], k: number): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer\n     */\n    function maximumScore($nums, $k) {\n        \n    }\n}", "swift": "class Solution {\n    func maximumScore(_ nums: [Int], _ k: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun maximumScore(nums: List<Int>, k: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int maximumScore(List<int> nums, int k) {\n\n  }\n}", "golang": "func maximumScore(nums []int, k int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer}\ndef maximum_score(nums, k)\n    \nend", "scala": "object Solution {\n    def maximumScore(nums: List[Int], k: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn maximum_score(nums: Vec<i32>, k: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (maximum-score nums k)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n\n  )", "erlang": "-spec maximum_score(Nums :: [integer()], K :: integer()) -> integer().\nmaximum_score(Nums, K) ->\n  .", "elixir": "defmodule Solution do\n  @spec maximum_score(nums :: [integer], k :: integer) :: integer\n  def maximum_score(nums, k) do\n\n  end\nend"}}
{"id": "leetcode_2926", "url": "https://leetcode.com/problems/maximum-balanced-subsequence-sum/", "title": "Maximum Balanced Subsequence Sum", "description": "You are given a **0-indexed** integer array `nums`.\n\n\nA **subsequence** of `nums` having length `k` and consisting of **indices** `i0\u00a0<\u00a0i1 <\u00a0... < ik-1` is **balanced** if the following holds:\n\n\n* `nums[ij] - nums[ij-1] >= ij - ij-1`, for every `j` in the range `[1, k - 1]`.\n\n\nA **subsequence** of `nums` having length `1` is considered balanced.\n\n\nReturn *an integer denoting the **maximum** possible **sum of elements** in a **balanced** subsequence of* `nums`.\n\n\nA **subsequence** of an array is a new **non-empty** array that is formed from the original array by deleting some (**possibly none**) of the elements without disturbing the relative positions of the remaining elements.", "examples": ["**Input:** nums = [3,3,5,6]\n**Output:** 14\n**Explanation:** In this example, the subsequence [3,5,6] consisting of indices 0, 2, and 3 can be selected.\nnums[2] - nums[0] >= 2 - 0.\nnums[3] - nums[2] >= 3 - 2.\nHence, it is a balanced subsequence, and its sum is the maximum among the balanced subsequences of nums.\nThe subsequence consisting of indices 1, 2, and 3 is also valid.\nIt can be shown that it is not possible to get a balanced subsequence with a sum greater than 14.", "**Input:** nums = [5,-1,-3,8]\n**Output:** 13\n**Explanation:** In this example, the subsequence [5,8] consisting of indices 0 and 3 can be selected.\nnums[3] - nums[0] >= 3 - 0.\nHence, it is a balanced subsequence, and its sum is the maximum among the balanced subsequences of nums.\nIt can be shown that it is not possible to get a balanced subsequence with a sum greater than 13.", "**Input:** nums = [-2,-1]\n**Output:** -1\n**Explanation:** In this example, the subsequence [-1] can be selected.\nIt is a balanced subsequence, and its sum is the maximum among the balanced subsequences of nums."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `-109 <= nums[i] <= 109`", "difficulty": "Hard", "tags": ["Array", "Binary Search", "Dynamic Programming", "Binary Indexed Tree", "Segment Tree"], "hints": ["Let <code>dp[x]</code> represent the maximum sum of a balanced subsequence ending at <code>x</code>.", "Rewriting the formula <code>nums[i<sub>j</sub>] - nums[i<sub>j-1</sub>] >= i<sub>j</sub> - i<sub>j-1</sub></code> gives <code>nums[i<sub>j</sub>] - i<sub>j</sub> >= nums[i<sub>j-1</sub>] - i<sub>j-1</sub></code>.", "So, for some index <code>x</code>, we need to find an index <code>y</code>, <code>y < x</code>, such that <code>dp[x] = nums[x] + dp[y]</code> is maximized, and <code>nums[x] - x >= nums[y] - y</code>.", "There are many ways to achieve this. One method involves sorting the values of <code>nums[x] - x</code> for all indices <code>x</code> and using a segment/Fenwick tree with coordinate compression.", "Hence, using a dictionary or map, let's call it <code>dict</code>, where <code>dict[nums[x] - x]</code> represents the position of the value, <code>nums[x] - x</code>, in the segment tree.", "The tree is initialized with zeros initially.", "For indices <code>x</code> in order from <code>[0, n - 1]</code>, <code>dp[x] = max(nums[x]</code>, <code>nums[x]</code> + the maximum query from the tree in the range <code>[0, dict[nums[x] - x]])</code>, and if <code>dp[x]</code> is greater than the value in the tree at position <code>dict[nums[x] - x]</code>, we update the value in the tree.", "The answer to the problem is the maximum value in <code>dp</code>."], "templates": {"cpp": "class Solution {\npublic:\n    long long maxBalancedSubsequenceSum(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public long maxBalancedSubsequenceSum(int[] nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def maxBalancedSubsequenceSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        ", "c": "long long maxBalancedSubsequenceSum(int* nums, int numsSize) {\n    \n}", "csharp": "public class Solution {\n    public long MaxBalancedSubsequenceSum(int[] nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxBalancedSubsequenceSum = function(nums) {\n    \n};", "typescript": "function maxBalancedSubsequenceSum(nums: number[]): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function maxBalancedSubsequenceSum($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func maxBalancedSubsequenceSum(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun maxBalancedSubsequenceSum(nums: IntArray): Long {\n        \n    }\n}", "dart": "class Solution {\n  int maxBalancedSubsequenceSum(List<int> nums) {\n    \n  }\n}", "golang": "func maxBalancedSubsequenceSum(nums []int) int64 {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef max_balanced_subsequence_sum(nums)\n    \nend", "scala": "object Solution {\n    def maxBalancedSubsequenceSum(nums: Array[Int]): Long = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn max_balanced_subsequence_sum(nums: Vec<i32>) -> i64 {\n        \n    }\n}", "racket": "(define/contract (max-balanced-subsequence-sum nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )", "erlang": "-spec max_balanced_subsequence_sum(Nums :: [integer()]) -> integer().\nmax_balanced_subsequence_sum(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec max_balanced_subsequence_sum(nums :: [integer]) :: integer\n  def max_balanced_subsequence_sum(nums) do\n    \n  end\nend"}}
{"id": "leetcode_2681", "url": "https://leetcode.com/problems/power-of-heroes/", "title": "Power of Heroes", "description": "You are given a **0-indexed** integer array `nums` representing the strength of some heroes. The **power** of a group of heroes is defined as follows:\n\n\n* Let `i0`, `i1`, ... ,`ik` be the indices of the heroes in a group. Then, the power of this group is `max(nums[i0], nums[i1], ... ,nums[ik])2 * min(nums[i0], nums[i1], ... ,nums[ik])`.\n\n\nReturn *the sum of the **power** of all **non-empty** groups of heroes possible.* Since the sum could be very large, return it **modulo** `109 + 7`.", "examples": ["**Input:** nums = [2,1,4]\n**Output:** 141\n**Explanation:** \n1st\u00a0group: [2] has power = 22\u00a0* 2 = 8.\n2nd\u00a0group: [1] has power = 12 * 1 = 1. \n3rd\u00a0group: [4] has power = 42 * 4 = 64. \n4th\u00a0group: [2,1] has power = 22 * 1 = 4. \n5th\u00a0group: [2,4] has power = 42 * 2 = 32. \n6th\u00a0group: [1,4] has power = 42 * 1 = 16. \n\u200b\u200b\u200b\u200b\u200b\u200b\u200b7th\u00a0group: [2,1,4] has power = 42\u200b\u200b\u200b\u200b\u200b\u200b\u200b * 1 = 16. \nThe sum of powers of all groups is 8 + 1 + 64 + 4 + 32 + 16 + 16 = 141.", "**Input:** nums = [1,1,1]\n**Output:** 7\n**Explanation:** A total of 7 groups are possible, and the power of each group will be 1. Therefore, the sum of the powers of all groups is 7."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `1 <= nums[i] <= 109`", "difficulty": "Hard", "tags": ["Array", "Math", "Sorting", "Prefix Sum"], "hints": ["Try something with sorting the array.", "For a pair of array elements nums[i] and nums[j] (i < j), the power would be nums[i]*nums[j]^2 regardless of how many elements in between are included.", "The number of subsets with the above as power will correspond to 2^(j-i-1).", "Try collecting the terms for nums[0], nums[1], \u2026, nums[j-1] when computing the power of heroes ending at index j to get the power in a single pass."], "templates": {"cpp": "class Solution {\npublic:\n    int sumOfPower(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public int sumOfPower(int[] nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def sumOfPower(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def sumOfPower(self, nums: List[int]) -> int:\n        ", "c": "int sumOfPower(int* nums, int numsSize){\n\n}", "csharp": "public class Solution {\n    public int SumOfPower(int[] nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar sumOfPower = function(nums) {\n    \n};", "typescript": "function sumOfPower(nums: number[]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function sumOfPower($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func sumOfPower(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun sumOfPower(nums: IntArray): Int {\n        \n    }\n}", "dart": "class Solution {\n  int sumOfPower(List<int> nums) {\n\n  }\n}", "golang": "func sumOfPower(nums []int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef sum_of_power(nums)\n    \nend", "scala": "object Solution {\n    def sumOfPower(nums: Array[Int]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn sum_of_power(nums: Vec<i32>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (sum-of-power nums)\n  (-> (listof exact-integer?) exact-integer?)\n\n  )", "erlang": "-spec sum_of_power(Nums :: [integer()]) -> integer().\nsum_of_power(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec sum_of_power(nums :: [integer]) :: integer\n  def sum_of_power(nums) do\n\n  end\nend"}}
{"id": "leetcode_2790", "url": "https://leetcode.com/problems/maximum-number-of-groups-with-increasing-length/", "title": "Maximum Number of Groups With Increasing Length", "description": "You are given a **0-indexed** array `usageLimits` of length `n`.\n\n\nYour task is to create **groups** using numbers from `0` to `n - 1`, ensuring that each number, `i`, is used no more than `usageLimits[i]` times in total **across all groups**. You must also satisfy the following conditions:\n\n\n* Each group must consist of **distinct** numbers, meaning that no duplicate numbers are allowed within a single group.\n* Each group (except the first one) must have a length **strictly greater** than the previous group.\n\n\nReturn *an integer denoting the **maximum** number of groups you can create while satisfying these conditions.*", "examples": ["**Input:** usageLimits = [1,2,5]\n**Output:** 3\n**Explanation:** In this example, we can use 0 at most once, 1 at most twice, and 2 at most five times.\nOne way of creating the maximum number of groups while satisfying the conditions is: \nGroup 1 contains the number [2].\nGroup 2 contains the numbers [1,2].\nGroup 3 contains the numbers [0,1,2]. \nIt can be shown that the maximum number of groups is 3. \nSo, the output is 3.", "**Input:** usageLimits = [2,1,2]\n**Output:** 2\n**Explanation:** In this example, we can use 0 at most twice, 1 at most once, and 2 at most twice.\nOne way of creating the maximum number of groups while satisfying the conditions is:\nGroup 1 contains the number [0].\nGroup 2 contains the numbers [1,2].\nIt can be shown that the maximum number of groups is 2.\nSo, the output is 2.", "**Input:** usageLimits = [1,1]\n**Output:** 1\n**Explanation:** In this example, we can use both 0 and 1 at most once.\nOne way of creating the maximum number of groups while satisfying the conditions is:\nGroup 1 contains the number [0].\nIt can be shown that the maximum number of groups is 1.\nSo, the output is 1."], "constraints": "**Constraints:**\n\n\n* `1 <= usageLimits.length <= 105`\n* `1 <= usageLimits[i] <= 109`", "difficulty": "Hard", "tags": ["Array", "Math", "Binary Search", "Greedy", "Sorting"], "hints": ["Can we solve this problem using sorting and binary search?\r\nSort the array in increasing order and run a binary search on the number of groups, x.\r\nTo determine if a value x is feasible, greedily distribute the numbers such that each group receives 1, 2, 3, ..., x numbers.", "Sort the array in increasing order and run a binary search on the number of groups, x.", "To determine if a value x is feasible, greedily distribute the numbers such that each group receives 1, 2, 3, ..., x numbers."], "templates": {"cpp": "class Solution {\npublic:\n    int maxIncreasingGroups(vector<int>& usageLimits) {\n        \n    }\n};", "java": "class Solution {\n    public int maxIncreasingGroups(List<Integer> usageLimits) {\n        \n    }\n}", "python": "class Solution(object):\n    def maxIncreasingGroups(self, usageLimits):\n        \"\"\"\n        :type usageLimits: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def maxIncreasingGroups(self, usageLimits: List[int]) -> int:\n        ", "c": "int maxIncreasingGroups(int* usageLimits, int usageLimitsSize){\n\n}", "csharp": "public class Solution {\n    public int MaxIncreasingGroups(IList<int> usageLimits) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} usageLimits\n * @return {number}\n */\nvar maxIncreasingGroups = function(usageLimits) {\n    \n};", "typescript": "function maxIncreasingGroups(usageLimits: number[]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $usageLimits\n     * @return Integer\n     */\n    function maxIncreasingGroups($usageLimits) {\n        \n    }\n}", "swift": "class Solution {\n    func maxIncreasingGroups(_ usageLimits: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun maxIncreasingGroups(usageLimits: List<Int>): Int {\n        \n    }\n}", "dart": "class Solution {\n  int maxIncreasingGroups(List<int> usageLimits) {\n\n  }\n}", "golang": "func maxIncreasingGroups(usageLimits []int) int {\n    \n}", "ruby": "# @param {Integer[]} usage_limits\n# @return {Integer}\ndef max_increasing_groups(usage_limits)\n    \nend", "scala": "object Solution {\n    def maxIncreasingGroups(usageLimits: List[Int]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn max_increasing_groups(usage_limits: Vec<i32>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (max-increasing-groups usageLimits)\n  (-> (listof exact-integer?) exact-integer?)\n\n  )", "erlang": "-spec max_increasing_groups(UsageLimits :: [integer()]) -> integer().\nmax_increasing_groups(UsageLimits) ->\n  .", "elixir": "defmodule Solution do\n  @spec max_increasing_groups(usage_limits :: [integer]) :: integer\n  def max_increasing_groups(usage_limits) do\n\n  end\nend"}}
{"id": "leetcode_2801", "url": "https://leetcode.com/problems/count-stepping-numbers-in-range/", "title": "Count Stepping Numbers in Range", "description": "Given two positive integers `low` and `high` represented as strings, find the count of **stepping numbers** in the inclusive range `[low, high]`.\n\n\nA **stepping number** is an integer such that all of its adjacent digits have an absolute difference of **exactly** `1`.\n\n\nReturn *an integer denoting the count of stepping numbers in the inclusive range* `[low, high]`*.* \n\n\nSince the answer may be very large, return it **modulo** `109 + 7`.\n\n\n**Note:** A stepping number should not have a leading zero.", "examples": ["**Input:** low = \"1\", high = \"11\"\n**Output:** 10\n**Explanation:** The stepping numbers in the range [1,11] are 1, 2, 3, 4, 5, 6, 7, 8, 9 and 10. There are a total of 10 stepping numbers in the range. Hence, the output is 10.", "**Input:** low = \"90\", high = \"101\"\n**Output:** 2\n**Explanation:** The stepping numbers in the range [90,101] are 98 and 101. There are a total of 2 stepping numbers in the range. Hence, the output is 2."], "constraints": "**Constraints:**\n\n\n* `1 <= int(low) <= int(high) < 10100`\n* `1 <= low.length, high.length <= 100`\n* `low` and `high` consist of only digits.\n* `low` and `high` don't have any leading zeros.", "difficulty": "Hard", "tags": ["String", "Dynamic Programming"], "hints": ["Calculate the number of stepping numbers in the range [1, high] and subtract the number of stepping numbers in the range [1, low - 1].", "The main problem is calculating the number of stepping numbers in the range [1, x].", "First, calculate the number of stepping numbers shorter than x in length, which can be done using dynamic programming. (dp[i][j] is the number of i-digit stepping numbers ending with digit j).", "Finally, calculate the number of stepping numbers that have the same length as x similarly. However, this time we need to maintain whether the prefix (in string) is smaller than or equal to x in the DP state."], "templates": {"cpp": "class Solution {\npublic:\n    int countSteppingNumbers(string low, string high) {\n        \n    }\n};", "java": "class Solution {\n    public int countSteppingNumbers(String low, String high) {\n        \n    }\n}", "python": "class Solution(object):\n    def countSteppingNumbers(self, low, high):\n        \"\"\"\n        :type low: str\n        :type high: str\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def countSteppingNumbers(self, low: str, high: str) -> int:\n        ", "c": "int countSteppingNumbers(char * low, char * high){\n\n}", "csharp": "public class Solution {\n    public int CountSteppingNumbers(string low, string high) {\n        \n    }\n}", "javascript": "/**\n * @param {string} low\n * @param {string} high\n * @return {number}\n */\nvar countSteppingNumbers = function(low, high) {\n    \n};", "typescript": "function countSteppingNumbers(low: string, high: string): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param String $low\n     * @param String $high\n     * @return Integer\n     */\n    function countSteppingNumbers($low, $high) {\n        \n    }\n}", "swift": "class Solution {\n    func countSteppingNumbers(_ low: String, _ high: String) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun countSteppingNumbers(low: String, high: String): Int {\n        \n    }\n}", "dart": "class Solution {\n  int countSteppingNumbers(String low, String high) {\n\n  }\n}", "golang": "func countSteppingNumbers(low string, high string) int {\n    \n}", "ruby": "# @param {String} low\n# @param {String} high\n# @return {Integer}\ndef count_stepping_numbers(low, high)\n    \nend", "scala": "object Solution {\n    def countSteppingNumbers(low: String, high: String): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn count_stepping_numbers(low: String, high: String) -> i32 {\n        \n    }\n}", "racket": "(define/contract (count-stepping-numbers low high)\n  (-> string? string? exact-integer?)\n\n  )", "erlang": "-spec count_stepping_numbers(Low :: unicode:unicode_binary(), High :: unicode:unicode_binary()) -> integer().\ncount_stepping_numbers(Low, High) ->\n  .", "elixir": "defmodule Solution do\n  @spec count_stepping_numbers(low :: String.t, high :: String.t) :: integer\n  def count_stepping_numbers(low, high) do\n\n  end\nend"}}
{"id": "leetcode_2968", "url": "https://leetcode.com/problems/apply-operations-to-maximize-frequency-score/", "title": "Apply Operations to Maximize Frequency Score", "description": "You are given a **0-indexed** integer array `nums` and an integer `k`.\n\n\nYou can perform the following operation on the array **at most** `k` times:\n\n\n* Choose any index `i` from the array and **increase** or **decrease** `nums[i]` by `1`.\n\n\nThe score of the final array is the **frequency** of the most frequent element in the array.\n\n\nReturn *the **maximum** score you can achieve*.\n\n\nThe frequency of an element is the number of occurences of that element in the array.", "examples": ["**Input:** nums = [1,2,6,4], k = 3\n**Output:** 3\n**Explanation:** We can do the following operations on the array:\n- Choose i = 0, and increase the value of nums[0] by 1. The resulting array is [2,2,6,4].\n- Choose i = 3, and decrease the value of nums[3] by 1. The resulting array is [2,2,6,3].\n- Choose i = 3, and decrease the value of nums[3] by 1. The resulting array is [2,2,6,2].\nThe element 2 is the most frequent in the final array so our score is 3.\nIt can be shown that we cannot achieve a better score.", "**Input:** nums = [1,4,4,2,4], k = 0\n**Output:** 3\n**Explanation:** We cannot apply any operations so our score will be the frequency of the most frequent element in the original array, which is 3."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `1 <= nums[i] <= 109`\n* `0 <= k <= 1014`", "difficulty": "Hard", "tags": ["Array", "Binary Search", "Sliding Window", "Sorting", "Prefix Sum"], "hints": ["If you sort the original array, it is optimal to apply the operations on one subarray such that all the elements of that subarray become equal.", "You can use binary search to find the longest subarray where we can make the elements equal in at most <code>k</code> operations."], "templates": {"cpp": "class Solution {\npublic:\n    int maxFrequencyScore(vector<int>& nums, long long k) {\n        \n    }\n};", "java": "class Solution {\n    public int maxFrequencyScore(int[] nums, long k) {\n        \n    }\n}", "python": "class Solution(object):\n    def maxFrequencyScore(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def maxFrequencyScore(self, nums: List[int], k: int) -> int:\n        ", "c": "int maxFrequencyScore(int* nums, int numsSize, long long k) {\n    \n}", "csharp": "public class Solution {\n    public int MaxFrequencyScore(int[] nums, long k) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maxFrequencyScore = function(nums, k) {\n    \n};", "typescript": "function maxFrequencyScore(nums: number[], k: number): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer\n     */\n    function maxFrequencyScore($nums, $k) {\n        \n    }\n}", "swift": "class Solution {\n    func maxFrequencyScore(_ nums: [Int], _ k: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun maxFrequencyScore(nums: IntArray, k: Long): Int {\n        \n    }\n}", "dart": "class Solution {\n  int maxFrequencyScore(List<int> nums, int k) {\n    \n  }\n}", "golang": "func maxFrequencyScore(nums []int, k int64) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer}\ndef max_frequency_score(nums, k)\n    \nend", "scala": "object Solution {\n    def maxFrequencyScore(nums: Array[Int], k: Long): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn max_frequency_score(nums: Vec<i32>, k: i64) -> i32 {\n        \n    }\n}", "racket": "(define/contract (max-frequency-score nums k)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )", "erlang": "-spec max_frequency_score(Nums :: [integer()], K :: integer()) -> integer().\nmax_frequency_score(Nums, K) ->\n  .", "elixir": "defmodule Solution do\n  @spec max_frequency_score(nums :: [integer], k :: integer) :: integer\n  def max_frequency_score(nums, k) do\n    \n  end\nend"}}
{"id": "leetcode_2732", "url": "https://leetcode.com/problems/find-a-good-subset-of-the-matrix/", "title": "Find a Good Subset of the Matrix", "description": "You are given a **0-indexed** `m x n` binary matrix `grid`.\n\n\nLet us call a **non-empty** subset of rows **good** if the sum of each column of the subset is at most half of the length of the subset.\n\n\nMore formally, if the length of the chosen subset of rows is `k`, then the sum of each column should be at most `floor(k / 2)`.\n\n\nReturn *an integer array that contains row indices of a good subset sorted in **ascending** order.*\n\n\nIf there are multiple good subsets, you can return any of them. If there are no good subsets, return an empty array.\n\n\nA **subset** of rows of the matrix `grid` is any matrix that can be obtained by deleting some (possibly none or all) rows from `grid`.", "examples": ["**Input:** grid = [[0,1,1,0],[0,0,0,1],[1,1,1,1]]\n**Output:** [0,1]\n**Explanation:** We can choose the 0th and 1st rows to create a good subset of rows.\nThe length of the chosen subset is 2.\n- The sum of the 0th\u00a0column is 0 + 0 = 0, which is at most half of the length of the subset.\n- The sum of the 1st\u00a0column is 1 + 0 = 1, which is at most half of the length of the subset.\n- The sum of the 2nd\u00a0column is 1 + 0 = 1, which is at most half of the length of the subset.\n- The sum of the 3rd\u00a0column is 0 + 1 = 1, which is at most half of the length of the subset.", "**Input:** grid = [[0]]\n**Output:** [0]\n**Explanation:** We can choose the 0th row to create a good subset of rows.\nThe length of the chosen subset is 1.\n- The sum of the 0th\u00a0column is 0, which is at most half of the length of the subset.", "**Input:** grid = [[1,1,1],[1,1,1]]\n**Output:** []\n**Explanation:** It is impossible to choose any subset of rows to create a good subset."], "constraints": "**Constraints:**\n\n\n* `m == grid.length`\n* `n == grid[i].length`\n* `1 <= m <= 104`\n* `1 <= n <= 5`\n* `grid[i][j]` is either `0` or `1`.", "difficulty": "Hard", "tags": ["Array", "Greedy", "Bit Manipulation", "Matrix"], "hints": ["It can be proven, that if there exists a good subset of rows then there exists a good subset of rows with the size of either 1 or 2.", "To check if there exists a good subset of rows of size 1, we check if there exists a row containing only zeros, if it does, we return its index as a good subset.", "To check if there exists a good subset of rows of size 2, we iterate over two bit-masks, check if both are presented in the array and if they form a good subset, if they do, return their indices as a good subset."], "templates": {"cpp": "class Solution {\npublic:\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\n        \n    }\n};", "java": "class Solution {\n    public List<Integer> goodSubsetofBinaryMatrix(int[][] grid) {\n        \n    }\n}", "python": "class Solution(object):\n    def goodSubsetofBinaryMatrix(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        ", "python3": "class Solution:\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\n        ", "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* goodSubsetofBinaryMatrix(int** grid, int gridSize, int* gridColSize, int* returnSize){\n\n}", "csharp": "public class Solution {\n    public IList<int> GoodSubsetofBinaryMatrix(int[][] grid) {\n        \n    }\n}", "javascript": "/**\n * @param {number[][]} grid\n * @return {number[]}\n */\nvar goodSubsetofBinaryMatrix = function(grid) {\n    \n};", "typescript": "function goodSubsetofBinaryMatrix(grid: number[][]): number[] {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[][] $grid\n     * @return Integer[]\n     */\n    function goodSubsetofBinaryMatrix($grid) {\n        \n    }\n}", "swift": "class Solution {\n    func goodSubsetofBinaryMatrix(_ grid: [[Int]]) -> [Int] {\n        \n    }\n}", "kotlin": "class Solution {\n    fun goodSubsetofBinaryMatrix(grid: Array<IntArray>): List<Int> {\n        \n    }\n}", "dart": "class Solution {\n  List<int> goodSubsetofBinaryMatrix(List<List<int>> grid) {\n\n  }\n}", "golang": "func goodSubsetofBinaryMatrix(grid [][]int) []int {\n    \n}", "ruby": "# @param {Integer[][]} grid\n# @return {Integer[]}\ndef good_subsetof_binary_matrix(grid)\n    \nend", "scala": "object Solution {\n    def goodSubsetofBinaryMatrix(grid: Array[Array[Int]]): List[Int] = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn good_subsetof_binary_matrix(grid: Vec<Vec<i32>>) -> Vec<i32> {\n        \n    }\n}", "racket": "(define/contract (good-subsetof-binary-matrix grid)\n  (-> (listof (listof exact-integer?)) (listof exact-integer?))\n\n  )", "erlang": "-spec good_subsetof_binary_matrix(Grid :: [[integer()]]) -> [integer()].\ngood_subsetof_binary_matrix(Grid) ->\n  .", "elixir": "defmodule Solution do\n  @spec good_subsetof_binary_matrix(grid :: [[integer]]) :: [integer]\n  def good_subsetof_binary_matrix(grid) do\n\n  end\nend"}}
{"id": "leetcode_2972", "url": "https://leetcode.com/problems/count-the-number-of-incremovable-subarrays-ii/", "title": "Count the Number of Incremovable Subarrays II", "description": "You are given a **0-indexed** array of **positive** integers `nums`.\n\n\nA subarray of `nums` is called **incremovable** if `nums` becomes **strictly increasing** on removing the subarray. For example, the subarray `[3, 4]` is an incremovable subarray of `[5, 3, 4, 6, 7]` because removing this subarray changes the array `[5, 3, 4, 6, 7]` to `[5, 6, 7]` which is strictly increasing.\n\n\nReturn *the total number of **incremovable** subarrays of* `nums`.\n\n\n**Note** that an empty array is considered strictly increasing.\n\n\nA **subarray** is a contiguous non-empty sequence of elements within an array.", "examples": ["**Input:** nums = [1,2,3,4]\n**Output:** 10\n**Explanation:** The 10 incremovable subarrays are: [1], [2], [3], [4], [1,2], [2,3], [3,4], [1,2,3], [2,3,4], and [1,2,3,4], because on removing any one of these subarrays nums becomes strictly increasing. Note that you cannot select an empty subarray.", "**Input:** nums = [6,5,7,8]\n**Output:** 7\n**Explanation:** The 7 incremovable subarrays are: [5], [6], [5,7], [6,5], [5,7,8], [6,5,7] and [6,5,7,8].\nIt can be shown that there are only 7 incremovable subarrays in nums.", "**Input:** nums = [8,7,6,6]\n**Output:** 3\n**Explanation:** The 3 incremovable subarrays are: [8,7,6], [7,6,6], and [8,7,6,6]. Note that [8,7] is not an incremovable subarray because after removing [8,7] nums becomes [6,6], which is sorted in ascending order but not strictly increasing."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `1 <= nums[i] <= 109`", "difficulty": "Hard", "tags": [], "hints": ["Calculate the largest <code>x</code> such that <code>nums[0..x]</code> is strictly increasing.", "Calculate the smallest <code>y</code> such that <code>nums[y..nums.length-1]</code> is strictly increasing.", "For each <code>i</code> in <code>[0, x]</code>, select the smallest <code>j</code> in <code>[y, nums.length - 1]</code>. Then we can keep the prefix with any suffix of <code>[j, nums.length - 1]</code> (including the empty one).", "Note that when <code>i</code> increases, <code>j</code> won\u2019t decrease. Use two-pointers.", "Note that we cannot delete an empty array, but we can delete the whole array."], "templates": {"cpp": "class Solution {\npublic:\n    long long incremovableSubarrayCount(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public long incremovableSubarrayCount(int[] nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def incremovableSubarrayCount(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def incremovableSubarrayCount(self, nums: List[int]) -> int:\n        ", "c": "long long incremovableSubarrayCount(int* nums, int numsSize) {\n    \n}", "csharp": "public class Solution {\n    public long IncremovableSubarrayCount(int[] nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar incremovableSubarrayCount = function(nums) {\n    \n};", "typescript": "function incremovableSubarrayCount(nums: number[]): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function incremovableSubarrayCount($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func incremovableSubarrayCount(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun incremovableSubarrayCount(nums: IntArray): Long {\n        \n    }\n}", "dart": "class Solution {\n  int incremovableSubarrayCount(List<int> nums) {\n    \n  }\n}", "golang": "func incremovableSubarrayCount(nums []int) int64 {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef incremovable_subarray_count(nums)\n    \nend", "scala": "object Solution {\n    def incremovableSubarrayCount(nums: Array[Int]): Long = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn incremovable_subarray_count(nums: Vec<i32>) -> i64 {\n        \n    }\n}", "racket": "(define/contract (incremovable-subarray-count nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )", "erlang": "-spec incremovable_subarray_count(Nums :: [integer()]) -> integer().\nincremovable_subarray_count(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec incremovable_subarray_count(nums :: [integer]) :: integer\n  def incremovable_subarray_count(nums) do\n    \n  end\nend"}}
{"id": "leetcode_2709", "url": "https://leetcode.com/problems/greatest-common-divisor-traversal/", "title": "Greatest Common Divisor Traversal", "description": "You are given a **0-indexed** integer array `nums`, and you are allowed to **traverse** between its indices. You can traverse between index `i` and index `j`, `i != j`, if and only if `gcd(nums[i], nums[j]) > 1`, where `gcd` is the **greatest common divisor**.\n\n\nYour task is to determine if for **every pair** of indices `i` and `j` in nums, where `i < j`, there exists a **sequence of traversals** that can take us from `i` to `j`.\n\n\nReturn `true` *if it is possible to traverse between all such pairs of indices,* *or* `false` *otherwise.*", "examples": ["**Input:** nums = [2,3,6]\n**Output:** true\n**Explanation:** In this example, there are 3 possible pairs of indices: (0, 1), (0, 2), and (1, 2).\nTo go from index 0 to index 1, we can use the sequence of traversals 0 -> 2 -> 1, where we move from index 0 to index 2 because gcd(nums[0], nums[2]) = gcd(2, 6) = 2 > 1, and then move from index 2 to index 1 because gcd(nums[2], nums[1]) = gcd(6, 3) = 3 > 1.\nTo go from index 0 to index 2, we can just go directly because gcd(nums[0], nums[2]) = gcd(2, 6) = 2 > 1. Likewise, to go from index 1 to index 2, we can just go directly because gcd(nums[1], nums[2]) = gcd(3, 6) = 3 > 1.", "**Input:** nums = [3,9,5]\n**Output:** false\n**Explanation:** No sequence of traversals can take us from index 0 to index 2 in this example. So, we return false.", "**Input:** nums = [4,3,12,8]\n**Output:** true\n**Explanation:** There are 6 possible pairs of indices to traverse between: (0, 1), (0, 2), (0, 3), (1, 2), (1, 3), and (2, 3). A valid sequence of traversals exists for each pair, so we return true."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `1 <= nums[i] <= 105`", "difficulty": "Hard", "tags": ["Array", "Math", "Union Find", "Number Theory"], "hints": ["Create a (prime) factor-numbers list for all the indices.", "Add an edge between the neighbors of the (prime) factor-numbers list. The order of the numbers doesn\u2019t matter. We only need edges between 2 neighbors instead of edges for all pairs.", "The problem is now similar to checking if all the numbers (nodes of the graph) are in the same connected component.", "Any algorithm (i.e., BFS, DFS, or Union-Find Set) should work to find or check connected components"], "templates": {"cpp": "class Solution {\npublic:\n    bool canTraverseAllPairs(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public boolean canTraverseAllPairs(int[] nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def canTraverseAllPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        ", "python3": "class Solution:\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\n        ", "c": "bool canTraverseAllPairs(int* nums, int numsSize){\n\n}", "csharp": "public class Solution {\n    public bool CanTraverseAllPairs(int[] nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar canTraverseAllPairs = function(nums) {\n    \n};", "typescript": "function canTraverseAllPairs(nums: number[]): boolean {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Boolean\n     */\n    function canTraverseAllPairs($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func canTraverseAllPairs(_ nums: [Int]) -> Bool {\n        \n    }\n}", "kotlin": "class Solution {\n    fun canTraverseAllPairs(nums: IntArray): Boolean {\n        \n    }\n}", "dart": "class Solution {\n  bool canTraverseAllPairs(List<int> nums) {\n\n  }\n}", "golang": "func canTraverseAllPairs(nums []int) bool {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Boolean}\ndef can_traverse_all_pairs(nums)\n    \nend", "scala": "object Solution {\n    def canTraverseAllPairs(nums: Array[Int]): Boolean = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn can_traverse_all_pairs(nums: Vec<i32>) -> bool {\n        \n    }\n}", "racket": "(define/contract (can-traverse-all-pairs nums)\n  (-> (listof exact-integer?) boolean?)\n\n  )", "erlang": "-spec can_traverse_all_pairs(Nums :: [integer()]) -> boolean().\ncan_traverse_all_pairs(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec can_traverse_all_pairs(nums :: [integer]) :: boolean\n  def can_traverse_all_pairs(nums) do\n\n  end\nend"}}
{"id": "leetcode_2949", "url": "https://leetcode.com/problems/count-beautiful-substrings-ii/", "title": "Count Beautiful Substrings II", "description": "You are given a string `s` and a positive integer `k`.\n\n\nLet `vowels` and `consonants` be the number of vowels and consonants in a string.\n\n\nA string is **beautiful** if:\n\n\n* `vowels == consonants`.\n* `(vowels * consonants) % k == 0`, in other terms the multiplication of `vowels` and `consonants` is divisible by `k`.\n\n\nReturn *the number of **non-empty beautiful substrings** in the given string* `s`.\n\n\nA **substring** is a contiguous sequence of characters in a string.\n\n\n**Vowel letters** in English are `'a'`, `'e'`, `'i'`, `'o'`, and `'u'`.\n\n\n**Consonant letters** in English are every letter except vowels.", "examples": ["**Input:** s = \"baeyh\", k = 2\n**Output:** 2\n**Explanation:** There are 2 beautiful substrings in the given string.\n- Substring \"baeyh\", vowels = 2 ([\"a\",e\"]), consonants = 2 ([\"y\",\"h\"]).\nYou can see that string \"aeyh\" is beautiful as vowels == consonants and vowels * consonants % k == 0.\n- Substring \"baeyh\", vowels = 2 ([\"a\",e\"]), consonants = 2 ([\"b\",\"y\"]).\nYou can see that string \"baey\" is beautiful as vowels == consonants and vowels * consonants % k == 0.\nIt can be shown that there are only 2 beautiful substrings in the given string.", "**Input:** s = \"abba\", k = 1\n**Output:** 3\n**Explanation:** There are 3 beautiful substrings in the given string.\n- Substring \"abba\", vowels = 1 ([\"a\"]), consonants = 1 ([\"b\"]).\n- Substring \"abba\", vowels = 1 ([\"a\"]), consonants = 1 ([\"b\"]).\n- Substring \"abba\", vowels = 2 ([\"a\",\"a\"]), consonants = 2 ([\"b\",\"b\"]).\nIt can be shown that there are only 3 beautiful substrings in the given string.", "**Input:** s = \"bcdf\", k = 1\n**Output:** 0\n**Explanation:** There are no beautiful substrings in the given string."], "constraints": "**Constraints:**\n\n\n* `1 <= s.length <= 5 * 104`\n* `1 <= k <= 1000`\n* `s` consists of only English lowercase letters.", "difficulty": "Hard", "tags": ["Hash Table", "Math", "String", "Number Theory", "Prefix Sum"], "hints": ["For the given <code>k</code> find all the <code>x</code> integers such that <code>x^2 % k == 0</code>. Notice, that there aren\u2019t many such candidates.", "We can iterate over all such <code>x</codes> values and count the number of substrings such that <code>vowels == consonants == x</code>.", "This can be done with prefix sums and hash map."], "templates": {"cpp": "class Solution {\npublic:\n    long long beautifulSubstrings(string s, int k) {\n        \n    }\n};", "java": "class Solution {\n    public long beautifulSubstrings(String s, int k) {\n        \n    }\n}", "python": "class Solution(object):\n    def beautifulSubstrings(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def beautifulSubstrings(self, s: str, k: int) -> int:\n        ", "c": "long long beautifulSubstrings(char* s, int k) {\n    \n}", "csharp": "public class Solution {\n    public long BeautifulSubstrings(string s, int k) {\n        \n    }\n}", "javascript": "/**\n * @param {string} s\n * @param {number} k\n * @return {number}\n */\nvar beautifulSubstrings = function(s, k) {\n    \n};", "typescript": "function beautifulSubstrings(s: string, k: number): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @param Integer $k\n     * @return Integer\n     */\n    function beautifulSubstrings($s, $k) {\n        \n    }\n}", "swift": "class Solution {\n    func beautifulSubstrings(_ s: String, _ k: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun beautifulSubstrings(s: String, k: Int): Long {\n        \n    }\n}", "dart": "class Solution {\n  int beautifulSubstrings(String s, int k) {\n    \n  }\n}", "golang": "func beautifulSubstrings(s string, k int) int64 {\n    \n}", "ruby": "# @param {String} s\n# @param {Integer} k\n# @return {Integer}\ndef beautiful_substrings(s, k)\n    \nend", "scala": "object Solution {\n    def beautifulSubstrings(s: String, k: Int): Long = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn beautiful_substrings(s: String, k: i32) -> i64 {\n        \n    }\n}", "racket": "(define/contract (beautiful-substrings s k)\n  (-> string? exact-integer? exact-integer?)\n  )", "erlang": "-spec beautiful_substrings(S :: unicode:unicode_binary(), K :: integer()) -> integer().\nbeautiful_substrings(S, K) ->\n  .", "elixir": "defmodule Solution do\n  @spec beautiful_substrings(s :: String.t, k :: integer) :: integer\n  def beautiful_substrings(s, k) do\n    \n  end\nend"}}
{"id": "leetcode_2945", "url": "https://leetcode.com/problems/find-maximum-non-decreasing-array-length/", "title": "Find Maximum Non-decreasing Array Length", "description": "You are given a **0-indexed** integer array `nums`.\n\n\nYou can perform any number of operations, where each operation involves selecting a **subarray** of the array and replacing it with the **sum** of its elements. For example, if the given array is `[1,3,5,6]` and you select subarray `[3,5]` the array will convert to `[1,8,6]`.\n\n\nReturn *the* ***maximum*** *length of a* ***non-decreasing*** *array that can be made after applying operations.*\n\n\nA **subarray** is a contiguous **non-empty** sequence of elements within an array.", "examples": ["**Input:** nums = [5,2,2]\n**Output:** 1\n**Explanation:** This array with length 3 is not non-decreasing.\nWe have two ways to make the array length two.\nFirst, choosing subarray [2,2] converts the array to [5,4].\nSecond, choosing subarray [5,2] converts the array to [7,2].\nIn these two ways the array is not non-decreasing.\nAnd if we choose subarray [5,2,2] and replace it with [9] it becomes non-decreasing. \nSo the answer is 1.", "**Input:** nums = [1,2,3,4]\n**Output:** 4\n**Explanation:** The array is non-decreasing. So the answer is 4.", "**Input:** nums = [4,3,2,6]\n**Output:** 3\n**Explanation:** Replacing [3,2] with [5] converts the given array to [4,5,6] that is non-decreasing.\nBecause the given array is not non-decreasing, the maximum possible answer is 3."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `1 <= nums[i] <= 105`", "difficulty": "Hard", "tags": ["Array", "Binary Search", "Dynamic Programming", "Stack", "Queue", "Monotonic Stack", "Monotonic Queue"], "hints": ["Let <code>dp[i]</code> be the maximum number of elements in the increasing sequence after processing the first <code>i</code> elements of the original array.", "We have <code>dp[0] = 0</code>. <code>dp[i + 1] >= dp[i]</code> (since if we have the solution for the first <code>i</code> elements, we can always merge the last one of the first <code>i + 1</code> elements which is <code>nums[i]</code> into the solution of the first <code>i</code> elements.", "For <code>i > 0</code>, we want to <code>dp[i] = max(dp[j] + 1)</code> where <code>sum(nums[i - 1] + nums[i - 2] +\u2026 + nums[j]) >= v[j]</code> and <code>v[j]</code> is the last element of the solution ending with <code>nums[j - 1]</code>."], "templates": {"cpp": "class Solution {\npublic:\n    int findMaximumLength(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public int findMaximumLength(int[] nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def findMaximumLength(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def findMaximumLength(self, nums: List[int]) -> int:\n        ", "c": "int findMaximumLength(int* nums, int numsSize) {\n    \n}", "csharp": "public class Solution {\n    public int FindMaximumLength(int[] nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMaximumLength = function(nums) {\n    \n};", "typescript": "function findMaximumLength(nums: number[]): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function findMaximumLength($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func findMaximumLength(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun findMaximumLength(nums: IntArray): Int {\n        \n    }\n}", "dart": "class Solution {\n  int findMaximumLength(List<int> nums) {\n    \n  }\n}", "golang": "func findMaximumLength(nums []int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef find_maximum_length(nums)\n    \nend", "scala": "object Solution {\n    def findMaximumLength(nums: Array[Int]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn find_maximum_length(nums: Vec<i32>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (find-maximum-length nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )", "erlang": "-spec find_maximum_length(Nums :: [integer()]) -> integer().\nfind_maximum_length(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec find_maximum_length(nums :: [integer]) :: integer\n  def find_maximum_length(nums) do\n    \n  end\nend"}}
{"id": "leetcode_2953", "url": "https://leetcode.com/problems/count-complete-substrings/", "title": "Count Complete Substrings", "description": "You are given a string `word` and an integer `k`.\n\n\nA substring `s` of `word` is **complete** if:\n\n\n* Each character in `s` occurs **exactly** `k` times.\n* The difference between two adjacent characters is **at most** `2`. That is, for any two adjacent characters `c1` and `c2` in `s`, the absolute difference in their positions in the alphabet is **at most** `2`.\n\n\nReturn *the number of **complete** substrings of* `word`.\n\n\nA **substring** is a **non-empty** contiguous sequence of characters in a string.", "examples": ["**Input:** word = \"igigee\", k = 2\n**Output:** 3\n**Explanation:** The complete substrings where each character appears exactly twice and the difference between adjacent characters is at most 2 are: **igig**ee, igig**ee**, **igigee**.", "**Input:** word = \"aaabbbccc\", k = 3\n**Output:** 6\n**Explanation:** The complete substrings where each character appears exactly three times and the difference between adjacent characters is at most 2 are: **aaa**bbbccc, aaa**bbb**ccc, aaabbb**ccc**, **aaabbb**ccc, aaa**bbbccc**, **aaabbbccc**."], "constraints": "**Constraints:**\n\n\n* `1 <= word.length <= 105`\n* `word` consists only of lowercase English letters.\n* `1 <= k <= word.length`", "difficulty": "Hard", "tags": ["Hash Table", "String", "Sliding Window"], "hints": ["There are at most 26 different lengths of the complete substrings: <code>k *1, k * 2, \u2026 k * 26</code>.****", "For each length, we can use sliding window to count the frequency of each letter in the window.", "We still need to check for all characters in the window that <code>abs(word[i] - word[i - 1]) <= 2</code>. We do this by maintaining the values of <code>abs(word[i] - word[i - 1])</code> in the sliding window dynamically in an ordered multiset or priority queue, so that we know the maximum value at each iteration."], "templates": {"cpp": "class Solution {\npublic:\n    int countCompleteSubstrings(string word, int k) {\n        \n    }\n};", "java": "class Solution {\n    public int countCompleteSubstrings(String word, int k) {\n        \n    }\n}", "python": "class Solution(object):\n    def countCompleteSubstrings(self, word, k):\n        \"\"\"\n        :type word: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def countCompleteSubstrings(self, word: str, k: int) -> int:\n        ", "c": "int countCompleteSubstrings(char* word, int k) {\n    \n}", "csharp": "public class Solution {\n    public int CountCompleteSubstrings(string word, int k) {\n        \n    }\n}", "javascript": "/**\n * @param {string} word\n * @param {number} k\n * @return {number}\n */\nvar countCompleteSubstrings = function(word, k) {\n    \n};", "typescript": "function countCompleteSubstrings(word: string, k: number): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param String $word\n     * @param Integer $k\n     * @return Integer\n     */\n    function countCompleteSubstrings($word, $k) {\n        \n    }\n}", "swift": "class Solution {\n    func countCompleteSubstrings(_ word: String, _ k: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun countCompleteSubstrings(word: String, k: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int countCompleteSubstrings(String word, int k) {\n    \n  }\n}", "golang": "func countCompleteSubstrings(word string, k int) int {\n    \n}", "ruby": "# @param {String} word\n# @param {Integer} k\n# @return {Integer}\ndef count_complete_substrings(word, k)\n    \nend", "scala": "object Solution {\n    def countCompleteSubstrings(word: String, k: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn count_complete_substrings(word: String, k: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (count-complete-substrings word k)\n  (-> string? exact-integer? exact-integer?)\n  )", "erlang": "-spec count_complete_substrings(Word :: unicode:unicode_binary(), K :: integer()) -> integer().\ncount_complete_substrings(Word, K) ->\n  .", "elixir": "defmodule Solution do\n  @spec count_complete_substrings(word :: String.t, k :: integer) :: integer\n  def count_complete_substrings(word, k) do\n    \n  end\nend"}}
{"id": "leetcode_2763", "url": "https://leetcode.com/problems/sum-of-imbalance-numbers-of-all-subarrays/", "title": "Sum of Imbalance Numbers of All Subarrays", "description": "The **imbalance number** of a **0-indexed** integer array `arr` of length `n` is defined as the number of indices in `sarr = sorted(arr)` such that:\n\n\n* `0 <= i < n - 1`, and\n* `sarr[i+1] - sarr[i] > 1`\n\n\nHere, `sorted(arr)` is the function that returns the sorted version of `arr`.\n\n\nGiven a **0-indexed** integer array `nums`, return *the **sum of imbalance numbers** of all its **subarrays***.\n\n\nA **subarray** is a contiguous **non-empty** sequence of elements within an array.", "examples": ["**Input:** nums = [2,3,1,4]\n**Output:** 3\n**Explanation:** There are 3 subarrays with non-zeroimbalance numbers:\n- Subarray [3, 1] with an imbalance number of 1.\n- Subarray [3, 1, 4] with an imbalance number of 1.\n- Subarray [1, 4] with an imbalance number of 1.\nThe imbalance number of all other subarrays is 0. Hence, the sum of imbalance numbers of all the subarrays of nums is 3.", "**Input:** nums = [1,3,3,3,5]\n**Output:** 8\n**Explanation:** There are 7 subarrays with non-zero imbalance numbers:\n- Subarray [1, 3] with an imbalance number of 1.\n- Subarray [1, 3, 3] with an imbalance number of 1.\n- Subarray [1, 3, 3, 3] with an imbalance number of 1.\n- Subarray [1, 3, 3, 3, 5] with an imbalance number of 2. \n- Subarray [3, 3, 3, 5] with an imbalance number of 1. \n- Subarray [3, 3, 5] with an imbalance number of 1.\n- Subarray [3, 5] with an imbalance number of 1.\nThe imbalance number of all other subarrays is 0. Hence, the sum of imbalance numbers of all the subarrays of nums is 8."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 1000`\n* `1 <= nums[i] <= nums.length`", "difficulty": "Hard", "tags": ["Array", "Hash Table", "Ordered Set"], "hints": ["Iterate over all subarrays in a nested fashion. Namely, for each left endpoint, start from nums[left] and add elements nums[left + 1], nums[left + 2], etc.", "To keep track of the imbalance value, maintain a set of added elements.", "Increment the imbalance value whenever a new number is not adjacent (+/- 1) to other old numbers. For example, when you add 3 to [1, 5], or when you add 5 to [1, 3]. For a formal proof, consider three cases: new value is (i) largest, (ii) smallest, (iii) between two old numbers.", "Decrement the imbalance value whenever a new number is adjacent (+/- 1) to two old numbers. For example, when you add 3 to [2, 4]. The imbalance value does not change in the case of one adjacent old number."], "templates": {"cpp": "class Solution {\npublic:\n    int sumImbalanceNumbers(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public int sumImbalanceNumbers(int[] nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def sumImbalanceNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def sumImbalanceNumbers(self, nums: List[int]) -> int:\n        ", "c": "int sumImbalanceNumbers(int* nums, int numsSize){\n\n}", "csharp": "public class Solution {\n    public int SumImbalanceNumbers(int[] nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar sumImbalanceNumbers = function(nums) {\n    \n};", "typescript": "function sumImbalanceNumbers(nums: number[]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function sumImbalanceNumbers($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func sumImbalanceNumbers(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun sumImbalanceNumbers(nums: IntArray): Int {\n        \n    }\n}", "dart": "class Solution {\n  int sumImbalanceNumbers(List<int> nums) {\n\n  }\n}", "golang": "func sumImbalanceNumbers(nums []int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef sum_imbalance_numbers(nums)\n    \nend", "scala": "object Solution {\n    def sumImbalanceNumbers(nums: Array[Int]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn sum_imbalance_numbers(nums: Vec<i32>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (sum-imbalance-numbers nums)\n  (-> (listof exact-integer?) exact-integer?)\n\n  )", "erlang": "-spec sum_imbalance_numbers(Nums :: [integer()]) -> integer().\nsum_imbalance_numbers(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec sum_imbalance_numbers(nums :: [integer]) :: integer\n  def sum_imbalance_numbers(nums) do\n\n  end\nend"}}
{"id": "leetcode_2827", "url": "https://leetcode.com/problems/number-of-beautiful-integers-in-the-range/", "title": "Number of Beautiful Integers in the Range", "description": "You are given positive integers `low`, `high`, and `k`.\n\n\nA number is **beautiful** if it meets both of the following conditions:\n\n\n* The count of even digits in the number is equal to the count of odd digits.\n* The number is divisible by `k`.\n\n\nReturn *the number of beautiful integers in the range* `[low, high]`.", "examples": ["**Input:** low = 10, high = 20, k = 3\n**Output:** 2\n**Explanation:** There are 2 beautiful integers in the given range: [12,18]. \n- 12 is beautiful because it contains 1 odd digit and 1 even digit, and is divisible by k = 3.\n- 18 is beautiful because it contains 1 odd digit and 1 even digit, and is divisible by k = 3.\nAdditionally we can see that:\n- 16 is not beautiful because it is not divisible by k = 3.\n- 15 is not beautiful because it does not contain equal counts even and odd digits.\nIt can be shown that there are only 2 beautiful integers in the given range.", "**Input:** low = 1, high = 10, k = 1\n**Output:** 1\n**Explanation:** There is 1 beautiful integer in the given range: [10].\n- 10 is beautiful because it contains 1 odd digit and 1 even digit, and is divisible by k = 1.\nIt can be shown that there is only 1 beautiful integer in the given range.", "**Input:** low = 5, high = 5, k = 2\n**Output:** 0\n**Explanation:** There are 0 beautiful integers in the given range.\n- 5 is not beautiful because it is not divisible by k = 2 and it does not contain equal even and odd digits."], "constraints": "**Constraints:**\n\n\n* `0 < low <= high <= 109`\n* `0 < k <= 20`", "difficulty": "Hard", "tags": ["Math", "Dynamic Programming"], "hints": ["<div class=\"_1l1MA\">The intended solution uses Dynamic Programming.</div>", "<div class=\"_1l1MA\">Let <code> f(n) </code> denote number of beautiful integers in the range <code> [1\u2026n] </code>, then the answer is <code> f(r) - f(l-1) </code>.</div>"], "templates": {"cpp": "class Solution {\npublic:\n    int numberOfBeautifulIntegers(int low, int high, int k) {\n        \n    }\n};", "java": "class Solution {\n    public int numberOfBeautifulIntegers(int low, int high, int k) {\n        \n    }\n}", "python": "class Solution(object):\n    def numberOfBeautifulIntegers(self, low, high, k):\n        \"\"\"\n        :type low: int\n        :type high: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def numberOfBeautifulIntegers(self, low: int, high: int, k: int) -> int:\n        ", "c": "int numberOfBeautifulIntegers(int low, int high, int k){\n\n}", "csharp": "public class Solution {\n    public int NumberOfBeautifulIntegers(int low, int high, int k) {\n        \n    }\n}", "javascript": "/**\n * @param {number} low\n * @param {number} high\n * @param {number} k\n * @return {number}\n */\nvar numberOfBeautifulIntegers = function(low, high, k) {\n    \n};", "typescript": "function numberOfBeautifulIntegers(low: number, high: number, k: number): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer $low\n     * @param Integer $high\n     * @param Integer $k\n     * @return Integer\n     */\n    function numberOfBeautifulIntegers($low, $high, $k) {\n        \n    }\n}", "swift": "class Solution {\n    func numberOfBeautifulIntegers(_ low: Int, _ high: Int, _ k: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun numberOfBeautifulIntegers(low: Int, high: Int, k: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int numberOfBeautifulIntegers(int low, int high, int k) {\n\n  }\n}", "golang": "func numberOfBeautifulIntegers(low int, high int, k int) int {\n    \n}", "ruby": "# @param {Integer} low\n# @param {Integer} high\n# @param {Integer} k\n# @return {Integer}\ndef number_of_beautiful_integers(low, high, k)\n    \nend", "scala": "object Solution {\n    def numberOfBeautifulIntegers(low: Int, high: Int, k: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn number_of_beautiful_integers(low: i32, high: i32, k: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (number-of-beautiful-integers low high k)\n  (-> exact-integer? exact-integer? exact-integer? exact-integer?)\n\n  )", "erlang": "-spec number_of_beautiful_integers(Low :: integer(), High :: integer(), K :: integer()) -> integer().\nnumber_of_beautiful_integers(Low, High, K) ->\n  .", "elixir": "defmodule Solution do\n  @spec number_of_beautiful_integers(low :: integer, high :: integer, k :: integer) :: integer\n  def number_of_beautiful_integers(low, high, k) do\n\n  end\nend"}}
{"id": "leetcode_2935", "url": "https://leetcode.com/problems/maximum-strong-pair-xor-ii/", "title": "Maximum Strong Pair XOR II", "description": "You are given a **0-indexed** integer array `nums`. A pair of integers `x` and `y` is called a **strong** pair if it satisfies the condition:\n\n\n* `|x - y| <= min(x, y)`\n\n\nYou need to select two integers from `nums` such that they form a strong pair and their bitwise `XOR` is the **maximum** among all strong pairs in the array.\n\n\nReturn *the **maximum*** `XOR` *value out of all possible strong pairs in the array* `nums`.\n\n\n**Note** that you can pick the same integer twice to form a pair.", "examples": ["**Input:** nums = [1,2,3,4,5]\n**Output:** 7\n**Explanation:** There are 11 strong pairs in the array nums: (1, 1), (1, 2), (2, 2), (2, 3), (2, 4), (3, 3), (3, 4), (3, 5), (4, 4), (4, 5) and (5, 5).\nThe maximum XOR possible from these pairs is 3 XOR 4 = 7.", "**Input:** nums = [10,100]\n**Output:** 0\n**Explanation:** There are 2 strong pairs in the array nums: (10, 10) and (100, 100).\nThe maximum XOR possible from these pairs is 10 XOR 10 = 0 since the pair (100, 100) also gives 100 XOR 100 = 0.", "**Input:** nums = [500,520,2500,3000]\n**Output:** 1020\n**Explanation:** There are 6 strong pairs in the array nums: (500, 500), (500, 520), (520, 520), (2500, 2500), (2500, 3000) and (3000, 3000).\nThe maximum XOR possible from these pairs is 500 XOR 520 = 1020 since the only other non-zero XOR value is 2500 XOR 3000 = 636."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 5 * 104`\n* `1 <= nums[i] <= 220 - 1`", "difficulty": "Hard", "tags": ["Array", "Hash Table", "Bit Manipulation", "Trie", "Sliding Window"], "hints": ["Sort the array, now let <code>x <= y</code> which means <code>|x - y| <= min(x, y)</code> can now be written as <code>y - x <= x</code> or in other words, <code>y <= 2 * x</code>.", "If <code>x</code> and <code>y</code> have the same number of bits, try making<code>y</code>\u2019s bits different from x if possible for each bit starting from the second most significant bit.", "If <code>y</code> has 1 more bit than <code>x</code> and <code>y <= 2 * x</code> use the idea about Digit DP to make <code>y</code>\u2019s prefix smaller than <code>2 * x + 1</code> as well as trying to make each bit different from <code>x</code> using a Hashmap.", "Alternatively, use Trie data structure to find the pair with maximum <code>XOR</code>."], "templates": {"cpp": "class Solution {\npublic:\n    int maximumStrongPairXor(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public int maximumStrongPairXor(int[] nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def maximumStrongPairXor(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def maximumStrongPairXor(self, nums: List[int]) -> int:\n        ", "c": "int maximumStrongPairXor(int* nums, int numsSize) {\n    \n}", "csharp": "public class Solution {\n    public int MaximumStrongPairXor(int[] nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maximumStrongPairXor = function(nums) {\n    \n};", "typescript": "function maximumStrongPairXor(nums: number[]): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function maximumStrongPairXor($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func maximumStrongPairXor(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun maximumStrongPairXor(nums: IntArray): Int {\n        \n    }\n}", "dart": "class Solution {\n  int maximumStrongPairXor(List<int> nums) {\n    \n  }\n}", "golang": "func maximumStrongPairXor(nums []int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef maximum_strong_pair_xor(nums)\n    \nend", "scala": "object Solution {\n    def maximumStrongPairXor(nums: Array[Int]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn maximum_strong_pair_xor(nums: Vec<i32>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (maximum-strong-pair-xor nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )", "erlang": "-spec maximum_strong_pair_xor(Nums :: [integer()]) -> integer().\nmaximum_strong_pair_xor(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec maximum_strong_pair_xor(nums :: [integer]) :: integer\n  def maximum_strong_pair_xor(nums) do\n    \n  end\nend"}}
{"id": "leetcode_2954", "url": "https://leetcode.com/problems/count-the-number-of-infection-sequences/", "title": "Count the Number of Infection Sequences", "description": "You are given an integer `n` and a **0-indexed**integer array `sick` which is **sorted** in **increasing** order.\n\n\nThere are `n` children standing in a queue with positions `0` to `n - 1` assigned to them. The array `sick` contains the positions of the children who are infected with an infectious disease. An infected child at position `i` can spread the disease to either of its immediate neighboring children at positions `i - 1` and `i + 1` **if** they exist and are currently not infected. **At most one** child who was previously not infected can get infected with the disease in one second.\n\n\nIt can be shown that after a finite number of seconds, all the children in the queue will get infected with the disease. An **infection sequence** is the sequential order of positions in which **all** of the non-infected children get infected with the disease. Return *the total number of possible infection sequences*.\n\n\nSince the answer may be large, return it modulo `109 + 7`.\n\n\n**Note** that an infection sequence **does not** contain positions of children who were already infected with the disease in the beginning.", "examples": ["**Input:** n = 5, sick = [0,4]\n**Output:** 4\n**Explanation:** Children at positions 1, 2, and 3 are not infected in the beginning. There are 4 possible infection sequences:\n- The children at positions 1 and 3 can get infected since their positions are adjacent to the infected children 0 and 4. The child at position 1 gets infected first.\nNow, the child at position 2 is adjacent to the child at position 1 who is infected and the child at position 3 is adjacent to the child at position 4 who is infected, hence either of them can get infected. The child at position 2 gets infected.\nFinally, the child at position 3 gets infected because it is adjacent to children at positions 2 and 4 who are infected. The infection sequence is [1,2,3].\n- The children at positions 1 and 3 can get infected because their positions are adjacent to the infected children 0 and 4. The child at position 1 gets infected first.\nNow, the child at position 2 is adjacent to the child at position 1 who is infected and the child at position 3 is adjacent to the child at position 4 who is infected, hence either of them can get infected. The child at position 3 gets infected.\nFinally, the child at position 2 gets infected because it is adjacent to children at positions 1 and 3 who are infected. The infection sequence is [1,3,2].\n- The infection sequence is [3,1,2]. The order of infection of disease in the children can be seen as: [0,1,2,3,4] => [0,1,2,3,4] => [0,1,2,3,4] => [0,1,2,3,4].\n- The infection sequence is [3,2,1]. The order of infection of disease in the children can be seen as: [0,1,2,3,4] => [0,1,2,3,4] => [0,1,2,3,4] => [0,1,2,3,4].", "**Input:** n = 4, sick = [1]\n**Output:** 3\n**Explanation:** Children at positions 0, 2, and 3 are not infected in the beginning. There are 3 possible infection sequences:\n- The infection sequence is [0,2,3]. The order of infection of disease in the children can be seen as: [0,1,2,3] => [0,1,2,3] => [0,1,2,3] => [0,1,2,3].\n- The infection sequence is [2,0,3]. The order of infection of disease in the children can be seen as: [0,1,2,3] => [0,1,2,3] => [0,1,2,3] => [0,1,2,3].\n- The infection sequence is [2,3,0]. The order of infection of disease in the children can be seen as: [0,1,2,3] => [0,1,2,3] => [0,1,2,3] => [0,1,2,3]."], "constraints": "**Constraints:**\n\n\n* `2 <= n <= 105`\n* `1 <= sick.length <= n - 1`\n* `0 <= sick[i] <= n - 1`\n* `sick` is sorted in increasing order.", "difficulty": "Hard", "tags": ["Array", "Math", "Combinatorics"], "hints": ["Consider infected children as <code>0</code> and non-infected as <code>1</code>, then divide the array into segments with the same value.", "For each segment of non-infected children whose indices are <code>[i, j]</code> and indices <code>(i - 1)</code> and <code>(j + 1)</code>, if they exist, are already infected. Then if <code>i == 0</code> or <code>j == n - 1</code>, each second there is only one kid that can be infected (which is at the other endpoint).", "If <code>i > 0</code> and <code>j < n - 1</code>, we have two choices per second since the children at the two endpoints can both be the infect candidates. So there are <code>2<sup>j - i + 1</sup></code> orders to infect all children in the segment.", "Each second we can select a segment and select one endpoint from it.", "The answer is: \r\n<code>S! / (len[1]! * len[2]! * ... * len[m]!) * 2<sup>k</sup></code> \r\nwhere <code>len[1], len[2], ..., len[m]</code> are the lengths of each segment of non-infected children that have an infected child at both endpoints, <code>S</code> is the total length of all segments of non-infected children, and <code>k = (len[1] - 1) + (len[2] - 1) + ... + (len[m] - 1)</code>."], "templates": {"cpp": "class Solution {\npublic:\n    int numberOfSequence(int n, vector<int>& sick) {\n        \n    }\n};", "java": "class Solution {\n    public int numberOfSequence(int n, int[] sick) {\n        \n    }\n}", "python": "class Solution(object):\n    def numberOfSequence(self, n, sick):\n        \"\"\"\n        :type n: int\n        :type sick: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def numberOfSequence(self, n: int, sick: List[int]) -> int:\n        ", "c": "int numberOfSequence(int n, int* sick, int sickSize) {\n    \n}", "csharp": "public class Solution {\n    public int NumberOfSequence(int n, int[] sick) {\n        \n    }\n}", "javascript": "/**\n * @param {number} n\n * @param {number[]} sick\n * @return {number}\n */\nvar numberOfSequence = function(n, sick) {\n    \n};", "typescript": "function numberOfSequence(n: number, sick: number[]): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[] $sick\n     * @return Integer\n     */\n    function numberOfSequence($n, $sick) {\n        \n    }\n}", "swift": "class Solution {\n    func numberOfSequence(_ n: Int, _ sick: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun numberOfSequence(n: Int, sick: IntArray): Int {\n        \n    }\n}", "dart": "class Solution {\n  int numberOfSequence(int n, List<int> sick) {\n    \n  }\n}", "golang": "func numberOfSequence(n int, sick []int) int {\n    \n}", "ruby": "# @param {Integer} n\n# @param {Integer[]} sick\n# @return {Integer}\ndef number_of_sequence(n, sick)\n    \nend", "scala": "object Solution {\n    def numberOfSequence(n: Int, sick: Array[Int]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn number_of_sequence(n: i32, sick: Vec<i32>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (number-of-sequence n sick)\n  (-> exact-integer? (listof exact-integer?) exact-integer?)\n  )", "erlang": "-spec number_of_sequence(N :: integer(), Sick :: [integer()]) -> integer().\nnumber_of_sequence(N, Sick) ->\n  .", "elixir": "defmodule Solution do\n  @spec number_of_sequence(n :: integer, sick :: [integer]) :: integer\n  def number_of_sequence(n, sick) do\n    \n  end\nend"}}
{"id": "leetcode_2742", "url": "https://leetcode.com/problems/painting-the-walls/", "title": "Painting the Walls", "description": "You are given two **0-indexed** integer arrays,\u00a0`cost` and `time`, of size `n` representing the costs and the time taken to paint `n` different walls respectively. There are two painters available:\n\n\n* A**paid painter**\u00a0that paints the `ith` wall in `time[i]` units of time and takes `cost[i]` units of money.\n* A**free painter** that paints\u00a0**any** wall in `1` unit of time at a cost of `0`. But the\u00a0free painter can only be used if the paid painter is already **occupied**.\n\n\nReturn *the minimum amount of money required to paint the* `n`*walls.*", "examples": ["**Input:** cost = [1,2,3,2], time = [1,2,3,2]\n**Output:** 3\n**Explanation:** The walls at index 0 and 1 will be painted by the paid painter, and it will take 3 units of time; meanwhile, the free painter will paint the walls at index 2 and 3, free of cost in 2 units of time. Thus, the total cost is 1 + 2 = 3.", "**Input:** cost = [2,3,4,2], time = [1,1,1,1]\n**Output:** 4\n**Explanation:** The walls at index 0 and 3 will be painted by the paid painter, and it will take 2 units of time; meanwhile, the free painter will paint the walls at index 1 and 2, free of cost in 2 units of time. Thus, the total cost is 2 + 2 = 4."], "constraints": "**Constraints:**\n\n\n* `1 <= cost.length <= 500`\n* `cost.length == time.length`\n* `1 <= cost[i] <= 106`\n* `1 <= time[i] <= 500`", "difficulty": "Hard", "tags": ["Array", "Dynamic Programming"], "hints": ["Can we break the problem down into smaller subproblems and use DP?", "Paid painters will be used for a maximum of N/2 units of time. There is no need to use paid painter for a time greater than this."], "templates": {"cpp": "class Solution {\npublic:\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n        \n    }\n};", "java": "class Solution {\n    public int paintWalls(int[] cost, int[] time) {\n        \n    }\n}", "python": "class Solution(object):\n    def paintWalls(self, cost, time):\n        \"\"\"\n        :type cost: List[int]\n        :type time: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\n        ", "c": "int paintWalls(int* cost, int costSize, int* time, int timeSize){\n\n}", "csharp": "public class Solution {\n    public int PaintWalls(int[] cost, int[] time) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} cost\n * @param {number[]} time\n * @return {number}\n */\nvar paintWalls = function(cost, time) {\n    \n};", "typescript": "function paintWalls(cost: number[], time: number[]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $cost\n     * @param Integer[] $time\n     * @return Integer\n     */\n    function paintWalls($cost, $time) {\n        \n    }\n}", "swift": "class Solution {\n    func paintWalls(_ cost: [Int], _ time: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun paintWalls(cost: IntArray, time: IntArray): Int {\n        \n    }\n}", "dart": "class Solution {\n  int paintWalls(List<int> cost, List<int> time) {\n\n  }\n}", "golang": "func paintWalls(cost []int, time []int) int {\n    \n}", "ruby": "# @param {Integer[]} cost\n# @param {Integer[]} time\n# @return {Integer}\ndef paint_walls(cost, time)\n    \nend", "scala": "object Solution {\n    def paintWalls(cost: Array[Int], time: Array[Int]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn paint_walls(cost: Vec<i32>, time: Vec<i32>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (paint-walls cost time)\n  (-> (listof exact-integer?) (listof exact-integer?) exact-integer?)\n\n  )", "erlang": "-spec paint_walls(Cost :: [integer()], Time :: [integer()]) -> integer().\npaint_walls(Cost, Time) ->\n  .", "elixir": "defmodule Solution do\n  @spec paint_walls(cost :: [integer], time :: [integer]) :: integer\n  def paint_walls(cost, time) do\n\n  end\nend"}}
{"id": "leetcode_2781", "url": "https://leetcode.com/problems/length-of-the-longest-valid-substring/", "title": "Length of the Longest Valid Substring", "description": "You are given a string `word` and an array of strings `forbidden`.\n\n\nA string is called **valid** if none of its substrings are present in `forbidden`.\n\n\nReturn *the length of the **longest valid substring** of the string* `word`.\n\n\nA **substring** is a contiguous sequence of characters in a string, possibly empty.", "examples": ["**Input:** word = \"cbaaaabc\", forbidden = [\"aaa\",\"cb\"]\n**Output:** 4\n**Explanation:** There are 11 valid substrings in word: \"c\", \"b\", \"a\", \"ba\", \"aa\", \"bc\", \"baa\", \"aab\", \"ab\", \"abc\" and \"aabc\". The length of the longest valid substring is 4. \nIt can be shown that all other substrings contain either \"aaa\" or \"cb\" as a substring.", "**Input:** word = \"leetcode\", forbidden = [\"de\",\"le\",\"e\"]\n**Output:** 4\n**Explanation:** There are 11 valid substrings in word: \"l\", \"t\", \"c\", \"o\", \"d\", \"tc\", \"co\", \"od\", \"tco\", \"cod\", and \"tcod\". The length of the longest valid substring is 4.\nIt can be shown that all other substrings contain either \"de\", \"le\", or \"e\" as a substring."], "constraints": "**Constraints:**\n\n\n* `1 <= word.length <= 105`\n* `word` consists only of lowercase English letters.\n* `1 <= forbidden.length <= 105`\n* `1 <= forbidden[i].length <= 10`\n* `forbidden[i]` consists only of lowercase English letters.", "difficulty": "Hard", "tags": ["Array", "Hash Table", "String", "Sliding Window"], "hints": [], "templates": {"cpp": "class Solution {\npublic:\n    int longestValidSubstring(string word, vector<string>& forbidden) {\n        \n    }\n};", "java": "class Solution {\n    public int longestValidSubstring(String word, List<String> forbidden) {\n        \n    }\n}", "python": "class Solution(object):\n    def longestValidSubstring(self, word, forbidden):\n        \"\"\"\n        :type word: str\n        :type forbidden: List[str]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        ", "c": "int longestValidSubstring(char * word, char ** forbidden, int forbiddenSize){\n\n}", "csharp": "public class Solution {\n    public int LongestValidSubstring(string word, IList<string> forbidden) {\n        \n    }\n}", "javascript": "/**\n * @param {string} word\n * @param {string[]} forbidden\n * @return {number}\n */\nvar longestValidSubstring = function(word, forbidden) {\n    \n};", "typescript": "function longestValidSubstring(word: string, forbidden: string[]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param String $word\n     * @param String[] $forbidden\n     * @return Integer\n     */\n    function longestValidSubstring($word, $forbidden) {\n        \n    }\n}", "swift": "class Solution {\n    func longestValidSubstring(_ word: String, _ forbidden: [String]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun longestValidSubstring(word: String, forbidden: List<String>): Int {\n        \n    }\n}", "dart": "class Solution {\n  int longestValidSubstring(String word, List<String> forbidden) {\n\n  }\n}", "golang": "func longestValidSubstring(word string, forbidden []string) int {\n    \n}", "ruby": "# @param {String} word\n# @param {String[]} forbidden\n# @return {Integer}\ndef longest_valid_substring(word, forbidden)\n    \nend", "scala": "object Solution {\n    def longestValidSubstring(word: String, forbidden: List[String]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn longest_valid_substring(word: String, forbidden: Vec<String>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (longest-valid-substring word forbidden)\n  (-> string? (listof string?) exact-integer?)\n\n  )", "erlang": "-spec longest_valid_substring(Word :: unicode:unicode_binary(), Forbidden :: [unicode:unicode_binary()]) -> integer().\nlongest_valid_substring(Word, Forbidden) ->\n  .", "elixir": "defmodule Solution do\n  @spec longest_valid_substring(word :: String.t, forbidden :: [String.t]) :: integer\n  def longest_valid_substring(word, forbidden) do\n\n  end\nend"}}
{"id": "leetcode_2851", "url": "https://leetcode.com/problems/string-transformation/", "title": "String Transformation", "description": "You are given two strings `s` and `t` of equal length `n`. You can perform the following operation on the string `s`:\n\n\n* Remove a **suffix** of `s` of length `l` where `0 < l < n` and append it at the start of `s`.  \n\n For example, let `s = 'abcd'` then in one operation you can remove the suffix `'cd'` and append it in front of `s` making `s = 'cdab'`.\n\n\nYou are also given an integer `k`. Return *the number of ways in which* `s` *can be transformed into* `t` *in **exactly*** `k` *operations.*\n\n\nSince the answer can be large, return it **modulo** `109 + 7`.", "examples": ["**Input:** s = \"abcd\", t = \"cdab\", k = 2\n**Output:** 2\n**Explanation:** \nFirst way:\nIn first operation, choose suffix from index = 3, so resulting s = \"dabc\".\nIn second operation, choose suffix from index = 3, so resulting s = \"cdab\".\n\nSecond way:\nIn first operation, choose suffix from index = 1, so resulting s = \"bcda\".\nIn second operation, choose suffix from index = 1, so resulting s = \"cdab\".", "**Input:** s = \"ababab\", t = \"ababab\", k = 1\n**Output:** 2\n**Explanation:** \nFirst way:\nChoose suffix from index = 2, so resulting s = \"ababab\".\n\nSecond way:\nChoose suffix from index = 4, so resulting s = \"ababab\"."], "constraints": "**Constraints:**\n\n\n* `2 <= s.length <= 5 * 105`\n* `1 <= k <= 1015`\n* `s.length == t.length`\n* `s` and `t` consist of only lowercase English alphabets.", "difficulty": "Hard", "tags": ["Math", "String", "Dynamic Programming", "String Matching"], "hints": ["String <code>t</code> can be only constructed if it is a rotated version of string <code>s</code>.", "Use KMP algorithm or Z algorithm to find the number of indices from where <code>s</code> is equal to <code>t</code>.", "Use Dynamic Programming to count the number of ways."], "templates": {"cpp": "class Solution {\npublic:\n    int numberOfWays(string s, string t, long long k) {\n        \n    }\n};", "java": "class Solution {\n    public int numberOfWays(String s, String t, long k) {\n        \n    }\n}", "python": "class Solution(object):\n    def numberOfWays(self, s, t, k):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def numberOfWays(self, s: str, t: str, k: int) -> int:\n        ", "c": "int numberOfWays(char* s, char* t, long long k){\n\n}", "csharp": "public class Solution {\n    public int NumberOfWays(string s, string t, long k) {\n        \n    }\n}", "javascript": "/**\n * @param {string} s\n * @param {string} t\n * @param {number} k\n * @return {number}\n */\nvar numberOfWays = function(s, t, k) {\n    \n};", "typescript": "function numberOfWays(s: string, t: string, k: number): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @param String $t\n     * @param Integer $k\n     * @return Integer\n     */\n    function numberOfWays($s, $t, $k) {\n        \n    }\n}", "swift": "class Solution {\n    func numberOfWays(_ s: String, _ t: String, _ k: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun numberOfWays(s: String, t: String, k: Long): Int {\n        \n    }\n}", "dart": "class Solution {\n  int numberOfWays(String s, String t, int k) {\n\n  }\n}", "golang": "func numberOfWays(s string, t string, k int64) int {\n    \n}", "ruby": "# @param {String} s\n# @param {String} t\n# @param {Integer} k\n# @return {Integer}\ndef number_of_ways(s, t, k)\n    \nend", "scala": "object Solution {\n    def numberOfWays(s: String, t: String, k: Long): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn number_of_ways(s: String, t: String, k: i64) -> i32 {\n        \n    }\n}", "racket": "(define/contract (number-of-ways s t k)\n  (-> string? string? exact-integer? exact-integer?)\n\n  )", "erlang": "-spec number_of_ways(S :: unicode:unicode_binary(), T :: unicode:unicode_binary(), K :: integer()) -> integer().\nnumber_of_ways(S, T, K) ->\n  .", "elixir": "defmodule Solution do\n  @spec number_of_ways(s :: String.t, t :: String.t, k :: integer) :: integer\n  def number_of_ways(s, t, k) do\n\n  end\nend"}}
{"id": "leetcode_2902", "url": "https://leetcode.com/problems/count-of-sub-multisets-with-bounded-sum/", "title": "Count of Sub-Multisets With Bounded Sum", "description": "You are given a **0-indexed** array `nums` of non-negative integers, and two integers `l` and `r`.\n\n\nReturn *the **count of sub-multisets** within* `nums` *where the sum of elements in each subset falls within the inclusive range of* `[l, r]`.\n\n\nSince the answer may be large, return it modulo `109 + 7`.\n\n\nA **sub-multiset** is an **unordered** collection of elements of the array in which a given value `x` can occur `0, 1, ..., occ[x]` times, where `occ[x]` is the number of occurrences of `x` in the array.\n\n\n**Note** that:\n\n\n* Two **sub-multisets** are the same if sorting both sub-multisets results in identical multisets.\n* The sum of an **empty** multiset is `0`.", "examples": ["**Input:** nums = [1,2,2,3], l = 6, r = 6\n**Output:** 1\n**Explanation:** The only subset of nums that has a sum of 6 is {1, 2, 3}.", "**Input:** nums = [2,1,4,2,7], l = 1, r = 5\n**Output:** 7\n**Explanation:** The subsets of nums that have a sum within the range [1, 5] are {1}, {2}, {4}, {2, 2}, {1, 2}, {1, 4}, and {1, 2, 2}.", "**Input:** nums = [1,2,1,3,5,2], l = 3, r = 5\n**Output:** 9\n**Explanation:** The subsets of nums that have a sum within the range [3, 5] are {3}, {5}, {1, 2}, {1, 3}, {2, 2}, {2, 3}, {1, 1, 2}, {1, 1, 3}, and {1, 2, 2}."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 2 * 104`\n* `0 <= nums[i] <= 2 * 104`\n* Sum of `nums` does not exceed `2 * 104`.\n* `0 <= l <= r <= 2 * 104`", "difficulty": "Hard", "tags": ["Array", "Hash Table", "Dynamic Programming", "Sliding Window"], "hints": ["Since the sum of\u00a0<code>nums</code>is at most\u00a0<code>20000</code>, the number of distinct elements of nums is <code>200</code>.", "Let <code>dp[x]</code> be the number of submultisets of <code>nums</code> with sum <code>x</code>.", "The answer to the problem is <code>dp[l] + dp[l+1] + \u2026 + dp[r]</code>.", "Use coin change dp to transition between states."], "templates": {"cpp": "class Solution {\npublic:\n    int countSubMultisets(vector<int>& nums, int l, int r) {\n        \n    }\n};", "java": "class Solution {\n    public int countSubMultisets(List<Integer> nums, int l, int r) {\n        \n    }\n}", "python": "class Solution(object):\n    def countSubMultisets(self, nums, l, r):\n        \"\"\"\n        :type nums: List[int]\n        :type l: int\n        :type r: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def countSubMultisets(self, nums: List[int], l: int, r: int) -> int:\n        ", "c": "int countSubMultisets(int* nums, int numsSize, int l, int r) {\n    \n}", "csharp": "public class Solution {\n    public int CountSubMultisets(IList<int> nums, int l, int r) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @param {number} l\n * @param {number} r\n * @return {number}\n */\nvar countSubMultisets = function(nums, l, r) {\n    \n};", "typescript": "function countSubMultisets(nums: number[], l: number, r: number): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $l\n     * @param Integer $r\n     * @return Integer\n     */\n    function countSubMultisets($nums, $l, $r) {\n        \n    }\n}", "swift": "class Solution {\n    func countSubMultisets(_ nums: [Int], _ l: Int, _ r: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun countSubMultisets(nums: List<Int>, l: Int, r: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int countSubMultisets(List<int> nums, int l, int r) {\n    \n  }\n}", "golang": "func countSubMultisets(nums []int, l int, r int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @param {Integer} l\n# @param {Integer} r\n# @return {Integer}\ndef count_sub_multisets(nums, l, r)\n    \nend", "scala": "object Solution {\n    def countSubMultisets(nums: List[Int], l: Int, r: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn count_sub_multisets(nums: Vec<i32>, l: i32, r: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (count-sub-multisets nums l r)\n  (-> (listof exact-integer?) exact-integer? exact-integer? exact-integer?)\n  )", "erlang": "-spec count_sub_multisets(Nums :: [integer()], L :: integer(), R :: integer()) -> integer().\ncount_sub_multisets(Nums, L, R) ->\n  .", "elixir": "defmodule Solution do\n  @spec count_sub_multisets(nums :: [integer], l :: integer, r :: integer) :: integer\n  def count_sub_multisets(nums, l, r) do\n    \n  end\nend"}}
{"id": "leetcode_2963", "url": "https://leetcode.com/problems/count-the-number-of-good-partitions/", "title": "Count the Number of Good Partitions", "description": "You are given a **0-indexed** array `nums` consisting of **positive** integers.\n\n\nA partition of an array into one or more **contiguous** subarrays is called **good** if no two subarrays contain the same number.\n\n\nReturn *the **total number** of good partitions of* `nums`.\n\n\nSince the answer may be large, return it **modulo** `109 + 7`.", "examples": ["**Input:** nums = [1,2,3,4]\n**Output:** 8\n**Explanation:** The 8 possible good partitions are: ([1], [2], [3], [4]), ([1], [2], [3,4]), ([1], [2,3], [4]), ([1], [2,3,4]), ([1,2], [3], [4]), ([1,2], [3,4]), ([1,2,3], [4]), and ([1,2,3,4]).", "**Input:** nums = [1,1,1,1]\n**Output:** 1\n**Explanation:** The only possible good partition is: ([1,1,1,1]).", "**Input:** nums = [1,2,1,3]\n**Output:** 2\n**Explanation:** The 2 possible good partitions are: ([1,2,1], [3]) and ([1,2,1,3])."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `1 <= nums[i] <= 109`", "difficulty": "Hard", "tags": ["Array", "Hash Table", "Math", "Combinatorics"], "hints": ["If a segment contains a value, it must contain all occurrences of the same value.", "Partition the array into segments making each one as short as possible. This can be achieved by two-pointers or using a Set.", "If we have <code>m</code> segments, we can arbitrarily group the neighboring segments. How many ways are there to group these <code>m</code> segments?"], "templates": {"cpp": "class Solution {\npublic:\n    int numberOfGoodPartitions(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public int numberOfGoodPartitions(int[] nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def numberOfGoodPartitions(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def numberOfGoodPartitions(self, nums: List[int]) -> int:\n        ", "c": "int numberOfGoodPartitions(int* nums, int numsSize) {\n    \n}", "csharp": "public class Solution {\n    public int NumberOfGoodPartitions(int[] nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numberOfGoodPartitions = function(nums) {\n    \n};", "typescript": "function numberOfGoodPartitions(nums: number[]): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function numberOfGoodPartitions($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func numberOfGoodPartitions(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun numberOfGoodPartitions(nums: IntArray): Int {\n        \n    }\n}", "dart": "class Solution {\n  int numberOfGoodPartitions(List<int> nums) {\n    \n  }\n}", "golang": "func numberOfGoodPartitions(nums []int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef number_of_good_partitions(nums)\n    \nend", "scala": "object Solution {\n    def numberOfGoodPartitions(nums: Array[Int]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn number_of_good_partitions(nums: Vec<i32>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (number-of-good-partitions nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )", "erlang": "-spec number_of_good_partitions(Nums :: [integer()]) -> integer().\nnumber_of_good_partitions(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec number_of_good_partitions(nums :: [integer]) :: integer\n  def number_of_good_partitions(nums) do\n    \n  end\nend"}}
{"id": "leetcode_2719", "url": "https://leetcode.com/problems/count-of-integers/", "title": "Count of Integers", "description": "You are given two numeric strings `num1` and `num2` and two integers `max_sum` and `min_sum`. We denote an integer `x` to be *good* if:\n\n\n* `num1 <= x <= num2`\n* `min_sum <= digit_sum(x) <= max_sum`.\n\n\nReturn *the number of good integers*. Since the answer may be large, return it modulo `109 + 7`.\n\n\nNote that `digit_sum(x)` denotes the sum of the digits of `x`.", "examples": ["**Input:** num1 = \"1\", num2 = \"12\", min_sum = 1, max_sum = 8\n**Output:** 11\n**Explanation:** There are 11 integers whose sum of digits lies between 1 and 8 are 1,2,3,4,5,6,7,8,10,11, and 12. Thus, we return 11.", "**Input:** num1 = \"1\", num2 = \"5\", min_sum = 1, max_sum = 5\n**Output:** 5\n**Explanation:** The 5 integers whose sum of digits lies between 1 and 5 are 1,2,3,4, and 5. Thus, we return 5."], "constraints": "**Constraints:**\n\n\n* `1 <= num1 <= num2 <= 1022`\n* `1 <= min_sum <= max_sum <= 400`", "difficulty": "Hard", "tags": ["Math", "String", "Dynamic Programming"], "hints": ["Let f(n, l, r) denotes the number of integers from 1 to n with the sum of digits between l and r.", "The answer is f(num2, min_sum, max_sum) - f(num-1, min_sum, max_sum).", "You can calculate f(n, l, r) using digit dp."], "templates": {"cpp": "class Solution {\npublic:\n    int count(string num1, string num2, int min_sum, int max_sum) {\n        \n    }\n};", "java": "class Solution {\n    public int count(String num1, String num2, int min_sum, int max_sum) {\n        \n    }\n}", "python": "class Solution(object):\n    def count(self, num1, num2, min_sum, max_sum):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :type min_sum: int\n        :type max_sum: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\n        ", "c": "int count(char * num1, char * num2, int min_sum, int max_sum){\n\n}", "csharp": "public class Solution {\n    public int Count(string num1, string num2, int min_sum, int max_sum) {\n        \n    }\n}", "javascript": "/**\n * @param {string} num1\n * @param {string} num2\n * @param {number} min_sum\n * @param {number} max_sum\n * @return {number}\n */\nvar count = function(num1, num2, min_sum, max_sum) {\n    \n};", "typescript": "function count(num1: string, num2: string, min_sum: number, max_sum: number): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param String $num1\n     * @param String $num2\n     * @param Integer $min_sum\n     * @param Integer $max_sum\n     * @return Integer\n     */\n    function count($num1, $num2, $min_sum, $max_sum) {\n        \n    }\n}", "swift": "class Solution {\n    func count(_ num1: String, _ num2: String, _ min_sum: Int, _ max_sum: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun count(num1: String, num2: String, min_sum: Int, max_sum: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int count(String num1, String num2, int min_sum, int max_sum) {\n\n  }\n}", "golang": "func count(num1 string, num2 string, min_sum int, max_sum int) int {\n    \n}", "ruby": "# @param {String} num1\n# @param {String} num2\n# @param {Integer} min_sum\n# @param {Integer} max_sum\n# @return {Integer}\ndef count(num1, num2, min_sum, max_sum)\n    \nend", "scala": "object Solution {\n    def count(num1: String, num2: String, min_sum: Int, max_sum: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn count(num1: String, num2: String, min_sum: i32, max_sum: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (count num1 num2 min_sum max_sum)\n  (-> string? string? exact-integer? exact-integer? exact-integer?)\n\n  )", "erlang": "-spec count(Num1 :: unicode:unicode_binary(), Num2 :: unicode:unicode_binary(), Min_sum :: integer(), Max_sum :: integer()) -> integer().\ncount(Num1, Num2, Min_sum, Max_sum) ->\n  .", "elixir": "defmodule Solution do\n  @spec count(num1 :: String.t, num2 :: String.t, min_sum :: integer, max_sum :: integer) :: integer\n  def count(num1, num2, min_sum, max_sum) do\n\n  end\nend"}}
