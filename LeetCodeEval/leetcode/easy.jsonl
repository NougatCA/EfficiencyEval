{"id": "leetcode_2833", "url": "https://leetcode.com/problems/furthest-point-from-origin/", "title": "Furthest Point From Origin", "description": "You are given a string `moves` of length `n` consisting only of characters `'L'`, `'R'`, and `'_'`. The string represents your movement on a number line starting from the origin `0`.\n\n\nIn the `ith` move, you can choose one of the following directions:\n\n\n* move to the left if `moves[i] = 'L'` or `moves[i] = '_'`\n* move to the right if `moves[i] = 'R'` or `moves[i] = '_'`\n\n\nReturn *the **distance from the origin** of the **furthest** point you can get to after* `n` *moves*.", "examples": ["**Input:** moves = \"L_RL__R\"\n**Output:** 3\n**Explanation:** The furthest point we can reach from the origin 0 is point -3 through the following sequence of moves \"LLRLLLR\".", "**Input:** moves = \"_R__LL_\"\n**Output:** 5\n**Explanation:** The furthest point we can reach from the origin 0 is point -5 through the following sequence of moves \"LRLLLLL\".", "**Input:** moves = \"_______\"\n**Output:** 7\n**Explanation:** The furthest point we can reach from the origin 0 is point 7 through the following sequence of moves \"RRRRRRR\"."], "constraints": "**Constraints:**\n\n\n* `1 <= moves.length == n <= 50`\n* `moves` consists only of characters `'L'`, `'R'` and `'_'`.", "difficulty": "Easy", "tags": ["Array", "Counting"], "hints": ["<div class=\"_1l1MA\">In an optimal answer, all occurrences of <code>'_\u2019</code>\u00a0will be replaced with the <strong>same</strong> character.</div>", "<div class=\"_1l1MA\">Replace all characters of <code>'_\u2019</code>\u00a0with the character that occurs the most.\u00a0</div>"], "templates": {"cpp": "class Solution {\npublic:\n    int furthestDistanceFromOrigin(string moves) {\n        \n    }\n};", "java": "class Solution {\n    public int furthestDistanceFromOrigin(String moves) {\n        \n    }\n}", "python": "class Solution(object):\n    def furthestDistanceFromOrigin(self, moves):\n        \"\"\"\n        :type moves: str\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def furthestDistanceFromOrigin(self, moves: str) -> int:\n        ", "c": "int furthestDistanceFromOrigin(char * moves){\n\n}", "csharp": "public class Solution {\n    public int FurthestDistanceFromOrigin(string moves) {\n        \n    }\n}", "javascript": "/**\n * @param {string} moves\n * @return {number}\n */\nvar furthestDistanceFromOrigin = function(moves) {\n    \n};", "typescript": "function furthestDistanceFromOrigin(moves: string): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param String $moves\n     * @return Integer\n     */\n    function furthestDistanceFromOrigin($moves) {\n        \n    }\n}", "swift": "class Solution {\n    func furthestDistanceFromOrigin(_ moves: String) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun furthestDistanceFromOrigin(moves: String): Int {\n        \n    }\n}", "dart": "class Solution {\n  int furthestDistanceFromOrigin(String moves) {\n\n  }\n}", "golang": "func furthestDistanceFromOrigin(moves string) int {\n    \n}", "ruby": "# @param {String} moves\n# @return {Integer}\ndef furthest_distance_from_origin(moves)\n    \nend", "scala": "object Solution {\n    def furthestDistanceFromOrigin(moves: String): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn furthest_distance_from_origin(moves: String) -> i32 {\n        \n    }\n}", "racket": "(define/contract (furthest-distance-from-origin moves)\n  (-> string? exact-integer?)\n\n  )", "erlang": "-spec furthest_distance_from_origin(Moves :: unicode:unicode_binary()) -> integer().\nfurthest_distance_from_origin(Moves) ->\n  .", "elixir": "defmodule Solution do\n  @spec furthest_distance_from_origin(moves :: String.t) :: integer\n  def furthest_distance_from_origin(moves) do\n\n  end\nend"}}
{"id": "leetcode_2864", "url": "https://leetcode.com/problems/maximum-odd-binary-number/", "title": "Maximum Odd Binary Number", "description": "You are given a **binary** string `s` that contains at least one `'1'`.\n\n\nYou have to **rearrange** the bits in such a way that the resulting binary number is the **maximum odd binary number** that can be created from this combination.\n\n\nReturn *a string representing the maximum odd binary number that can be created from the given combination.*\n\n\n**Note** that the resulting string **can** have leading zeros.", "examples": ["**Input:** s = \"010\"\n**Output:** \"001\"\n**Explanation:** Because there is just one '1', it must be in the last position. So the answer is \"001\".", "**Input:** s = \"0101\"\n**Output:** \"1001\"\n**Explanation:** One of the '1's must be in the last position. The maximum number that can be made with the remaining digits is \"100\". So the answer is \"1001\"."], "constraints": "**Constraints:**\n\n\n* `1 <= s.length <= 100`\n* `s` consists only of `'0'` and `'1'`.\n* `s` contains at least one `'1'`.", "difficulty": "Easy", "tags": ["Math", "String", "Greedy"], "hints": ["The binary representation of an odd number contains <code>'1'</code> in the least significant place."], "templates": {"cpp": "class Solution {\npublic:\n    string maximumOddBinaryNumber(string s) {\n        \n    }\n};", "java": "class Solution {\n    public String maximumOddBinaryNumber(String s) {\n        \n    }\n}", "python": "class Solution(object):\n    def maximumOddBinaryNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        ", "python3": "class Solution:\n    def maximumOddBinaryNumber(self, s: str) -> str:\n        ", "c": "char* maximumOddBinaryNumber(char* s){\n\n}", "csharp": "public class Solution {\n    public string MaximumOddBinaryNumber(string s) {\n        \n    }\n}", "javascript": "/**\n * @param {string} s\n * @return {string}\n */\nvar maximumOddBinaryNumber = function(s) {\n    \n};", "typescript": "function maximumOddBinaryNumber(s: string): string {\n\n};", "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @return String\n     */\n    function maximumOddBinaryNumber($s) {\n        \n    }\n}", "swift": "class Solution {\n    func maximumOddBinaryNumber(_ s: String) -> String {\n        \n    }\n}", "kotlin": "class Solution {\n    fun maximumOddBinaryNumber(s: String): String {\n        \n    }\n}", "dart": "class Solution {\n  String maximumOddBinaryNumber(String s) {\n\n  }\n}", "golang": "func maximumOddBinaryNumber(s string) string {\n    \n}", "ruby": "# @param {String} s\n# @return {String}\ndef maximum_odd_binary_number(s)\n    \nend", "scala": "object Solution {\n    def maximumOddBinaryNumber(s: String): String = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn maximum_odd_binary_number(s: String) -> String {\n        \n    }\n}", "racket": "(define/contract (maximum-odd-binary-number s)\n  (-> string? string?)\n\n  )", "erlang": "-spec maximum_odd_binary_number(S :: unicode:unicode_binary()) -> unicode:unicode_binary().\nmaximum_odd_binary_number(S) ->\n  .", "elixir": "defmodule Solution do\n  @spec maximum_odd_binary_number(s :: String.t) :: String.t\n  def maximum_odd_binary_number(s) do\n\n  end\nend"}}
{"id": "leetcode_2937", "url": "https://leetcode.com/problems/make-three-strings-equal/", "title": "Make Three Strings Equal", "description": "You are given three strings `s1`, `s2`, and `s3`. You have to perform the following operation on these three strings **as many times** as you want.\n\n\nIn one operation you can choose one of these three strings such that its length is at least `2` and delete the **rightmost** character of it.\n\n\nReturn *the **minimum** number of operations you need to perform to make the three strings equal if there is a way to make them equal, otherwise, return* `-1`*.*", "examples": ["**Input:** s1 = \"abc\", s2 = \"abb\", s3 = \"ab\"\n**Output:** 2\n**Explanation:** Performing operations on s1 and s2 once will lead to three equal strings.\nIt can be shown that there is no way to make them equal with less than two operations.", "**Input:** s1 = \"dac\", s2 = \"bac\", s3 = \"cac\"\n**Output:** -1\n**Explanation:** Because the leftmost letters of s1 and s2 are not equal, they could not be equal after any number of operations. So the answer is -1."], "constraints": "**Constraints:**\n\n\n* `1 <= s1.length, s2.length, s3.length <= 100`\n* `s1`, `s2` and `s3` consist only of lowercase English letters.", "difficulty": "Easy", "tags": ["String"], "hints": ["Calculate the length of the longest common prefix of the <code>3</code> strings."], "templates": {"cpp": "class Solution {\npublic:\n    int findMinimumOperations(string s1, string s2, string s3) {\n        \n    }\n};", "java": "class Solution {\n    public int findMinimumOperations(String s1, String s2, String s3) {\n        \n    }\n}", "python": "class Solution(object):\n    def findMinimumOperations(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def findMinimumOperations(self, s1: str, s2: str, s3: str) -> int:\n        ", "c": "int findMinimumOperations(char* s1, char* s2, char* s3) {\n    \n}", "csharp": "public class Solution {\n    public int FindMinimumOperations(string s1, string s2, string s3) {\n        \n    }\n}", "javascript": "/**\n * @param {string} s1\n * @param {string} s2\n * @param {string} s3\n * @return {number}\n */\nvar findMinimumOperations = function(s1, s2, s3) {\n    \n};", "typescript": "function findMinimumOperations(s1: string, s2: string, s3: string): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param String $s1\n     * @param String $s2\n     * @param String $s3\n     * @return Integer\n     */\n    function findMinimumOperations($s1, $s2, $s3) {\n        \n    }\n}", "swift": "class Solution {\n    func findMinimumOperations(_ s1: String, _ s2: String, _ s3: String) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun findMinimumOperations(s1: String, s2: String, s3: String): Int {\n        \n    }\n}", "dart": "class Solution {\n  int findMinimumOperations(String s1, String s2, String s3) {\n    \n  }\n}", "golang": "func findMinimumOperations(s1 string, s2 string, s3 string) int {\n    \n}", "ruby": "# @param {String} s1\n# @param {String} s2\n# @param {String} s3\n# @return {Integer}\ndef find_minimum_operations(s1, s2, s3)\n    \nend", "scala": "object Solution {\n    def findMinimumOperations(s1: String, s2: String, s3: String): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn find_minimum_operations(s1: String, s2: String, s3: String) -> i32 {\n        \n    }\n}", "racket": "(define/contract (find-minimum-operations s1 s2 s3)\n  (-> string? string? string? exact-integer?)\n  )", "erlang": "-spec find_minimum_operations(S1 :: unicode:unicode_binary(), S2 :: unicode:unicode_binary(), S3 :: unicode:unicode_binary()) -> integer().\nfind_minimum_operations(S1, S2, S3) ->\n  .", "elixir": "defmodule Solution do\n  @spec find_minimum_operations(s1 :: String.t, s2 :: String.t, s3 :: String.t) :: integer\n  def find_minimum_operations(s1, s2, s3) do\n    \n  end\nend"}}
{"id": "leetcode_2960", "url": "https://leetcode.com/problems/count-tested-devices-after-test-operations/", "title": "Count Tested Devices After Test Operations", "description": "You are given a **0-indexed** integer array `batteryPercentages` having length `n`, denoting the battery percentages of `n` **0-indexed** devices.\n\n\nYour task is to test each device `i` **in order** from `0` to `n - 1`, by performing the following test operations:\n\n\n* If `batteryPercentages[i]` is **greater** than `0`:\n\t+ **Increment** the count of tested devices.\n\t+ **Decrease** the battery percentage of all devices with indices `j` in the range `[i + 1, n - 1]` by `1`, ensuring their battery percentage **never goes below** `0`, i.e, `batteryPercentages[j] = max(0, batteryPercentages[j] - 1)`.\n\t+ Move to the next device.\n* Otherwise, move to the next device without performing any test.\n\n\nReturn *an integer denoting the number of devices that will be tested after performing the test operations in order.*", "examples": ["**Input:** batteryPercentages = [1,1,2,1,3]\n**Output:** 3\n**Explanation:** Performing the test operations in order starting from device 0:\nAt device 0, batteryPercentages[0] > 0, so there is now 1 tested device, and batteryPercentages becomes [1,0,1,0,2].\nAt device 1, batteryPercentages[1] == 0, so we move to the next device without testing.\nAt device 2, batteryPercentages[2] > 0, so there are now 2 tested devices, and batteryPercentages becomes [1,0,1,0,1].\nAt device 3, batteryPercentages[3] == 0, so we move to the next device without testing.\nAt device 4, batteryPercentages[4] > 0, so there are now 3 tested devices, and batteryPercentages stays the same.\nSo, the answer is 3.", "**Input:** batteryPercentages = [0,1,2]\n**Output:** 2\n**Explanation:** Performing the test operations in order starting from device 0:\nAt device 0, batteryPercentages[0] == 0, so we move to the next device without testing.\nAt device 1, batteryPercentages[1] > 0, so there is now 1 tested device, and batteryPercentages becomes [0,1,1].\nAt device 2, batteryPercentages[2] > 0, so there are now 2 tested devices, and batteryPercentages stays the same.\nSo, the answer is 2."], "constraints": "**Constraints:**\n\n\n* `1 <= n == batteryPercentages.length <= 100`\n* `0 <= batteryPercentages[i] <= 100`", "difficulty": "Easy", "tags": ["Array", "Simulation"], "hints": ["One solution is simulating the operations as explained in the problem statement, and it works in <code>O(n<sup>2</sup>)</code> time.", "While going through the devices, you can maintain the number of previously tested devices, and the current device can be tested if <code>batteryPercentages[i]</code> is greater than the number of tested devices."], "templates": {"cpp": "class Solution {\npublic:\n    int countTestedDevices(vector<int>& batteryPercentages) {\n        \n    }\n};", "java": "class Solution {\n    public int countTestedDevices(int[] batteryPercentages) {\n        \n    }\n}", "python": "class Solution(object):\n    def countTestedDevices(self, batteryPercentages):\n        \"\"\"\n        :type batteryPercentages: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def countTestedDevices(self, batteryPercentages: List[int]) -> int:\n        ", "c": "int countTestedDevices(int* batteryPercentages, int batteryPercentagesSize) {\n    \n}", "csharp": "public class Solution {\n    public int CountTestedDevices(int[] batteryPercentages) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} batteryPercentages\n * @return {number}\n */\nvar countTestedDevices = function(batteryPercentages) {\n    \n};", "typescript": "function countTestedDevices(batteryPercentages: number[]): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $batteryPercentages\n     * @return Integer\n     */\n    function countTestedDevices($batteryPercentages) {\n        \n    }\n}", "swift": "class Solution {\n    func countTestedDevices(_ batteryPercentages: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun countTestedDevices(batteryPercentages: IntArray): Int {\n        \n    }\n}", "dart": "class Solution {\n  int countTestedDevices(List<int> batteryPercentages) {\n    \n  }\n}", "golang": "func countTestedDevices(batteryPercentages []int) int {\n    \n}", "ruby": "# @param {Integer[]} battery_percentages\n# @return {Integer}\ndef count_tested_devices(battery_percentages)\n    \nend", "scala": "object Solution {\n    def countTestedDevices(batteryPercentages: Array[Int]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn count_tested_devices(battery_percentages: Vec<i32>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (count-tested-devices batteryPercentages)\n  (-> (listof exact-integer?) exact-integer?)\n  )", "erlang": "-spec count_tested_devices(BatteryPercentages :: [integer()]) -> integer().\ncount_tested_devices(BatteryPercentages) ->\n  .", "elixir": "defmodule Solution do\n  @spec count_tested_devices(battery_percentages :: [integer]) :: integer\n  def count_tested_devices(battery_percentages) do\n    \n  end\nend"}}
{"id": "leetcode_2848", "url": "https://leetcode.com/problems/points-that-intersect-with-cars/", "title": "Points That Intersect With Cars", "description": "You are given a **0-indexed** 2D integer array `nums` representing the coordinates of the cars parking on a number line. For any index `i`, `nums[i] = [starti, endi]` where `starti` is the starting point of the `ith` car and `endi` is the ending point of the `ith` car.\n\n\nReturn *the number of integer points on the line that are covered with **any part** of a car.*", "examples": ["**Input:** nums = [[3,6],[1,5],[4,7]]\n**Output:** 7\n**Explanation:** All the points from 1 to 7 intersect at least one car, therefore the answer would be 7.", "**Input:** nums = [[1,3],[5,8]]\n**Output:** 7\n**Explanation:** Points intersecting at least one car are 1, 2, 3, 5, 6, 7, 8. There are a total of 7 points, therefore the answer would be 7."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 100`\n* `nums[i].length == 2`\n* `1 <= starti\u00a0<= endi\u00a0<= 100`", "difficulty": "Easy", "tags": ["Hash Table", "Math", "Prefix Sum"], "hints": ["Sort the array according to first element and then starting from the <code>0<sup>th</sup></code> index remove the overlapping parts and return the count of non-overlapping points."], "templates": {"cpp": "class Solution {\npublic:\n    int numberOfPoints(vector<vector<int>>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public int numberOfPoints(List<List<Integer>> nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def numberOfPoints(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def numberOfPoints(self, nums: List[List[int]]) -> int:\n        ", "c": "int numberOfPoints(int** nums, int numsSize, int* numsColSize){\n\n}", "csharp": "public class Solution {\n    public int NumberOfPoints(IList<IList<int>> nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[][]} nums\n * @return {number}\n */\nvar numberOfPoints = function(nums) {\n    \n};", "typescript": "function numberOfPoints(nums: number[][]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[][] $nums\n     * @return Integer\n     */\n    function numberOfPoints($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func numberOfPoints(_ nums: [[Int]]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun numberOfPoints(nums: List<List<Int>>): Int {\n        \n    }\n}", "dart": "class Solution {\n  int numberOfPoints(List<List<int>> nums) {\n\n  }\n}", "golang": "func numberOfPoints(nums [][]int) int {\n    \n}", "ruby": "# @param {Integer[][]} nums\n# @return {Integer}\ndef number_of_points(nums)\n    \nend", "scala": "object Solution {\n    def numberOfPoints(nums: List[List[Int]]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn number_of_points(nums: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (number-of-points nums)\n  (-> (listof (listof exact-integer?)) exact-integer?)\n\n  )", "erlang": "-spec number_of_points(Nums :: [[integer()]]) -> integer().\nnumber_of_points(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec number_of_points(nums :: [[integer]]) :: integer\n  def number_of_points(nums) do\n\n  end\nend"}}
{"id": "leetcode_2798", "url": "https://leetcode.com/problems/number-of-employees-who-met-the-target/", "title": "Number of Employees Who Met the Target", "description": "There are `n` employees in a company, numbered from `0` to `n - 1`. Each employee `i` has worked for `hours[i]` hours in the company.\n\n\nThe company requires each employee to work for **at least** `target` hours.\n\n\nYou are given a **0-indexed** array of non-negative integers `hours` of length `n` and a non-negative integer `target`.\n\n\nReturn *the integer denoting the number of employees who worked at least* `target` *hours*.", "examples": ["**Input:** hours = [0,1,2,3,4], target = 2\n**Output:** 3\n**Explanation:** The company wants each employee to work for at least 2 hours.\n- Employee 0 worked for 0 hours and didn't meet the target.\n- Employee 1 worked for 1 hours and didn't meet the target.\n- Employee 2 worked for 2 hours and met the target.\n- Employee 3 worked for 3 hours and met the target.\n- Employee 4 worked for 4 hours and met the target.\nThere are 3 employees who met the target.", "**Input:** hours = [5,1,4,2,2], target = 6\n**Output:** 0\n**Explanation:** The company wants each employee to work for at least 6 hours.\nThere are 0 employees who met the target."], "constraints": "**Constraints:**\n\n\n* `1 <= n == hours.length <= 50`\n* `0 <=\u00a0hours[i], target <= 105`", "difficulty": "Easy", "tags": ["Array", "Enumeration"], "hints": ["Iterate over the elements of array hours and check if the value is greater than or equal to target."], "templates": {"cpp": "class Solution {\npublic:\n    int numberOfEmployeesWhoMetTarget(vector<int>& hours, int target) {\n        \n    }\n};", "java": "class Solution {\n    public int numberOfEmployeesWhoMetTarget(int[] hours, int target) {\n        \n    }\n}", "python": "class Solution(object):\n    def numberOfEmployeesWhoMetTarget(self, hours, target):\n        \"\"\"\n        :type hours: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def numberOfEmployeesWhoMetTarget(self, hours: List[int], target: int) -> int:\n        ", "c": "int numberOfEmployeesWhoMetTarget(int* hours, int hoursSize, int target){\n\n}", "csharp": "public class Solution {\n    public int NumberOfEmployeesWhoMetTarget(int[] hours, int target) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} hours\n * @param {number} target\n * @return {number}\n */\nvar numberOfEmployeesWhoMetTarget = function(hours, target) {\n    \n};", "typescript": "function numberOfEmployeesWhoMetTarget(hours: number[], target: number): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $hours\n     * @param Integer $target\n     * @return Integer\n     */\n    function numberOfEmployeesWhoMetTarget($hours, $target) {\n        \n    }\n}", "swift": "class Solution {\n    func numberOfEmployeesWhoMetTarget(_ hours: [Int], _ target: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun numberOfEmployeesWhoMetTarget(hours: IntArray, target: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int numberOfEmployeesWhoMetTarget(List<int> hours, int target) {\n\n  }\n}", "golang": "func numberOfEmployeesWhoMetTarget(hours []int, target int) int {\n    \n}", "ruby": "# @param {Integer[]} hours\n# @param {Integer} target\n# @return {Integer}\ndef number_of_employees_who_met_target(hours, target)\n    \nend", "scala": "object Solution {\n    def numberOfEmployeesWhoMetTarget(hours: Array[Int], target: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn number_of_employees_who_met_target(hours: Vec<i32>, target: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (number-of-employees-who-met-target hours target)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n\n  )", "erlang": "-spec number_of_employees_who_met_target(Hours :: [integer()], Target :: integer()) -> integer().\nnumber_of_employees_who_met_target(Hours, Target) ->\n  .", "elixir": "defmodule Solution do\n  @spec number_of_employees_who_met_target(hours :: [integer], target :: integer) :: integer\n  def number_of_employees_who_met_target(hours, target) do\n\n  end\nend"}}
{"id": "leetcode_2716", "url": "https://leetcode.com/problems/minimize-string-length/", "title": "Minimize String Length", "description": "Given a **0-indexed** string `s`, repeatedly perform the following operation **any** number of times:\n\n\n* Choose an index `i` in the string, and let `c` be the character in position `i`. **Delete** the **closest occurrence** of `c` to the **left** of `i` (if any) and the **closest occurrence** of `c` to the **right** of `i` (if any).\n\n\nYour task is to **minimize** the length of `s` by performing the above operation any number of times.\n\n\nReturn *an integer denoting the length of the **minimized** string.*", "examples": ["**Input:** s = \"aaabc\"\n**Output:** 3\n**Explanation:** In this example, s is \"aaabc\". We can start by selecting the character 'a' at index 1. We then remove the closest 'a' to the left of index 1, which is at index 0, and the closest 'a' to the right of index 1, which is at index 2. After this operation, the string becomes \"abc\". Any further operation we perform on the string will leave it unchanged. Therefore, the length of the minimized string is 3.", "**Input:** s = \"cbbd\"\n**Output:** 3\n**Explanation:** For this we can start with character 'b' at index 1. There is no occurrence of 'b' to the left of index 1, but there is one to the right at index 2, so we delete the 'b' at index 2. The string becomes \"cbd\" and further operations will leave it unchanged. Hence, the minimized length is 3.", "**Input:** s = \"dddaaa\"\n**Output:** 2\n**Explanation:** For this, we can start with the character 'd' at index 1. The closest occurrence of a 'd' to its left is at index 0, and the closest occurrence of a 'd' to its right is at index 2. We delete both index 0 and 2, so the string becomes \"daaa\". In the new string, we can select the character 'a' at index 2. The closest occurrence of an 'a' to its left is at index 1, and the closest occurrence of an 'a' to its right is at index 3. We delete both of them, and the string becomes \"da\". We cannot minimize this further, so the minimized length is 2."], "constraints": "**Constraints:**\n\n\n* `1 <= s.length <= 100`\n* `s` contains only lowercase English letters", "difficulty": "Easy", "tags": ["Hash Table", "String"], "hints": ["The minimized string will not contain duplicate characters.", "The minimized string will contain all distinct characters of the original string."], "templates": {"cpp": "class Solution {\npublic:\n    int minimizedStringLength(string s) {\n        \n    }\n};", "java": "class Solution {\n    public int minimizedStringLength(String s) {\n        \n    }\n}", "python": "class Solution(object):\n    def minimizedStringLength(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def minimizedStringLength(self, s: str) -> int:\n        ", "c": "int minimizedStringLength(char * s){\n\n}", "csharp": "public class Solution {\n    public int MinimizedStringLength(string s) {\n        \n    }\n}", "javascript": "/**\n * @param {string} s\n * @return {number}\n */\nvar minimizedStringLength = function(s) {\n    \n};", "typescript": "function minimizedStringLength(s: string): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function minimizedStringLength($s) {\n        \n    }\n}", "swift": "class Solution {\n    func minimizedStringLength(_ s: String) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun minimizedStringLength(s: String): Int {\n        \n    }\n}", "dart": "class Solution {\n  int minimizedStringLength(String s) {\n\n  }\n}", "golang": "func minimizedStringLength(s string) int {\n    \n}", "ruby": "# @param {String} s\n# @return {Integer}\ndef minimized_string_length(s)\n    \nend", "scala": "object Solution {\n    def minimizedStringLength(s: String): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn minimized_string_length(s: String) -> i32 {\n        \n    }\n}", "racket": "(define/contract (minimized-string-length s)\n  (-> string? exact-integer?)\n\n  )", "erlang": "-spec minimized_string_length(S :: unicode:unicode_binary()) -> integer().\nminimized_string_length(S) ->\n  .", "elixir": "defmodule Solution do\n  @spec minimized_string_length(s :: String.t) :: integer\n  def minimized_string_length(s) do\n\n  end\nend"}}
{"id": "leetcode_2956", "url": "https://leetcode.com/problems/find-common-elements-between-two-arrays/", "title": "Find Common Elements Between Two Arrays", "description": "You are given two **0-indexed** integer arrays `nums1` and `nums2` of sizes `n` and `m`, respectively.\n\n\nConsider calculating the following values:\n\n\n* The number of indices `i` such that `0 <= i < n` and `nums1[i]` occurs **at least** once in `nums2`.\n* The number of indices `i` such that `0 <= i < m` and `nums2[i]` occurs **at least** once in `nums1`.\n\n\nReturn *an integer array* `answer` *of size* `2` *containing the two values **in the above order***.", "examples": ["**Input:** nums1 = [4,3,2,3,1], nums2 = [2,2,5,2,3,6]\n**Output:** [3,4]\n**Explanation:** We calculate the values as follows:\n- The elements at indices 1, 2, and 3 in nums1 occur at least once in nums2. So the first value is 3.\n- The elements at indices 0, 1, 3, and 4 in nums2 occur at least once in nums1. So the second value is 4.", "**Input:** nums1 = [3,4,2,3], nums2 = [1,5]\n**Output:** [0,0]\n**Explanation:** There are no common elements between the two arrays, so the two values will be 0."], "constraints": "**Constraints:**\n\n\n* `n == nums1.length`\n* `m == nums2.length`\n* `1 <= n, m <= 100`\n* `1 <= nums1[i], nums2[i] <= 100`", "difficulty": "Easy", "tags": ["Array", "Hash Table"], "hints": ["Since the constraints are small, you can use brute force to solve the problem.", "For each element <code>i</code> in <code>nums1</code>, iterate over all elements of <code>nums2</code> to find if it occurs."], "templates": {"cpp": "class Solution {\npublic:\n    vector<int> findIntersectionValues(vector<int>& nums1, vector<int>& nums2) {\n        \n    }\n};", "java": "class Solution {\n    public int[] findIntersectionValues(int[] nums1, int[] nums2) {\n        \n    }\n}", "python": "class Solution(object):\n    def findIntersectionValues(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        ", "python3": "class Solution:\n    def findIntersectionValues(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        ", "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* findIntersectionValues(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize) {\n    \n}", "csharp": "public class Solution {\n    public int[] FindIntersectionValues(int[] nums1, int[] nums2) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number[]}\n */\nvar findIntersectionValues = function(nums1, nums2) {\n    \n};", "typescript": "function findIntersectionValues(nums1: number[], nums2: number[]): number[] {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums1\n     * @param Integer[] $nums2\n     * @return Integer[]\n     */\n    function findIntersectionValues($nums1, $nums2) {\n        \n    }\n}", "swift": "class Solution {\n    func findIntersectionValues(_ nums1: [Int], _ nums2: [Int]) -> [Int] {\n        \n    }\n}", "kotlin": "class Solution {\n    fun findIntersectionValues(nums1: IntArray, nums2: IntArray): IntArray {\n        \n    }\n}", "dart": "class Solution {\n  List<int> findIntersectionValues(List<int> nums1, List<int> nums2) {\n    \n  }\n}", "golang": "func findIntersectionValues(nums1 []int, nums2 []int) []int {\n    \n}", "ruby": "# @param {Integer[]} nums1\n# @param {Integer[]} nums2\n# @return {Integer[]}\ndef find_intersection_values(nums1, nums2)\n    \nend", "scala": "object Solution {\n    def findIntersectionValues(nums1: Array[Int], nums2: Array[Int]): Array[Int] = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn find_intersection_values(nums1: Vec<i32>, nums2: Vec<i32>) -> Vec<i32> {\n        \n    }\n}", "racket": "(define/contract (find-intersection-values nums1 nums2)\n  (-> (listof exact-integer?) (listof exact-integer?) (listof exact-integer?))\n  )", "erlang": "-spec find_intersection_values(Nums1 :: [integer()], Nums2 :: [integer()]) -> [integer()].\nfind_intersection_values(Nums1, Nums2) ->\n  .", "elixir": "defmodule Solution do\n  @spec find_intersection_values(nums1 :: [integer], nums2 :: [integer]) :: [integer]\n  def find_intersection_values(nums1, nums2) do\n    \n  end\nend"}}
{"id": "leetcode_2828", "url": "https://leetcode.com/problems/check-if-a-string-is-an-acronym-of-words/", "title": "Check if a String Is an Acronym of Words", "description": "Given an array of strings `words` and a string `s`, determine if `s` is an **acronym** of words.\n\n\nThe string `s` is considered an acronym of `words` if it can be formed by concatenating the **first** character of each string in `words` **in order**. For example, `\"ab\"` can be formed from `[\"apple\", \"banana\"]`, but it can't be formed from `[\"bear\", \"aardvark\"]`.\n\n\nReturn `true` *if* `s` *is an acronym of* `words`*, and* `false` *otherwise.*", "examples": ["**Input:** words = [\"alice\",\"bob\",\"charlie\"], s = \"abc\"\n**Output:** true\n**Explanation:** The first character in the words \"alice\", \"bob\", and \"charlie\" are 'a', 'b', and 'c', respectively. Hence, s = \"abc\" is the acronym.", "**Input:** words = [\"an\",\"apple\"], s = \"a\"\n**Output:** false\n**Explanation:** The first character in the words \"an\" and \"apple\" are 'a' and 'a', respectively. \nThe acronym formed by concatenating these characters is \"aa\". \nHence, s = \"a\" is not the acronym.", "**Input:** words = [\"never\",\"gonna\",\"give\",\"up\",\"on\",\"you\"], s = \"ngguoy\"\n**Output:** true\n**Explanation:** By concatenating the first character of the words in the array, we get the string \"ngguoy\". \nHence, s = \"ngguoy\" is the acronym."], "constraints": "**Constraints:**\n\n\n* `1 <= words.length <= 100`\n* `1 <= words[i].length <= 10`\n* `1 <= s.length <= 100`\n* `words[i]` and `s` consist of lowercase English letters.", "difficulty": "Easy", "tags": ["Array", "String"], "hints": ["<div class=\"_1l1MA\">Concatenate the first characters of the strings in <code>words</code>, and compare the resulting concatenation to <code>s</code>.</div>"], "templates": {"cpp": "class Solution {\npublic:\n    bool isAcronym(vector<string>& words, string s) {\n        \n    }\n};", "java": "class Solution {\n    public boolean isAcronym(List<String> words, String s) {\n        \n    }\n}", "python": "class Solution(object):\n    def isAcronym(self, words, s):\n        \"\"\"\n        :type words: List[str]\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        ", "python3": "class Solution:\n    def isAcronym(self, words: List[str], s: str) -> bool:\n        ", "c": "bool isAcronym(char ** words, int wordsSize, char * s){\n\n}", "csharp": "public class Solution {\n    public bool IsAcronym(IList<string> words, string s) {\n        \n    }\n}", "javascript": "/**\n * @param {string[]} words\n * @param {string} s\n * @return {boolean}\n */\nvar isAcronym = function(words, s) {\n    \n};", "typescript": "function isAcronym(words: string[], s: string): boolean {\n\n};", "php": "class Solution {\n\n    /**\n     * @param String[] $words\n     * @param String $s\n     * @return Boolean\n     */\n    function isAcronym($words, $s) {\n        \n    }\n}", "swift": "class Solution {\n    func isAcronym(_ words: [String], _ s: String) -> Bool {\n        \n    }\n}", "kotlin": "class Solution {\n    fun isAcronym(words: List<String>, s: String): Boolean {\n        \n    }\n}", "dart": "class Solution {\n  bool isAcronym(List<String> words, String s) {\n\n  }\n}", "golang": "func isAcronym(words []string, s string) bool {\n    \n}", "ruby": "# @param {String[]} words\n# @param {String} s\n# @return {Boolean}\ndef is_acronym(words, s)\n    \nend", "scala": "object Solution {\n    def isAcronym(words: List[String], s: String): Boolean = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn is_acronym(words: Vec<String>, s: String) -> bool {\n        \n    }\n}", "racket": "(define/contract (is-acronym words s)\n  (-> (listof string?) string? boolean?)\n\n  )", "erlang": "-spec is_acronym(Words :: [unicode:unicode_binary()], S :: unicode:unicode_binary()) -> boolean().\nis_acronym(Words, S) ->\n  .", "elixir": "defmodule Solution do\n  @spec is_acronym(words :: [String.t], s :: String.t) :: boolean\n  def is_acronym(words, s) do\n\n  end\nend"}}
{"id": "leetcode_2717", "url": "https://leetcode.com/problems/semi-ordered-permutation/", "title": "Semi-Ordered Permutation", "description": "You are given a **0-indexed** permutation of `n` integers `nums`.\n\n\nA permutation is called **semi-ordered** if the first number equals `1` and the last number equals `n`. You can perform the below operation as many times as you want until you make `nums` a **semi-ordered** permutation:\n\n\n* Pick two adjacent elements in `nums`, then swap them.\n\n\nReturn *the minimum number of operations to make* `nums` *a **semi-ordered permutation***.\n\n\nA **permutation** is a sequence of integers from `1` to `n` of length `n` containing each number exactly once.", "examples": ["**Input:** nums = [2,1,4,3]\n**Output:** 2\n**Explanation:** We can make the permutation semi-ordered using these sequence of operations: \n1 - swap i = 0 and j = 1. The permutation becomes [1,2,4,3].\n2 - swap i = 2 and j = 3. The permutation becomes [1,2,3,4].\nIt can be proved that there is no sequence of less than two operations that make nums a semi-ordered permutation.", "**Input:** nums = [2,4,1,3]\n**Output:** 3\n**Explanation:** We can make the permutation semi-ordered using these sequence of operations:\n1 - swap i = 1 and j = 2. The permutation becomes [2,1,4,3].\n2 - swap i = 0 and j = 1. The permutation becomes [1,2,4,3].\n3 - swap i = 2 and j = 3. The permutation becomes [1,2,3,4].\nIt can be proved that there is no sequence of less than three operations that make nums a semi-ordered permutation.", "**Input:** nums = [1,3,4,2,5]\n**Output:** 0\n**Explanation:** The permutation is already a semi-ordered permutation."], "constraints": "**Constraints:**\n\n\n* `2 <= nums.length == n <= 50`\n* `1 <= nums[i]\u00a0<= 50`\n* `nums is a permutation.`", "difficulty": "Easy", "tags": ["Array", "Simulation"], "hints": ["Find the index of elements 1 and n.", "Let x be the position of 1 and y be the position of n. the answer is x + (n-y-1) if x < y and x + (n-y-1) - 1 if x > y."], "templates": {"cpp": "class Solution {\npublic:\n    int semiOrderedPermutation(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public int semiOrderedPermutation(int[] nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def semiOrderedPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\n        ", "c": "int semiOrderedPermutation(int* nums, int numsSize){\n\n}", "csharp": "public class Solution {\n    public int SemiOrderedPermutation(int[] nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar semiOrderedPermutation = function(nums) {\n    \n};", "typescript": "function semiOrderedPermutation(nums: number[]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function semiOrderedPermutation($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func semiOrderedPermutation(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun semiOrderedPermutation(nums: IntArray): Int {\n        \n    }\n}", "dart": "class Solution {\n  int semiOrderedPermutation(List<int> nums) {\n\n  }\n}", "golang": "func semiOrderedPermutation(nums []int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef semi_ordered_permutation(nums)\n    \nend", "scala": "object Solution {\n    def semiOrderedPermutation(nums: Array[Int]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn semi_ordered_permutation(nums: Vec<i32>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (semi-ordered-permutation nums)\n  (-> (listof exact-integer?) exact-integer?)\n\n  )", "erlang": "-spec semi_ordered_permutation(Nums :: [integer()]) -> integer().\nsemi_ordered_permutation(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec semi_ordered_permutation(nums :: [integer]) :: integer\n  def semi_ordered_permutation(nums) do\n\n  end\nend"}}
{"id": "leetcode_2869", "url": "https://leetcode.com/problems/minimum-operations-to-collect-elements/", "title": "Minimum Operations to Collect Elements", "description": "You are given an array `nums` of positive integers and an integer `k`.\n\n\nIn one operation, you can remove the last element of the array and add it to your collection.\n\n\nReturn *the **minimum number of operations** needed to collect elements* `1, 2, ..., k`.", "examples": ["**Input:** nums = [3,1,5,4,2], k = 2\n**Output:** 4\n**Explanation:** After 4 operations, we collect elements 2, 4, 5, and 1, in this order. Our collection contains elements 1 and 2. Hence, the answer is 4.", "**Input:** nums = [3,1,5,4,2], k = 5\n**Output:** 5\n**Explanation:** After 5 operations, we collect elements 2, 4, 5, 1, and 3, in this order. Our collection contains elements 1 through 5. Hence, the answer is 5.", "**Input:** nums = [3,2,5,3,1], k = 3\n**Output:** 4\n**Explanation:** After 4 operations, we collect elements 1, 3, 5, and 2, in this order. Our collection contains elements 1 through 3. Hence, the answer is 4."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 50`\n* `1 <= nums[i] <= nums.length`\n* `1 <= k <= nums.length`\n* The input is generated such that you can collect elements `1, 2, ..., k`.", "difficulty": "Easy", "tags": ["Array", "Hash Table"], "hints": ["Use an occurrence array.", "Iterate over the elements in reverse order.", "If the current element <code>nums[i]</code> is not marked in the occurrence array and <code>nums[i] &lt;= k</code>, mark <code>nums[i]</code>.", "Keep track of how many integers you have marked.", "Return the current index as soon as the number of marked integers becomes equal to <code>k</code>."], "templates": {"cpp": "class Solution {\npublic:\n    int minOperations(vector<int>& nums, int k) {\n        \n    }\n};", "java": "class Solution {\n    public int minOperations(List<Integer> nums, int k) {\n        \n    }\n}", "python": "class Solution(object):\n    def minOperations(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:\n        ", "c": "int minOperations(int* nums, int numsSize, int k){\n\n}", "csharp": "public class Solution {\n    public int MinOperations(IList<int> nums, int k) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minOperations = function(nums, k) {\n    \n};", "typescript": "function minOperations(nums: number[], k: number): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer\n     */\n    function minOperations($nums, $k) {\n        \n    }\n}", "swift": "class Solution {\n    func minOperations(_ nums: [Int], _ k: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun minOperations(nums: List<Int>, k: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int minOperations(List<int> nums, int k) {\n\n  }\n}", "golang": "func minOperations(nums []int, k int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer}\ndef min_operations(nums, k)\n    \nend", "scala": "object Solution {\n    def minOperations(nums: List[Int], k: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn min_operations(nums: Vec<i32>, k: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (min-operations nums k)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n\n  )", "erlang": "-spec min_operations(Nums :: [integer()], K :: integer()) -> integer().\nmin_operations(Nums, K) ->\n  .", "elixir": "defmodule Solution do\n  @spec min_operations(nums :: [integer], k :: integer) :: integer\n  def min_operations(nums, k) do\n\n  end\nend"}}
{"id": "leetcode_2760", "url": "https://leetcode.com/problems/longest-even-odd-subarray-with-threshold/", "title": "Longest Even Odd Subarray With Threshold", "description": "You are given a **0-indexed** integer array `nums` and an integer `threshold`.\n\n\nFind the length of the **longest subarray** of `nums` starting at index `l` and ending at index `r` `(0 <= l <= r < nums.length)` that satisfies the following conditions:\n\n\n* `nums[l] % 2 == 0`\n* For all indices `i` in the range `[l, r - 1]`, `nums[i] % 2 != nums[i + 1] % 2`\n* For all indices `i` in the range `[l, r]`, `nums[i] <= threshold`\n\n\nReturn *an integer denoting the length of the longest such subarray.*\n\n\n**Note:** A **subarray** is a contiguous non-empty sequence of elements within an array.", "examples": ["**Input:** nums = [3,2,5,4], threshold = 5\n**Output:** 3\n**Explanation:** In this example, we can select the subarray that starts at l = 1 and ends at r = 3 => [2,5,4]. This subarray satisfies the conditions.\nHence, the answer is the length of the subarray, 3. We can show that 3 is the maximum possible achievable length.", "**Input:** nums = [1,2], threshold = 2\n**Output:** 1\n**Explanation:** In this example, we can select the subarray that starts at l = 1 and ends at r = 1 => [2]. \nIt satisfies all the conditions and we can show that 1 is the maximum possible achievable length.", "**Input:** nums = [2,3,4,5], threshold = 4\n**Output:** 3\n**Explanation:** In this example, we can select the subarray that starts at l = 0 and ends at r = 2 => [2,3,4]. \nIt satisfies all the conditions.\nHence, the answer is the length of the subarray, 3. We can show that 3 is the maximum possible achievable length."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 100`\n* `1 <= nums[i] <= 100`\n* `1 <= threshold <= 100`", "difficulty": "Easy", "tags": ["Array", "Sliding Window"], "hints": ["Brute force all the possible subarrays and find the longest that satisfies the conditions."], "templates": {"cpp": "class Solution {\npublic:\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\n        \n    }\n};", "java": "class Solution {\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\n        \n    }\n}", "python": "class Solution(object):\n    def longestAlternatingSubarray(self, nums, threshold):\n        \"\"\"\n        :type nums: List[int]\n        :type threshold: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\n        ", "c": "int longestAlternatingSubarray(int* nums, int numsSize, int threshold){\n\n}", "csharp": "public class Solution {\n    public int LongestAlternatingSubarray(int[] nums, int threshold) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @param {number} threshold\n * @return {number}\n */\nvar longestAlternatingSubarray = function(nums, threshold) {\n    \n};", "typescript": "function longestAlternatingSubarray(nums: number[], threshold: number): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $threshold\n     * @return Integer\n     */\n    function longestAlternatingSubarray($nums, $threshold) {\n        \n    }\n}", "swift": "class Solution {\n    func longestAlternatingSubarray(_ nums: [Int], _ threshold: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun longestAlternatingSubarray(nums: IntArray, threshold: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int longestAlternatingSubarray(List<int> nums, int threshold) {\n\n  }\n}", "golang": "func longestAlternatingSubarray(nums []int, threshold int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @param {Integer} threshold\n# @return {Integer}\ndef longest_alternating_subarray(nums, threshold)\n    \nend", "scala": "object Solution {\n    def longestAlternatingSubarray(nums: Array[Int], threshold: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn longest_alternating_subarray(nums: Vec<i32>, threshold: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (longest-alternating-subarray nums threshold)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n\n  )", "erlang": "-spec longest_alternating_subarray(Nums :: [integer()], Threshold :: integer()) -> integer().\nlongest_alternating_subarray(Nums, Threshold) ->\n  .", "elixir": "defmodule Solution do\n  @spec longest_alternating_subarray(nums :: [integer], threshold :: integer) :: integer\n  def longest_alternating_subarray(nums, threshold) do\n\n  end\nend"}}
{"id": "leetcode_2824", "url": "https://leetcode.com/problems/count-pairs-whose-sum-is-less-than-target/", "title": "Count Pairs Whose Sum is Less than Target", "description": "Given a **0-indexed** integer array `nums` of length `n` and an integer `target`, return *the number of pairs* `(i, j)` *where* `0 <= i < j < n` *and* `nums[i] + nums[j] < target`.", "examples": ["**Input:** nums = [-1,1,2,3,1], target = 2\n**Output:** 3\n**Explanation:** There are 3 pairs of indices that satisfy the conditions in the statement:\n- (0, 1) since 0 < 1 and nums[0] + nums[1] = 0 < target\n- (0, 2) since 0 < 2 and nums[0] + nums[2] = 1 < target \n- (0, 4) since 0 < 4 and nums[0] + nums[4] = 0 < target\nNote that (0, 3) is not counted since nums[0] + nums[3] is not strictly less than the target.", "**Input:** nums = [-6,2,5,-2,-7,-1,3], target = -2\n**Output:** 10\n**Explanation:** There are 10 pairs of indices that satisfy the conditions in the statement:\n- (0, 1) since 0 < 1 and nums[0] + nums[1] = -4 < target\n- (0, 3) since 0 < 3 and nums[0] + nums[3] = -8 < target\n- (0, 4) since 0 < 4 and nums[0] + nums[4] = -13 < target\n- (0, 5) since 0 < 5 and nums[0] + nums[5] = -7 < target\n- (0, 6) since 0 < 6 and nums[0] + nums[6] = -3 < target\n- (1, 4) since 1 < 4 and nums[1] + nums[4] = -5 < target\n- (3, 4) since 3 < 4 and nums[3] + nums[4] = -9 < target\n- (3, 5) since 3 < 5 and nums[3] + nums[5] = -3 < target\n- (4, 5) since 4 < 5 and nums[4] + nums[5] = -8 < target\n- (4, 6) since 4 < 6 and nums[4] + nums[6] = -4 < target"], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length == n <= 50`\n* `-50 <= nums[i], target <= 50`", "difficulty": "Easy", "tags": ["Array", "Two Pointers", "Sorting"], "hints": ["The constraints are small enough for a brute-force solution to pass"], "templates": {"cpp": "class Solution {\npublic:\n    int countPairs(vector<int>& nums, int target) {\n        \n    }\n};", "java": "class Solution {\n    public int countPairs(List<Integer> nums, int target) {\n        \n    }\n}", "python": "class Solution(object):\n    def countPairs(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def countPairs(self, nums: List[int], target: int) -> int:\n        ", "c": "int countPairs(int* nums, int numsSize, int target){\n\n}", "csharp": "public class Solution {\n    public int CountPairs(IList<int> nums, int target) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar countPairs = function(nums, target) {\n    \n};", "typescript": "function countPairs(nums: number[], target: number): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $target\n     * @return Integer\n     */\n    function countPairs($nums, $target) {\n        \n    }\n}", "swift": "class Solution {\n    func countPairs(_ nums: [Int], _ target: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun countPairs(nums: List<Int>, target: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int countPairs(List<int> nums, int target) {\n\n  }\n}", "golang": "func countPairs(nums []int, target int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @param {Integer} target\n# @return {Integer}\ndef count_pairs(nums, target)\n    \nend", "scala": "object Solution {\n    def countPairs(nums: List[Int], target: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn count_pairs(nums: Vec<i32>, target: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (count-pairs nums target)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n\n  )", "erlang": "-spec count_pairs(Nums :: [integer()], Target :: integer()) -> integer().\ncount_pairs(Nums, Target) ->\n  .", "elixir": "defmodule Solution do\n  @spec count_pairs(nums :: [integer], target :: integer) :: integer\n  def count_pairs(nums, target) do\n\n  end\nend"}}
{"id": "leetcode_2873", "url": "https://leetcode.com/problems/maximum-value-of-an-ordered-triplet-i/", "title": "Maximum Value of an Ordered Triplet I", "description": "You are given a **0-indexed** integer array `nums`.\n\n\nReturn ***the maximum value over all triplets of indices*** `(i, j, k)` *such that* `i < j < k`. If all such triplets have a negative value, return `0`.\n\n\nThe **value of a triplet of indices** `(i, j, k)` is equal to `(nums[i] - nums[j]) * nums[k]`.", "examples": ["**Input:** nums = [12,6,1,2,7]\n**Output:** 77\n**Explanation:** The value of the triplet (0, 2, 4) is (nums[0] - nums[2]) * nums[4] = 77.\nIt can be shown that there are no ordered triplets of indices with a value greater than 77.", "**Input:** nums = [1,10,3,4,19]\n**Output:** 133\n**Explanation:** The value of the triplet (1, 2, 4) is (nums[1] - nums[2]) * nums[4] = 133.\nIt can be shown that there are no ordered triplets of indices with a value greater than 133.", "**Input:** nums = [1,2,3]\n**Output:** 0\n**Explanation:** The only ordered triplet of indices (0, 1, 2) has a negative value of (nums[0] - nums[1]) * nums[2] = -3. Hence, the answer would be 0."], "constraints": "**Constraints:**\n\n\n* `3 <= nums.length <= 100`\n* `1 <= nums[i] <= 106`", "difficulty": "Easy", "tags": ["Array"], "hints": ["Use three nested loops to find all the triplets."], "templates": {"cpp": "class Solution {\npublic:\n    long long maximumTripletValue(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public long maximumTripletValue(int[] nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def maximumTripletValue(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def maximumTripletValue(self, nums: List[int]) -> int:\n        ", "c": "long long maximumTripletValue(int* nums, int numsSize) {\n    \n}", "csharp": "public class Solution {\n    public long MaximumTripletValue(int[] nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maximumTripletValue = function(nums) {\n    \n};", "typescript": "function maximumTripletValue(nums: number[]): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function maximumTripletValue($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func maximumTripletValue(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun maximumTripletValue(nums: IntArray): Long {\n        \n    }\n}", "dart": "class Solution {\n  int maximumTripletValue(List<int> nums) {\n    \n  }\n}", "golang": "func maximumTripletValue(nums []int) int64 {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef maximum_triplet_value(nums)\n    \nend", "scala": "object Solution {\n    def maximumTripletValue(nums: Array[Int]): Long = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn maximum_triplet_value(nums: Vec<i32>) -> i64 {\n        \n    }\n}", "racket": "(define/contract (maximum-triplet-value nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )", "erlang": "-spec maximum_triplet_value(Nums :: [integer()]) -> integer().\nmaximum_triplet_value(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec maximum_triplet_value(nums :: [integer]) :: integer\n  def maximum_triplet_value(nums) do\n    \n  end\nend"}}
{"id": "leetcode_2706", "url": "https://leetcode.com/problems/buy-two-chocolates/", "title": "Buy Two Chocolates", "description": "You are given an integer array `prices` representing the prices of various chocolates in a store. You are also given a single integer `money`, which represents your initial amount of money.\n\n\nYou must buy **exactly** two chocolates in such a way that you still have some **non-negative** leftover money. You would like to minimize the sum of the prices of the two chocolates you buy.\n\n\nReturn *the amount of money you will have leftover after buying the two chocolates*. If there is no way for you to buy two chocolates without ending up in debt, return `money`. Note that the leftover must be non-negative.", "examples": ["**Input:** prices = [1,2,2], money = 3\n**Output:** 0\n**Explanation:** Purchase the chocolates priced at 1 and 2 units respectively. You will have 3 - 3 = 0 units of money afterwards. Thus, we return 0.", "**Input:** prices = [3,2,3], money = 3\n**Output:** 3\n**Explanation:** You cannot buy 2 chocolates without going in debt, so we return 3."], "constraints": "**Constraints:**\n\n\n* `2 <= prices.length <= 50`\n* `1 <= prices[i] <= 100`\n* `1 <= money <= 100`", "difficulty": "Easy", "tags": ["Array", "Sorting"], "hints": ["Sort the array and check if the money is more than or equal to the sum of the two cheapest elements."], "templates": {"cpp": "class Solution {\npublic:\n    int buyChoco(vector<int>& prices, int money) {\n        \n    }\n};", "java": "class Solution {\n    public int buyChoco(int[] prices, int money) {\n        \n    }\n}", "python": "class Solution(object):\n    def buyChoco(self, prices, money):\n        \"\"\"\n        :type prices: List[int]\n        :type money: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def buyChoco(self, prices: List[int], money: int) -> int:\n        ", "c": "int buyChoco(int* prices, int pricesSize, int money){\n\n}", "csharp": "public class Solution {\n    public int BuyChoco(int[] prices, int money) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} prices\n * @param {number} money\n * @return {number}\n */\nvar buyChoco = function(prices, money) {\n    \n};", "typescript": "function buyChoco(prices: number[], money: number): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $prices\n     * @param Integer $money\n     * @return Integer\n     */\n    function buyChoco($prices, $money) {\n        \n    }\n}", "swift": "class Solution {\n    func buyChoco(_ prices: [Int], _ money: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun buyChoco(prices: IntArray, money: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int buyChoco(List<int> prices, int money) {\n\n  }\n}", "golang": "func buyChoco(prices []int, money int) int {\n    \n}", "ruby": "# @param {Integer[]} prices\n# @param {Integer} money\n# @return {Integer}\ndef buy_choco(prices, money)\n    \nend", "scala": "object Solution {\n    def buyChoco(prices: Array[Int], money: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn buy_choco(prices: Vec<i32>, money: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (buy-choco prices money)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n\n  )", "erlang": "-spec buy_choco(Prices :: [integer()], Money :: integer()) -> integer().\nbuy_choco(Prices, Money) ->\n  .", "elixir": "defmodule Solution do\n  @spec buy_choco(prices :: [integer], money :: integer) :: integer\n  def buy_choco(prices, money) do\n\n  end\nend"}}
{"id": "leetcode_2839", "url": "https://leetcode.com/problems/check-if-strings-can-be-made-equal-with-operations-i/", "title": "Check if Strings Can be Made Equal With Operations I", "description": "You are given two strings `s1` and `s2`, both of length `4`, consisting of **lowercase** English letters.\n\n\nYou can apply the following operation on any of the two strings **any** number of times:\n\n\n* Choose any two indices `i` and `j` such that `j - i = 2`, then **swap** the two characters at those indices in the string.\n\n\nReturn `true` *if you can make the strings* `s1` *and* `s2` *equal, and* `false` *otherwise*.", "examples": ["**Input:** s1 = \"abcd\", s2 = \"cdab\"\n**Output:** true\n**Explanation:** We can do the following operations on s1:\n- Choose the indices i = 0, j = 2. The resulting string is s1 = \"cbad\".\n- Choose the indices i = 1, j = 3. The resulting string is s1 = \"cdab\" = s2.", "**Input:** s1 = \"abcd\", s2 = \"dacb\"\n**Output:** false\n**Explanation:** It is not possible to make the two strings equal."], "constraints": "**Constraints:**\n\n\n* `s1.length == s2.length == 4`\n* `s1` and `s2` consist only of lowercase English letters.", "difficulty": "Easy", "tags": ["String"], "hints": ["<div class=\"_1l1MA\">Since the strings are very small you can try a brute-force approach.</div>", "<div class=\"_1l1MA\">There are only <code>2</code> different swaps that are possible in a string.</div>"], "templates": {"cpp": "class Solution {\npublic:\n    bool canBeEqual(string s1, string s2) {\n        \n    }\n};", "java": "class Solution {\n    public boolean canBeEqual(String s1, String s2) {\n        \n    }\n}", "python": "class Solution(object):\n    def canBeEqual(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        ", "python3": "class Solution:\n    def canBeEqual(self, s1: str, s2: str) -> bool:\n        ", "c": "bool canBeEqual(char* s1, char* s2){\n\n}", "csharp": "public class Solution {\n    public bool CanBeEqual(string s1, string s2) {\n        \n    }\n}", "javascript": "/**\n * @param {string} s1\n * @param {string} s2\n * @return {boolean}\n */\nvar canBeEqual = function(s1, s2) {\n    \n};", "typescript": "function canBeEqual(s1: string, s2: string): boolean {\n\n};", "php": "class Solution {\n\n    /**\n     * @param String $s1\n     * @param String $s2\n     * @return Boolean\n     */\n    function canBeEqual($s1, $s2) {\n        \n    }\n}", "swift": "class Solution {\n    func canBeEqual(_ s1: String, _ s2: String) -> Bool {\n        \n    }\n}", "kotlin": "class Solution {\n    fun canBeEqual(s1: String, s2: String): Boolean {\n        \n    }\n}", "dart": "class Solution {\n  bool canBeEqual(String s1, String s2) {\n\n  }\n}", "golang": "func canBeEqual(s1 string, s2 string) bool {\n    \n}", "ruby": "# @param {String} s1\n# @param {String} s2\n# @return {Boolean}\ndef can_be_equal(s1, s2)\n    \nend", "scala": "object Solution {\n    def canBeEqual(s1: String, s2: String): Boolean = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn can_be_equal(s1: String, s2: String) -> bool {\n        \n    }\n}", "racket": "(define/contract (can-be-equal s1 s2)\n  (-> string? string? boolean?)\n\n  )", "erlang": "-spec can_be_equal(S1 :: unicode:unicode_binary(), S2 :: unicode:unicode_binary()) -> boolean().\ncan_be_equal(S1, S2) ->\n  .", "elixir": "defmodule Solution do\n  @spec can_be_equal(s1 :: String.t, s2 :: String.t) :: boolean\n  def can_be_equal(s1, s2) do\n\n  end\nend"}}
{"id": "leetcode_2710", "url": "https://leetcode.com/problems/remove-trailing-zeros-from-a-string/", "title": "Remove Trailing Zeros From a String", "description": "Given a **positive** integer `num` represented as a string, return *the integer* `num` *without trailing zeros as a string*.", "examples": ["**Input:** num = \"51230100\"\n**Output:** \"512301\"\n**Explanation:** Integer \"51230100\" has 2 trailing zeros, we remove them and return integer \"512301\".", "**Input:** num = \"123\"\n**Output:** \"123\"\n**Explanation:** Integer \"123\" has no trailing zeros, we return integer \"123\"."], "constraints": "**Constraints:**\n\n\n* `1 <= num.length <= 1000`\n* `num` consists\u00a0of only digits.\n* `num` doesn't\u00a0have any leading zeros.", "difficulty": "Easy", "tags": ["String"], "hints": ["Find the last non-zero digit in num."], "templates": {"cpp": "class Solution {\npublic:\n    string removeTrailingZeros(string num) {\n        \n    }\n};", "java": "class Solution {\n    public String removeTrailingZeros(String num) {\n        \n    }\n}", "python": "class Solution(object):\n    def removeTrailingZeros(self, num):\n        \"\"\"\n        :type num: str\n        :rtype: str\n        \"\"\"\n        ", "python3": "class Solution:\n    def removeTrailingZeros(self, num: str) -> str:\n        ", "c": "char * removeTrailingZeros(char * num){\n\n}", "csharp": "public class Solution {\n    public string RemoveTrailingZeros(string num) {\n        \n    }\n}", "javascript": "/**\n * @param {string} num\n * @return {string}\n */\nvar removeTrailingZeros = function(num) {\n    \n};", "typescript": "function removeTrailingZeros(num: string): string {\n\n};", "php": "class Solution {\n\n    /**\n     * @param String $num\n     * @return String\n     */\n    function removeTrailingZeros($num) {\n        \n    }\n}", "swift": "class Solution {\n    func removeTrailingZeros(_ num: String) -> String {\n        \n    }\n}", "kotlin": "class Solution {\n    fun removeTrailingZeros(num: String): String {\n        \n    }\n}", "dart": "class Solution {\n  String removeTrailingZeros(String num) {\n\n  }\n}", "golang": "func removeTrailingZeros(num string) string {\n    \n}", "ruby": "# @param {String} num\n# @return {String}\ndef remove_trailing_zeros(num)\n    \nend", "scala": "object Solution {\n    def removeTrailingZeros(num: String): String = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn remove_trailing_zeros(num: String) -> String {\n        \n    }\n}", "racket": "(define/contract (remove-trailing-zeros num)\n  (-> string? string?)\n\n  )", "erlang": "-spec remove_trailing_zeros(Num :: unicode:unicode_binary()) -> unicode:unicode_binary().\nremove_trailing_zeros(Num) ->\n  .", "elixir": "defmodule Solution do\n  @spec remove_trailing_zeros(num :: String.t) :: String.t\n  def remove_trailing_zeros(num) do\n\n  end\nend"}}
{"id": "leetcode_2784", "url": "https://leetcode.com/problems/check-if-array-is-good/", "title": "Check if Array is Good", "description": "You are given an integer array `nums`. We consider an array **good** if it is a permutation of an array `base[n]`.\n\n\n`base[n] = [1, 2, ..., n - 1, n, n]` (in other words, it is an array of length `n + 1` which contains `1` to `n - 1` exactly once, plus two occurrences of `n`). For example, `base[1] = [1, 1]` and `base[3] = [1, 2, 3, 3]`.\n\n\nReturn `true` *if the given array is good, otherwise return*`false`.\n\n\n**Note:** A permutation of integers represents an arrangement of these numbers.", "examples": ["**Input:** nums = [2, 1, 3]\n**Output:** false\n**Explanation:** Since the maximum element of the array is 3, the only candidate n for which this array could be a permutation of base[n], is n = 3. However, base[3] has four elements but array nums has three. Therefore, it can not be a permutation of base[3] = [1, 2, 3, 3]. So the answer is false.", "**Input:** nums = [1, 3, 3, 2]\n**Output:** true\n**Explanation:** Since the maximum element of the array is 3, the only candidate n for which this array could be a permutation of base[n], is n = 3. It can be seen that nums is a permutation of base[3] = [1, 2, 3, 3] (by swapping the second and fourth elements in nums, we reach base[3]). Therefore, the answer is true.", "**Input:** nums = [1, 1]\n**Output:** true\n**Explanation:** Since the maximum element of the array is 1, the only candidate n for which this array could be a permutation of base[n], is n = 1. It can be seen that nums is a permutation of base[1] = [1, 1]. Therefore, the answer is true.", "**Input:** nums = [3, 4, 4, 1, 2, 1]\n**Output:** false\n**Explanation:** Since the maximum element of the array is 4, the only candidate n for which this array could be a permutation of base[n], is n = 4. However, base[4] has five elements but array nums has six. Therefore, it can not be a permutation of base[4] = [1, 2, 3, 4, 4]. So the answer is false."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 100`\n* `1 <= num[i] <= 200`", "difficulty": "Easy", "tags": ["Array", "Hash Table", "Sorting"], "hints": ["Find the maximum element of the array."], "templates": {"cpp": "class Solution {\npublic:\n    bool isGood(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public boolean isGood(int[] nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def isGood(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        ", "python3": "class Solution:\n    def isGood(self, nums: List[int]) -> bool:\n        ", "c": "bool isGood(int* nums, int numsSize){\n\n}", "csharp": "public class Solution {\n    public bool IsGood(int[] nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar isGood = function(nums) {\n    \n};", "typescript": "function isGood(nums: number[]): boolean {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Boolean\n     */\n    function isGood($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func isGood(_ nums: [Int]) -> Bool {\n        \n    }\n}", "kotlin": "class Solution {\n    fun isGood(nums: IntArray): Boolean {\n        \n    }\n}", "dart": "class Solution {\n  bool isGood(List<int> nums) {\n\n  }\n}", "golang": "func isGood(nums []int) bool {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Boolean}\ndef is_good(nums)\n    \nend", "scala": "object Solution {\n    def isGood(nums: Array[Int]): Boolean = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn is_good(nums: Vec<i32>) -> bool {\n        \n    }\n}", "racket": "(define/contract (is-good nums)\n  (-> (listof exact-integer?) boolean?)\n\n  )", "erlang": "-spec is_good(Nums :: [integer()]) -> boolean().\nis_good(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec is_good(nums :: [integer]) :: boolean\n  def is_good(nums) do\n\n  end\nend"}}
{"id": "leetcode_2696", "url": "https://leetcode.com/problems/minimum-string-length-after-removing-substrings/", "title": "Minimum String Length After Removing Substrings", "description": "You are given a string `s` consisting only of **uppercase** English letters.\n\n\nYou can apply some operations to this string where, in one operation, you can remove **any** occurrence of one of the substrings `\"AB\"` or `\"CD\"` from `s`.\n\n\nReturn *the **minimum** possible length of the resulting string that you can obtain*.\n\n\n**Note** that the string concatenates after removing the substring and could produce new `\"AB\"` or `\"CD\"` substrings.", "examples": ["**Input:** s = \"ABFCACDB\"\n**Output:** 2\n**Explanation:** We can do the following operations:\n- Remove the substring \"ABFCACDB\", so s = \"FCACDB\".\n- Remove the substring \"FCACDB\", so s = \"FCAB\".\n- Remove the substring \"FCAB\", so s = \"FC\".\nSo the resulting length of the string is 2.\nIt can be shown that it is the minimum length that we can obtain.", "**Input:** s = \"ACBBD\"\n**Output:** 5\n**Explanation:** We cannot do any operations on the string so the length remains the same."], "constraints": "**Constraints:**\n\n\n* `1 <= s.length <= 100`\n* `s`\u00a0consists only of uppercase English letters.", "difficulty": "Easy", "tags": ["String", "Stack", "Simulation"], "hints": ["Can we use brute force to solve the problem?", "Repeatedly traverse the string to find and remove the substrings \u201cAB\u201d and \u201cCD\u201d until no more occurrences exist."], "templates": {"cpp": "class Solution {\npublic:\n    int minLength(string s) {\n        \n    }\n};", "java": "class Solution {\n    public int minLength(String s) {\n        \n    }\n}", "python": "class Solution(object):\n    def minLength(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def minLength(self, s: str) -> int:\n        ", "c": "int minLength(char * s){\n\n}", "csharp": "public class Solution {\n    public int MinLength(string s) {\n        \n    }\n}", "javascript": "/**\n * @param {string} s\n * @return {number}\n */\nvar minLength = function(s) {\n    \n};", "typescript": "function minLength(s: string): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function minLength($s) {\n        \n    }\n}", "swift": "class Solution {\n    func minLength(_ s: String) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun minLength(s: String): Int {\n        \n    }\n}", "dart": "class Solution {\n  int minLength(String s) {\n\n  }\n}", "golang": "func minLength(s string) int {\n    \n}", "ruby": "# @param {String} s\n# @return {Integer}\ndef min_length(s)\n    \nend", "scala": "object Solution {\n    def minLength(s: String): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn min_length(s: String) -> i32 {\n        \n    }\n}", "racket": "(define/contract (min-length s)\n  (-> string? exact-integer?)\n\n  )", "erlang": "-spec min_length(S :: unicode:unicode_binary()) -> integer().\nmin_length(S) ->\n  .", "elixir": "defmodule Solution do\n  @spec min_length(s :: String.t) :: integer\n  def min_length(s) do\n\n  end\nend"}}
{"id": "leetcode_2815", "url": "https://leetcode.com/problems/max-pair-sum-in-an-array/", "title": "Max Pair Sum in an Array", "description": "You are given a **0-indexed** integer array `nums`. You have to find the **maximum** sum of a pair of numbers from `nums` such that the maximum **digit** in both numbers are equal.\n\n\nReturn *the maximum sum or* `-1` *if no such pair exists*.", "examples": ["**Input:** nums = [51,71,17,24,42]\n**Output:** 88\n**Explanation:** \nFor i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. \nFor i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.\nIt can be shown that there are no other pairs with equal maximum digits, so the answer is 88.", "**Input:** nums = [1,2,3,4]\n**Output:** -1\n**Explanation:** No pair exists in nums with equal maximum digits."], "constraints": "**Constraints:**\n\n\n* `2 <= nums.length <= 100`\n* `1 <= nums[i] <= 104`", "difficulty": "Easy", "tags": ["Array", "Hash Table"], "hints": ["Find the largest and second largest element with maximum digits equal to x where 1<=x<=9."], "templates": {"cpp": "class Solution {\npublic:\n    int maxSum(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public int maxSum(int[] nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def maxSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        ", "c": "int maxSum(int* nums, int numsSize){\n\n}", "csharp": "public class Solution {\n    public int MaxSum(int[] nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxSum = function(nums) {\n    \n};", "typescript": "function maxSum(nums: number[]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function maxSum($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func maxSum(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun maxSum(nums: IntArray): Int {\n        \n    }\n}", "dart": "class Solution {\n  int maxSum(List<int> nums) {\n\n  }\n}", "golang": "func maxSum(nums []int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef max_sum(nums)\n    \nend", "scala": "object Solution {\n    def maxSum(nums: Array[Int]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn max_sum(nums: Vec<i32>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (max-sum nums)\n  (-> (listof exact-integer?) exact-integer?)\n\n  )", "erlang": "-spec max_sum(Nums :: [integer()]) -> integer().\nmax_sum(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec max_sum(nums :: [integer]) :: integer\n  def max_sum(nums) do\n\n  end\nend"}}
{"id": "leetcode_2788", "url": "https://leetcode.com/problems/split-strings-by-separator/", "title": "Split Strings by Separator", "description": "Given an array of strings `words` and a character `separator`, **split** each string in `words` by `separator`.\n\n\nReturn *an array of strings containing the new strings formed after the splits, **excluding empty strings**.*\n\n\n**Notes**\n\n\n* `separator` is used to determine where the split should occur, but it is not included as part of the resulting strings.\n* A split may result in more than two strings.\n* The resulting strings must maintain the same order as they were initially given.", "examples": ["**Input:** words = [\"one.two.three\",\"four.five\",\"six\"], separator = \".\"\n**Output:** [\"one\",\"two\",\"three\",\"four\",\"five\",\"six\"]\n**Explanation:** In this example we split as follows:\n\n\"one.two.three\" splits into \"one\", \"two\", \"three\"\n\"four.five\" splits into \"four\", \"five\"\n\"six\" splits into \"six\" \n\nHence, the resulting array is [\"one\",\"two\",\"three\",\"four\",\"five\",\"six\"].", "**Input:** words = [\"$easy$\",\"$problem$\"], separator = \"$\"\n**Output:** [\"easy\",\"problem\"]\n**Explanation:** In this example we split as follows: \n\n\"$easy$\" splits into \"easy\" (excluding empty strings)\n\"$problem$\" splits into \"problem\" (excluding empty strings)\n\nHence, the resulting array is [\"easy\",\"problem\"].", "**Input:** words = [\"|||\"], separator = \"|\"\n**Output:** []\n**Explanation:** In this example the resulting split of \"|||\" will contain only empty strings, so we return an empty array []."], "constraints": "**Constraints:**\n\n\n* `1 <= words.length <= 100`\n* `1 <= words[i].length <= 20`\n* characters in `words[i]` are either lowercase English letters or characters from the string `\".,|$#@\"` (excluding the quotes)\n* `separator` is a character from the string `\".,|$#@\"` (excluding the quotes)", "difficulty": "Easy", "tags": ["Array", "String"], "hints": ["Iterate over each string in the given array using a loop and perform string splitting based on the provided separator character.", "Be sure not to return empty strings."], "templates": {"cpp": "class Solution {\npublic:\n    vector<string> splitWordsBySeparator(vector<string>& words, char separator) {\n        \n    }\n};", "java": "class Solution {\n    public List<String> splitWordsBySeparator(List<String> words, char separator) {\n        \n    }\n}", "python": "class Solution(object):\n    def splitWordsBySeparator(self, words, separator):\n        \"\"\"\n        :type words: List[str]\n        :type separator: str\n        :rtype: List[str]\n        \"\"\"\n        ", "python3": "class Solution:\n    def splitWordsBySeparator(self, words: List[str], separator: str) -> List[str]:\n        ", "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar ** splitWordsBySeparator(char ** words, int wordsSize, char separator, int* returnSize){\n\n}", "csharp": "public class Solution {\n    public IList<string> SplitWordsBySeparator(IList<string> words, char separator) {\n        \n    }\n}", "javascript": "/**\n * @param {string[]} words\n * @param {character} separator\n * @return {string[]}\n */\nvar splitWordsBySeparator = function(words, separator) {\n    \n};", "typescript": "function splitWordsBySeparator(words: string[], separator: string): string[] {\n\n};", "php": "class Solution {\n\n    /**\n     * @param String[] $words\n     * @param String $separator\n     * @return String[]\n     */\n    function splitWordsBySeparator($words, $separator) {\n        \n    }\n}", "swift": "class Solution {\n    func splitWordsBySeparator(_ words: [String], _ separator: Character) -> [String] {\n        \n    }\n}", "kotlin": "class Solution {\n    fun splitWordsBySeparator(words: List<String>, separator: Char): List<String> {\n        \n    }\n}", "dart": "class Solution {\n  List<String> splitWordsBySeparator(List<String> words, String separator) {\n\n  }\n}", "golang": "func splitWordsBySeparator(words []string, separator byte) []string {\n    \n}", "ruby": "# @param {String[]} words\n# @param {Character} separator\n# @return {String[]}\ndef split_words_by_separator(words, separator)\n    \nend", "scala": "object Solution {\n    def splitWordsBySeparator(words: List[String], separator: Char): List[String] = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn split_words_by_separator(words: Vec<String>, separator: char) -> Vec<String> {\n        \n    }\n}", "racket": "(define/contract (split-words-by-separator words separator)\n  (-> (listof string?) char? (listof string?))\n\n  )", "erlang": "-spec split_words_by_separator(Words :: [unicode:unicode_binary()], Separator :: char()) -> [unicode:unicode_binary()].\nsplit_words_by_separator(Words, Separator) ->\n  .", "elixir": "defmodule Solution do\n  @spec split_words_by_separator(words :: [String.t], separator :: char) :: [String.t]\n  def split_words_by_separator(words, separator) do\n\n  end\nend"}}
{"id": "leetcode_2859", "url": "https://leetcode.com/problems/sum-of-values-at-indices-with-k-set-bits/", "title": "Sum of Values at Indices With K Set Bits", "description": "You are given a **0-indexed** integer array `nums` and an integer `k`.\n\n\nReturn *an integer that denotes the **sum** of elements in* `nums` *whose corresponding **indices** have **exactly*** `k` *set bits in their binary representation.*\n\n\nThe **set bits** in an integer are the `1`'s present when it is written in binary.\n\n\n* For example, the binary representation of `21` is `10101`, which has `3` set bits.", "examples": ["**Input:** nums = [5,10,1,5,2], k = 1\n**Output:** 13\n**Explanation:** The binary representation of the indices are: \n0 = 0002\n1 = 0012\n2 = 0102\n3 = 0112\n4 = 1002Indices 1, 2, and 4 have k = 1 set bits in their binary representation.\nHence, the answer is nums[1] + nums[2] + nums[4] = 13.", "**Input:** nums = [4,3,2,1], k = 2\n**Output:** 1\n**Explanation:** The binary representation of the indices are:\n0 = 002\n1 = 012\n2 = 102\n3 = 112Only index 3 has k = 2 set bits in its binary representation.\nHence, the answer is nums[3] = 1."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 1000`\n* `1 <= nums[i] <= 105`\n* `0 <= k <= 10`", "difficulty": "Easy", "tags": ["Array", "Bit Manipulation"], "hints": ["Iterate through the indices <code>i</code> in the range <code>[0, n - 1]</code>, for each index <code>i</code> count the number of bits in its binary representation. If it is <code>k</code>, add <code>nums[i]</code> to the result."], "templates": {"cpp": "class Solution {\npublic:\n    int sumIndicesWithKSetBits(vector<int>& nums, int k) {\n        \n    }\n};", "java": "class Solution {\n    public int sumIndicesWithKSetBits(List<Integer> nums, int k) {\n        \n    }\n}", "python": "class Solution(object):\n    def sumIndicesWithKSetBits(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def sumIndicesWithKSetBits(self, nums: List[int], k: int) -> int:\n        ", "c": "int sumIndicesWithKSetBits(int* nums, int numsSize, int k){\n\n}", "csharp": "public class Solution {\n    public int SumIndicesWithKSetBits(IList<int> nums, int k) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar sumIndicesWithKSetBits = function(nums, k) {\n    \n};", "typescript": "function sumIndicesWithKSetBits(nums: number[], k: number): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer\n     */\n    function sumIndicesWithKSetBits($nums, $k) {\n        \n    }\n}", "swift": "class Solution {\n    func sumIndicesWithKSetBits(_ nums: [Int], _ k: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun sumIndicesWithKSetBits(nums: List<Int>, k: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int sumIndicesWithKSetBits(List<int> nums, int k) {\n\n  }\n}", "golang": "func sumIndicesWithKSetBits(nums []int, k int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer}\ndef sum_indices_with_k_set_bits(nums, k)\n    \nend", "scala": "object Solution {\n    def sumIndicesWithKSetBits(nums: List[Int], k: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn sum_indices_with_k_set_bits(nums: Vec<i32>, k: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (sum-indices-with-k-set-bits nums k)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n\n  )", "erlang": "-spec sum_indices_with_k_set_bits(Nums :: [integer()], K :: integer()) -> integer().\nsum_indices_with_k_set_bits(Nums, K) ->\n  .", "elixir": "defmodule Solution do\n  @spec sum_indices_with_k_set_bits(nums :: [integer], k :: integer) :: integer\n  def sum_indices_with_k_set_bits(nums, k) do\n\n  end\nend"}}
{"id": "leetcode_2843", "url": "https://leetcode.com/problems/count-symmetric-integers/", "title": "  Count Symmetric Integers", "description": "You are given two positive integers `low` and `high`.\n\n\nAn integer `x` consisting of `2 * n` digits is **symmetric** if the sum of the first `n` digits of `x` is equal to the sum of the last `n` digits of `x`. Numbers with an odd number of digits are never symmetric.\n\n\nReturn *the **number of symmetric** integers in the range* `[low, high]`.", "examples": ["**Input:** low = 1, high = 100\n**Output:** 9\n**Explanation:** There are 9 symmetric integers between 1 and 100: 11, 22, 33, 44, 55, 66, 77, 88, and 99.", "**Input:** low = 1200, high = 1230\n**Output:** 4\n**Explanation:** There are 4 symmetric integers between 1200 and 1230: 1203, 1212, 1221, and 1230."], "constraints": "**Constraints:**\n\n\n* `1 <= low <= high <= 104`", "difficulty": "Easy", "tags": ["Math", "Enumeration"], "hints": ["<div class=\"_1l1MA\">Iterate over all numbers from <code>low</code> to <code>high</code></div>", "<div class=\"_1l1MA\">Convert each number to a string and compare the sum of the first half with that of the second.</div>"], "templates": {"cpp": "class Solution {\npublic:\n    int countSymmetricIntegers(int low, int high) {\n        \n    }\n};", "java": "class Solution {\n    public int countSymmetricIntegers(int low, int high) {\n        \n    }\n}", "python": "class Solution(object):\n    def countSymmetricIntegers(self, low, high):\n        \"\"\"\n        :type low: int\n        :type high: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def countSymmetricIntegers(self, low: int, high: int) -> int:\n        ", "c": "int countSymmetricIntegers(int low, int high){\n\n}", "csharp": "public class Solution {\n    public int CountSymmetricIntegers(int low, int high) {\n        \n    }\n}", "javascript": "/**\n * @param {number} low\n * @param {number} high\n * @return {number}\n */\nvar countSymmetricIntegers = function(low, high) {\n    \n};", "typescript": "function countSymmetricIntegers(low: number, high: number): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer $low\n     * @param Integer $high\n     * @return Integer\n     */\n    function countSymmetricIntegers($low, $high) {\n        \n    }\n}", "swift": "class Solution {\n    func countSymmetricIntegers(_ low: Int, _ high: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun countSymmetricIntegers(low: Int, high: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int countSymmetricIntegers(int low, int high) {\n\n  }\n}", "golang": "func countSymmetricIntegers(low int, high int) int {\n    \n}", "ruby": "# @param {Integer} low\n# @param {Integer} high\n# @return {Integer}\ndef count_symmetric_integers(low, high)\n    \nend", "scala": "object Solution {\n    def countSymmetricIntegers(low: Int, high: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn count_symmetric_integers(low: i32, high: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (count-symmetric-integers low high)\n  (-> exact-integer? exact-integer? exact-integer?)\n\n  )", "erlang": "-spec count_symmetric_integers(Low :: integer(), High :: integer()) -> integer().\ncount_symmetric_integers(Low, High) ->\n  .", "elixir": "defmodule Solution do\n  @spec count_symmetric_integers(low :: integer, high :: integer) :: integer\n  def count_symmetric_integers(low, high) do\n\n  end\nend"}}
{"id": "leetcode_2951", "url": "https://leetcode.com/problems/find-the-peaks/", "title": "Find the Peaks", "description": "You are given a **0-indexed** array `mountain`. Your task is to find all the **peaks** in the `mountain` array.\n\n\nReturn *an array that consists of* indices *of **peaks** in the given array in **any order**.*\n\n\n**Notes:**\n\n\n* A **peak** is defined as an element that is **strictly greater** than its neighboring elements.\n* The first and last elements of the array are **not** a peak.", "examples": ["**Input:** mountain = [2,4,4]\n**Output:** []\n**Explanation:** mountain[0] and mountain[2] can not be a peak because they are first and last elements of the array.\nmountain[1] also can not be a peak because it is not strictly greater than mountain[2].\nSo the answer is [].", "**Input:** mountain = [1,4,3,8,5]\n**Output:** [1,3]\n**Explanation:** mountain[0] and mountain[4] can not be a peak because they are first and last elements of the array.\nmountain[2] also can not be a peak because it is not strictly greater than mountain[3] and mountain[1].\nBut mountain [1] and mountain[3] are strictly greater than their neighboring elements.\nSo the answer is [1,3]."], "constraints": "**Constraints:**\n\n\n* `3 <= mountain.length <= 100`\n* `1 <= mountain[i] <= 100`", "difficulty": "Easy", "tags": ["Array", "Enumeration"], "hints": ["If <code>nums[i] > num[i - 1]</code> and <code>nums[i] > nums[i + 1]</code> <code>nums[i]</code> is a peak."], "templates": {"cpp": "class Solution {\npublic:\n    vector<int> findPeaks(vector<int>& mountain) {\n        \n    }\n};", "java": "class Solution {\n    public List<Integer> findPeaks(int[] mountain) {\n        \n    }\n}", "python": "class Solution(object):\n    def findPeaks(self, mountain):\n        \"\"\"\n        :type mountain: List[int]\n        :rtype: List[int]\n        \"\"\"\n        ", "python3": "class Solution:\n    def findPeaks(self, mountain: List[int]) -> List[int]:\n        ", "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* findPeaks(int* mountain, int mountainSize, int* returnSize) {\n    \n}", "csharp": "public class Solution {\n    public IList<int> FindPeaks(int[] mountain) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} mountain\n * @return {number[]}\n */\nvar findPeaks = function(mountain) {\n    \n};", "typescript": "function findPeaks(mountain: number[]): number[] {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $mountain\n     * @return Integer[]\n     */\n    function findPeaks($mountain) {\n        \n    }\n}", "swift": "class Solution {\n    func findPeaks(_ mountain: [Int]) -> [Int] {\n        \n    }\n}", "kotlin": "class Solution {\n    fun findPeaks(mountain: IntArray): List<Int> {\n        \n    }\n}", "dart": "class Solution {\n  List<int> findPeaks(List<int> mountain) {\n    \n  }\n}", "golang": "func findPeaks(mountain []int) []int {\n    \n}", "ruby": "# @param {Integer[]} mountain\n# @return {Integer[]}\ndef find_peaks(mountain)\n    \nend", "scala": "object Solution {\n    def findPeaks(mountain: Array[Int]): List[Int] = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn find_peaks(mountain: Vec<i32>) -> Vec<i32> {\n        \n    }\n}", "racket": "(define/contract (find-peaks mountain)\n  (-> (listof exact-integer?) (listof exact-integer?))\n  )", "erlang": "-spec find_peaks(Mountain :: [integer()]) -> [integer()].\nfind_peaks(Mountain) ->\n  .", "elixir": "defmodule Solution do\n  @spec find_peaks(mountain :: [integer]) :: [integer]\n  def find_peaks(mountain) do\n    \n  end\nend"}}
{"id": "leetcode_2678", "url": "https://leetcode.com/problems/number-of-senior-citizens/", "title": "Number of Senior Citizens", "description": "You are given a **0-indexed** array of strings `details`. Each element of `details` provides information about a given passenger compressed into a string of length `15`. The system is such that:\n\n\n* The first ten characters consist of the phone number of passengers.\n* The next character denotes the gender of the person.\n* The following two characters are used to indicate the age of the person.\n* The last two characters determine the seat allotted to that person.\n\n\nReturn *the number of passengers who are **strictly** **more than 60 years old**.*", "examples": ["**Input:** details = [\"7868190130M7522\",\"5303914400F9211\",\"9273338290F4010\"]\n**Output:** 2\n**Explanation:** The passengers at indices 0, 1, and 2 have ages 75, 92, and 40. Thus, there are 2 people who are over 60 years old.", "**Input:** details = [\"1313579440F2036\",\"2921522980M5644\"]\n**Output:** 0\n**Explanation:** None of the passengers are older than 60."], "constraints": "**Constraints:**\n\n\n* `1 <= details.length <= 100`\n* `details[i].length == 15`\n* `details[i] consists of digits from '0' to '9'.`\n* `details[i][10] is either 'M' or 'F' or 'O'.`\n* The phone numbers and seat numbers of the passengers are distinct.", "difficulty": "Easy", "tags": ["Array", "String"], "hints": ["Convert the value at index 11 and 12 to a numerical value.", "The age of the person at index i is equal to details[i][11]*10+details[i][12]."], "templates": {"cpp": "class Solution {\npublic:\n    int countSeniors(vector<string>& details) {\n        \n    }\n};", "java": "class Solution {\n    public int countSeniors(String[] details) {\n        \n    }\n}", "python": "class Solution(object):\n    def countSeniors(self, details):\n        \"\"\"\n        :type details: List[str]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def countSeniors(self, details: List[str]) -> int:\n        ", "c": "int countSeniors(char ** details, int detailsSize){\n\n}", "csharp": "public class Solution {\n    public int CountSeniors(string[] details) {\n        \n    }\n}", "javascript": "/**\n * @param {string[]} details\n * @return {number}\n */\nvar countSeniors = function(details) {\n    \n};", "typescript": "function countSeniors(details: string[]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param String[] $details\n     * @return Integer\n     */\n    function countSeniors($details) {\n        \n    }\n}", "swift": "class Solution {\n    func countSeniors(_ details: [String]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun countSeniors(details: Array<String>): Int {\n        \n    }\n}", "dart": "class Solution {\n  int countSeniors(List<String> details) {\n\n  }\n}", "golang": "func countSeniors(details []string) int {\n    \n}", "ruby": "# @param {String[]} details\n# @return {Integer}\ndef count_seniors(details)\n    \nend", "scala": "object Solution {\n    def countSeniors(details: Array[String]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn count_seniors(details: Vec<String>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (count-seniors details)\n  (-> (listof string?) exact-integer?)\n\n  )", "erlang": "-spec count_seniors(Details :: [unicode:unicode_binary()]) -> integer().\ncount_seniors(Details) ->\n  .", "elixir": "defmodule Solution do\n  @spec count_seniors(details :: [String.t]) :: integer\n  def count_seniors(details) do\n\n  end\nend"}}
{"id": "leetcode_2697", "url": "https://leetcode.com/problems/lexicographically-smallest-palindrome/", "title": "Lexicographically Smallest Palindrome", "description": "You are given a string `s` consisting of **lowercase English letters**, and you are allowed to perform operations on it. In one operation, you can **replace** a character in `s` with another lowercase English letter.\n\n\nYour task is to make `s` a **palindrome** with the **minimum** **number** **of operations** possible. If there are **multiple palindromes** that can be made using the **minimum** number of operations, make the **lexicographically smallest** one.\n\n\nA string `a` is lexicographically smaller than a string `b` (of the same length) if in the first position where `a` and `b` differ, string `a` has a letter that appears earlier in the alphabet than the corresponding letter in `b`.\n\n\nReturn *the resulting palindrome string.*", "examples": ["**Input:** s = \"egcfe\"\n**Output:** \"efcfe\"\n**Explanation:** The minimum number of operations to make \"egcfe\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"efcfe\", by changing 'g'.", "**Input:** s = \"abcd\"\n**Output:** \"abba\"\n**Explanation:** The minimum number of operations to make \"abcd\" a palindrome is 2, and the lexicographically smallest palindrome string we can get by modifying two characters is \"abba\".", "**Input:** s = \"seven\"\n**Output:** \"neven\"\n**Explanation:** The minimum number of operations to make \"seven\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"neven\"."], "constraints": "**Constraints:**\n\n\n* `1 <= s.length <= 1000`\n* `s`\u00a0consists of only lowercase English letters**.**", "difficulty": "Easy", "tags": ["Two Pointers", "String", "Greedy"], "hints": ["We can make any string a palindrome, by simply making any character at index i equal to the character at index length - i - 1 (using 0-based indexing).", "To make it lexicographically smallest we can change the character with maximum ASCII value to the one with minimum ASCII value."], "templates": {"cpp": "class Solution {\npublic:\n    string makeSmallestPalindrome(string s) {\n        \n    }\n};", "java": "class Solution {\n    public String makeSmallestPalindrome(String s) {\n        \n    }\n}", "python": "class Solution(object):\n    def makeSmallestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        ", "python3": "class Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        ", "c": "char * makeSmallestPalindrome(char * s){\n\n}", "csharp": "public class Solution {\n    public string MakeSmallestPalindrome(string s) {\n        \n    }\n}", "javascript": "/**\n * @param {string} s\n * @return {string}\n */\nvar makeSmallestPalindrome = function(s) {\n    \n};", "typescript": "function makeSmallestPalindrome(s: string): string {\n\n};", "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @return String\n     */\n    function makeSmallestPalindrome($s) {\n        \n    }\n}", "swift": "class Solution {\n    func makeSmallestPalindrome(_ s: String) -> String {\n        \n    }\n}", "kotlin": "class Solution {\n    fun makeSmallestPalindrome(s: String): String {\n        \n    }\n}", "dart": "class Solution {\n  String makeSmallestPalindrome(String s) {\n\n  }\n}", "golang": "func makeSmallestPalindrome(s string) string {\n    \n}", "ruby": "# @param {String} s\n# @return {String}\ndef make_smallest_palindrome(s)\n    \nend", "scala": "object Solution {\n    def makeSmallestPalindrome(s: String): String = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn make_smallest_palindrome(s: String) -> String {\n        \n    }\n}", "racket": "(define/contract (make-smallest-palindrome s)\n  (-> string? string?)\n\n  )", "erlang": "-spec make_smallest_palindrome(S :: unicode:unicode_binary()) -> unicode:unicode_binary().\nmake_smallest_palindrome(S) ->\n  .", "elixir": "defmodule Solution do\n  @spec make_smallest_palindrome(s :: String.t) :: String.t\n  def make_smallest_palindrome(s) do\n\n  end\nend"}}
{"id": "leetcode_2855", "url": "https://leetcode.com/problems/minimum-right-shifts-to-sort-the-array/", "title": "Minimum Right Shifts to Sort the Array", "description": "You are given a **0-indexed** array `nums` of length `n` containing **distinct** positive integers. Return *the **minimum** number of **right shifts** required to sort* `nums` *and* `-1` *if this is not possible.*\n\n\nA **right shift** is defined as shifting the element at index `i` to index `(i + 1) % n`, for all indices.", "examples": ["**Input:** nums = [3,4,5,1,2]\n**Output:** 2\n**Explanation:** \nAfter the first right shift, nums = [2,3,4,5,1].\nAfter the second right shift, nums = [1,2,3,4,5].\nNow nums is sorted; therefore the answer is 2.", "**Input:** nums = [1,3,5]\n**Output:** 0\n**Explanation:** nums is already sorted therefore, the answer is 0.", "**Input:** nums = [2,1,4]\n**Output:** -1\n**Explanation:** It's impossible to sort the array using right shifts."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 100`\n* `1 <= nums[i] <= 100`\n* `nums` contains distinct integers.", "difficulty": "Easy", "tags": ["Array"], "hints": ["Find the pivot point around which the array is rotated.", "Will the answer exist if there is more than one point where <code>nums[i] < nums[i-1]</code>?"], "templates": {"cpp": "class Solution {\npublic:\n    int minimumRightShifts(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public int minimumRightShifts(List<Integer> nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def minimumRightShifts(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def minimumRightShifts(self, nums: List[int]) -> int:\n        ", "c": "int minimumRightShifts(int* nums, int numsSize){\n\n}", "csharp": "public class Solution {\n    public int MinimumRightShifts(IList<int> nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minimumRightShifts = function(nums) {\n    \n};", "typescript": "function minimumRightShifts(nums: number[]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function minimumRightShifts($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func minimumRightShifts(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun minimumRightShifts(nums: List<Int>): Int {\n        \n    }\n}", "dart": "class Solution {\n  int minimumRightShifts(List<int> nums) {\n\n  }\n}", "golang": "func minimumRightShifts(nums []int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef minimum_right_shifts(nums)\n    \nend", "scala": "object Solution {\n    def minimumRightShifts(nums: List[Int]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn minimum_right_shifts(nums: Vec<i32>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (minimum-right-shifts nums)\n  (-> (listof exact-integer?) exact-integer?)\n\n  )", "erlang": "-spec minimum_right_shifts(Nums :: [integer()]) -> integer().\nminimum_right_shifts(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec minimum_right_shifts(nums :: [integer]) :: integer\n  def minimum_right_shifts(nums) do\n\n  end\nend"}}
{"id": "leetcode_2682", "url": "https://leetcode.com/problems/find-the-losers-of-the-circular-game/", "title": "Find the Losers of the Circular Game", "description": "There are `n` friends that are playing a game. The friends are sitting in a circle and are numbered from `1` to `n` in **clockwise order**. More formally, moving clockwise from the `ith` friend brings you to the `(i+1)th` friend for `1 <= i < n`, and moving clockwise from the `nth` friend brings you to the `1st` friend.\n\n\nThe rules of the game are as follows:\n\n\n`1st` friend receives the ball.\n\n\n* After that, `1st` friend passes it to the friend who is `k` steps away from them in the **clockwise** direction.\n* After that, the friend who receives the ball should pass it to the friend who is `2 * k` steps away from them in the **clockwise** direction.\n* After that, the friend who receives the ball should pass it to the friend who is `3 * k` steps away from them in the **clockwise** direction, and so on and so forth.\n\n\nIn other words, on the `ith` turn, the friend holding the ball should pass it to the friend who is `i * k` steps away from them in the **clockwise** direction.\n\n\nThe game is finished when some friend receives the ball for the second time.\n\n\nThe **losers** of the game are friends who did not receive the ball in the entire game.\n\n\nGiven the number of friends, `n`, and an integer `k`, return *the array answer, which contains the losers of the game in the **ascending** order*.", "examples": ["**Input:** n = 5, k = 2\n**Output:** [4,5]\n**Explanation:** The game goes as follows:\n1) Start at 1st\u00a0friend and pass the ball to the friend who is 2 steps away from them - 3rd\u00a0friend.\n2) 3rd\u00a0friend passes the ball to the friend who is 4 steps away from them - 2nd\u00a0friend.\n3) 2nd\u00a0friend passes the ball to the friend who is 6 steps away from them  - 3rd\u00a0friend.\n4) The game ends as 3rd\u00a0friend receives the ball for the second time.", "**Input:** n = 4, k = 4\n**Output:** [2,3,4]\n**Explanation:** The game goes as follows:\n1) Start at the 1st\u00a0friend and pass the ball to the friend who is 4 steps away from them - 1st\u00a0friend.\n2) The game ends as 1st\u00a0friend receives the ball for the second time."], "constraints": "**Constraints:**\n\n\n* `1 <= k <= n <= 50`", "difficulty": "Easy", "tags": ["Array", "Hash Table", "Simulation"], "hints": ["Simulate the whole game until a player receives the ball for the second time."], "templates": {"cpp": "class Solution {\npublic:\n    vector<int> circularGameLosers(int n, int k) {\n        \n    }\n};", "java": "class Solution {\n    public int[] circularGameLosers(int n, int k) {\n        \n    }\n}", "python": "class Solution(object):\n    def circularGameLosers(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        ", "python3": "class Solution:\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\n        ", "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* circularGameLosers(int n, int k, int* returnSize){\n\n}", "csharp": "public class Solution {\n    public int[] CircularGameLosers(int n, int k) {\n        \n    }\n}", "javascript": "/**\n * @param {number} n\n * @param {number} k\n * @return {number[]}\n */\nvar circularGameLosers = function(n, k) {\n    \n};", "typescript": "function circularGameLosers(n: number, k: number): number[] {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer $k\n     * @return Integer[]\n     */\n    function circularGameLosers($n, $k) {\n        \n    }\n}", "swift": "class Solution {\n    func circularGameLosers(_ n: Int, _ k: Int) -> [Int] {\n        \n    }\n}", "kotlin": "class Solution {\n    fun circularGameLosers(n: Int, k: Int): IntArray {\n        \n    }\n}", "dart": "class Solution {\n  List<int> circularGameLosers(int n, int k) {\n\n  }\n}", "golang": "func circularGameLosers(n int, k int) []int {\n    \n}", "ruby": "# @param {Integer} n\n# @param {Integer} k\n# @return {Integer[]}\ndef circular_game_losers(n, k)\n    \nend", "scala": "object Solution {\n    def circularGameLosers(n: Int, k: Int): Array[Int] = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn circular_game_losers(n: i32, k: i32) -> Vec<i32> {\n        \n    }\n}", "racket": "(define/contract (circular-game-losers n k)\n  (-> exact-integer? exact-integer? (listof exact-integer?))\n\n  )", "erlang": "-spec circular_game_losers(N :: integer(), K :: integer()) -> [integer()].\ncircular_game_losers(N, K) ->\n  .", "elixir": "defmodule Solution do\n  @spec circular_game_losers(n :: integer, k :: integer) :: [integer]\n  def circular_game_losers(n, k) do\n\n  end\nend"}}
{"id": "leetcode_2913", "url": "https://leetcode.com/problems/subarrays-distinct-element-sum-of-squares-i/", "title": "Subarrays Distinct Element Sum of Squares I", "description": "You are given a **0-indexed** integer array `nums`.\n\n\nThe **distinct count** of a subarray of `nums` is defined as:\n\n\n* Let `nums[i..j]` be a subarray of `nums` consisting of all the indices from `i` to `j` such that `0 <= i <= j < nums.length`. Then the number of distinct values in `nums[i..j]` is called the distinct count of `nums[i..j]`.\n\n\nReturn *the sum of the **squares** of **distinct counts** of all subarrays of* `nums`.\n\n\nA subarray is a contiguous **non-empty** sequence of elements within an array.", "examples": ["**Input:** nums = [1,2,1]\n**Output:** 15\n**Explanation:** Six possible subarrays are:\n[1]: 1 distinct value\n[2]: 1 distinct value\n[1]: 1 distinct value\n[1,2]: 2 distinct values\n[2,1]: 2 distinct values\n[1,2,1]: 2 distinct values\nThe sum of the squares of the distinct counts in all subarrays is equal to 12 + 12 + 12 + 22 + 22 + 22 = 15.", "**Input:** nums = [1,1]\n**Output:** 3\n**Explanation:** Three possible subarrays are:\n[1]: 1 distinct value\n[1]: 1 distinct value\n[1,1]: 1 distinct value\nThe sum of the squares of the distinct counts in all subarrays is equal to 12 + 12 + 12 = 3."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 100`\n* `1 <= nums[i] <= 100`", "difficulty": "Easy", "tags": ["Array", "Hash Table"], "hints": ["Use a set/heap to keep track of distinct element counts."], "templates": {"cpp": "class Solution {\npublic:\n    int sumCounts(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public int sumCounts(List<Integer> nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def sumCounts(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n        ", "c": "int sumCounts(int* nums, int numsSize){\n\n}", "csharp": "public class Solution {\n    public int SumCounts(IList<int> nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar sumCounts = function(nums) {\n    \n};", "typescript": "function sumCounts(nums: number[]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function sumCounts($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func sumCounts(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun sumCounts(nums: List<Int>): Int {\n        \n    }\n}", "dart": "class Solution {\n  int sumCounts(List<int> nums) {\n\n  }\n}", "golang": "func sumCounts(nums []int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef sum_counts(nums)\n    \nend", "scala": "object Solution {\n    def sumCounts(nums: List[Int]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn sum_counts(nums: Vec<i32>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (sum-counts nums)\n  (-> (listof exact-integer?) exact-integer?)\n\n  )", "erlang": "-spec sum_counts(Nums :: [integer()]) -> integer().\nsum_counts(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec sum_counts(nums :: [integer]) :: integer\n  def sum_counts(nums) do\n\n  end\nend"}}
{"id": "leetcode_2765", "url": "https://leetcode.com/problems/longest-alternating-subarray/", "title": "Longest Alternating Subarray", "description": "You are given a **0-indexed** integer array `nums`. A subarray `s` of length `m` is called **alternating** if:\n\n\n* `m` is greater than `1`.\n* `s1 = s0 + 1`.\n* The **0-indexed** subarray `s` looks like `[s0, s1, s0, s1,...,s(m-1) % 2]`. In other words, `s1 - s0 = 1`, `s2 - s1 = -1`, `s3 - s2 = 1`, `s4 - s3 = -1`, and so on up to `s[m - 1] - s[m - 2] = (-1)m`.\n\n\nReturn *the maximum length of all **alternating** subarrays present in* `nums` *or* `-1` *if no such subarray exists**.*\n\n\nA subarray is a contiguous **non-empty** sequence of elements within an array.", "examples": ["**Input:** nums = [2,3,4,3,4]\n**Output:** 4\n**Explanation:** The alternating subarrays are [3,4], [3,4,3], and [3,4,3,4]. The longest of these is [3,4,3,4], which is of length 4.", "**Input:** nums = [4,5,6]\n**Output:** 2\n**Explanation:** [4,5] and [5,6] are the only two alternating subarrays. They are both of length 2."], "constraints": "**Constraints:**\n\n\n* `2 <= nums.length <= 100`\n* `1 <= nums[i] <= 104`", "difficulty": "Easy", "tags": ["Array", "Enumeration"], "hints": ["As the constraints are low, you can check each subarray for the given condition."], "templates": {"cpp": "class Solution {\npublic:\n    int alternatingSubarray(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public int alternatingSubarray(int[] nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def alternatingSubarray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def alternatingSubarray(self, nums: List[int]) -> int:\n        ", "c": "int alternatingSubarray(int* nums, int numsSize){\n\n}", "csharp": "public class Solution {\n    public int AlternatingSubarray(int[] nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar alternatingSubarray = function(nums) {\n    \n};", "typescript": "function alternatingSubarray(nums: number[]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function alternatingSubarray($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func alternatingSubarray(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun alternatingSubarray(nums: IntArray): Int {\n        \n    }\n}", "dart": "class Solution {\n  int alternatingSubarray(List<int> nums) {\n\n  }\n}", "golang": "func alternatingSubarray(nums []int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef alternating_subarray(nums)\n    \nend", "scala": "object Solution {\n    def alternatingSubarray(nums: Array[Int]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn alternating_subarray(nums: Vec<i32>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (alternating-subarray nums)\n  (-> (listof exact-integer?) exact-integer?)\n\n  )", "erlang": "-spec alternating_subarray(Nums :: [integer()]) -> integer().\nalternating_subarray(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec alternating_subarray(nums :: [integer]) :: integer\n  def alternating_subarray(nums) do\n\n  end\nend"}}
{"id": "leetcode_2932", "url": "https://leetcode.com/problems/maximum-strong-pair-xor-i/", "title": "Maximum Strong Pair XOR I", "description": "You are given a **0-indexed** integer array `nums`. A pair of integers `x` and `y` is called a **strong** pair if it satisfies the condition:\n\n\n* `|x - y| <= min(x, y)`\n\n\nYou need to select two integers from `nums` such that they form a strong pair and their bitwise `XOR` is the **maximum** among all strong pairs in the array.\n\n\nReturn *the **maximum*** `XOR` *value out of all possible strong pairs in the array* `nums`.\n\n\n**Note** that you can pick the same integer twice to form a pair.", "examples": ["**Input:** nums = [1,2,3,4,5]\n**Output:** 7\n**Explanation:** There are 11 strong pairs in the array nums: (1, 1), (1, 2), (2, 2), (2, 3), (2, 4), (3, 3), (3, 4), (3, 5), (4, 4), (4, 5) and (5, 5).\nThe maximum XOR possible from these pairs is 3 XOR 4 = 7.", "**Input:** nums = [10,100]\n**Output:** 0\n**Explanation:** There are 2 strong pairs in the array nums: (10, 10) and (100, 100).\nThe maximum XOR possible from these pairs is 10 XOR 10 = 0 since the pair (100, 100) also gives 100 XOR 100 = 0.", "**Input:** nums = [5,6,25,30]\n**Output:** 7\n**Explanation:** There are 6 strong pairs in the array nums: (5, 5), (5, 6), (6, 6), (25, 25), (25, 30) and (30, 30).\nThe maximum XOR possible from these pairs is 25 XOR 30 = 7 since the only other non-zero XOR value is 5 XOR 6 = 3."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 50`\n* `1 <= nums[i] <= 100`", "difficulty": "Easy", "tags": ["Array", "Hash Table", "Bit Manipulation", "Trie", "Sliding Window"], "hints": ["The constraints are small enough to make brute-force solutions pass."], "templates": {"cpp": "class Solution {\npublic:\n    int maximumStrongPairXor(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public int maximumStrongPairXor(int[] nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def maximumStrongPairXor(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def maximumStrongPairXor(self, nums: List[int]) -> int:\n        ", "c": "int maximumStrongPairXor(int* nums, int numsSize) {\n    \n}", "csharp": "public class Solution {\n    public int MaximumStrongPairXor(int[] nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maximumStrongPairXor = function(nums) {\n    \n};", "typescript": "function maximumStrongPairXor(nums: number[]): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function maximumStrongPairXor($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func maximumStrongPairXor(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun maximumStrongPairXor(nums: IntArray): Int {\n        \n    }\n}", "dart": "class Solution {\n  int maximumStrongPairXor(List<int> nums) {\n    \n  }\n}", "golang": "func maximumStrongPairXor(nums []int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef maximum_strong_pair_xor(nums)\n    \nend", "scala": "object Solution {\n    def maximumStrongPairXor(nums: Array[Int]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn maximum_strong_pair_xor(nums: Vec<i32>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (maximum-strong-pair-xor nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )", "erlang": "-spec maximum_strong_pair_xor(Nums :: [integer()]) -> integer().\nmaximum_strong_pair_xor(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec maximum_strong_pair_xor(nums :: [integer]) :: integer\n  def maximum_strong_pair_xor(nums) do\n    \n  end\nend"}}
{"id": "leetcode_2748", "url": "https://leetcode.com/problems/number-of-beautiful-pairs/", "title": "Number of Beautiful Pairs", "description": "You are given a **0-indexed** integer array `nums`. A pair of indices `i`, `j` where `0 <=\u00a0i < j < nums.length` is called beautiful if the **first digit** of `nums[i]` and the **last digit** of `nums[j]` are **coprime**.\n\n\nReturn *the total number of beautiful pairs in* `nums`.\n\n\nTwo integers `x` and `y` are **coprime** if there is no integer greater than 1 that divides both of them. In other words, `x` and `y` are coprime if `gcd(x, y) == 1`, where `gcd(x, y)` is the **greatest common divisor** of `x` and `y`.", "examples": ["**Input:** nums = [2,5,1,4]\n**Output:** 5\n**Explanation:** There are 5 beautiful pairs in nums:\nWhen i = 0 and j = 1: the first digit of nums[0] is 2, and the last digit of nums[1] is 5. We can confirm that 2 and 5 are coprime, since gcd(2,5) == 1.\nWhen i = 0 and j = 2: the first digit of nums[0] is 2, and the last digit of nums[2] is 1. Indeed, gcd(2,1) == 1.\nWhen i = 1 and j = 2: the first digit of nums[1] is 5, and the last digit of nums[2] is 1. Indeed, gcd(5,1) == 1.\nWhen i = 1 and j = 3: the first digit of nums[1] is 5, and the last digit of nums[3] is 4. Indeed, gcd(5,4) == 1.\nWhen i = 2 and j = 3: the first digit of nums[2] is 1, and the last digit of nums[3] is 4. Indeed, gcd(1,4) == 1.\nThus, we return 5.", "**Input:** nums = [11,21,12]\n**Output:** 2\n**Explanation:** There are 2 beautiful pairs:\nWhen i = 0 and j = 1: the first digit of nums[0] is 1, and the last digit of nums[1] is 1. Indeed, gcd(1,1) == 1.\nWhen i = 0 and j = 2: the first digit of nums[0] is 1, and the last digit of nums[2] is 2. Indeed, gcd(1,2) == 1.\nThus, we return 2."], "constraints": "**Constraints:**\n\n\n* `2 <= nums.length <= 100`\n* `1 <= nums[i] <= 9999`\n* `nums[i] % 10 != 0`", "difficulty": "Easy", "tags": ["Array", "Math", "Number Theory"], "hints": ["Since nums.length is small, you can find all pairs of indices and check if each pair is beautiful.", "Use integer to string conversion to get the first and last digit of each number."], "templates": {"cpp": "class Solution {\npublic:\n    int countBeautifulPairs(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public int countBeautifulPairs(int[] nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def countBeautifulPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def countBeautifulPairs(self, nums: List[int]) -> int:\n        ", "c": "int countBeautifulPairs(int* nums, int numsSize){\n\n}", "csharp": "public class Solution {\n    public int CountBeautifulPairs(int[] nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar countBeautifulPairs = function(nums) {\n    \n};", "typescript": "function countBeautifulPairs(nums: number[]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function countBeautifulPairs($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func countBeautifulPairs(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun countBeautifulPairs(nums: IntArray): Int {\n        \n    }\n}", "dart": "class Solution {\n  int countBeautifulPairs(List<int> nums) {\n\n  }\n}", "golang": "func countBeautifulPairs(nums []int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef count_beautiful_pairs(nums)\n    \nend", "scala": "object Solution {\n    def countBeautifulPairs(nums: Array[Int]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn count_beautiful_pairs(nums: Vec<i32>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (count-beautiful-pairs nums)\n  (-> (listof exact-integer?) exact-integer?)\n\n  )", "erlang": "-spec count_beautiful_pairs(Nums :: [integer()]) -> integer().\ncount_beautiful_pairs(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec count_beautiful_pairs(nums :: [integer]) :: integer\n  def count_beautiful_pairs(nums) do\n\n  end\nend"}}
{"id": "leetcode_2965", "url": "https://leetcode.com/problems/find-missing-and-repeated-values/", "title": "Find Missing and Repeated Values", "description": "You are given a **0-indexed** 2D integer matrix `grid` of size `n * n` with values in the range `[1, n2]`. Each integer appears **exactly once** except `a` which appears **twice** and `b` which is **missing**. The task is to find the repeating and missing numbers `a` and `b`.\n\n\nReturn *a **0-indexed** integer array* `ans` *of size* `2` *where* `ans[0]` *equals to* `a` *and* `ans[1]` *equals to* `b`*.*", "examples": ["**Input:** grid = [[1,3],[2,2]]\n**Output:** [2,4]\n**Explanation:** Number 2 is repeated and number 4 is missing so the answer is [2,4].", "**Input:** grid = [[9,1,7],[8,9,2],[3,4,6]]\n**Output:** [9,5]\n**Explanation:** Number 9 is repeated and number 5 is missing so the answer is [9,5]."], "constraints": "**Constraints:**\n\n\n* `2 <= n == grid.length == grid[i].length <= 50`\n* `1 <= grid[i][j] <= n * n`\n* For all `x` that `1 <= x <= n * n` there is exactly one `x` that is not equal to any of the grid members.\n* For all `x` that `1 <= x <= n * n` there is exactly one `x` that is equal to exactly two of the grid members.\n* For all `x` that `1 <= x <= n * n` except two of them there is exatly one pair of `i, j` that `0 <= i, j <= n - 1` and `grid[i][j] == x`.", "difficulty": "Easy", "tags": ["Array", "Hash Table", "Math", "Matrix"], "hints": [], "templates": {"cpp": "class Solution {\npublic:\n    vector<int> findMissingAndRepeatedValues(vector<vector<int>>& grid) {\n        \n    }\n};", "java": "class Solution {\n    public int[] findMissingAndRepeatedValues(int[][] grid) {\n        \n    }\n}", "python": "class Solution(object):\n    def findMissingAndRepeatedValues(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        ", "python3": "class Solution:\n    def findMissingAndRepeatedValues(self, grid: List[List[int]]) -> List[int]:\n        ", "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* findMissingAndRepeatedValues(int** grid, int gridSize, int* gridColSize, int* returnSize) {\n    \n}", "csharp": "public class Solution {\n    public int[] FindMissingAndRepeatedValues(int[][] grid) {\n        \n    }\n}", "javascript": "/**\n * @param {number[][]} grid\n * @return {number[]}\n */\nvar findMissingAndRepeatedValues = function(grid) {\n    \n};", "typescript": "function findMissingAndRepeatedValues(grid: number[][]): number[] {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[][] $grid\n     * @return Integer[]\n     */\n    function findMissingAndRepeatedValues($grid) {\n        \n    }\n}", "swift": "class Solution {\n    func findMissingAndRepeatedValues(_ grid: [[Int]]) -> [Int] {\n        \n    }\n}", "kotlin": "class Solution {\n    fun findMissingAndRepeatedValues(grid: Array<IntArray>): IntArray {\n        \n    }\n}", "dart": "class Solution {\n  List<int> findMissingAndRepeatedValues(List<List<int>> grid) {\n    \n  }\n}", "golang": "func findMissingAndRepeatedValues(grid [][]int) []int {\n    \n}", "ruby": "# @param {Integer[][]} grid\n# @return {Integer[]}\ndef find_missing_and_repeated_values(grid)\n    \nend", "scala": "object Solution {\n    def findMissingAndRepeatedValues(grid: Array[Array[Int]]): Array[Int] = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn find_missing_and_repeated_values(grid: Vec<Vec<i32>>) -> Vec<i32> {\n        \n    }\n}", "racket": "(define/contract (find-missing-and-repeated-values grid)\n  (-> (listof (listof exact-integer?)) (listof exact-integer?))\n  )", "erlang": "-spec find_missing_and_repeated_values(Grid :: [[integer()]]) -> [integer()].\nfind_missing_and_repeated_values(Grid) ->\n  .", "elixir": "defmodule Solution do\n  @spec find_missing_and_repeated_values(grid :: [[integer]]) :: [integer]\n  def find_missing_and_repeated_values(grid) do\n    \n  end\nend"}}
{"id": "leetcode_2733", "url": "https://leetcode.com/problems/neither-minimum-nor-maximum/", "title": "Neither Minimum nor Maximum", "description": "Given an integer array `nums` containing **distinct** **positive** integers, find and return **any** number from the array that is neither the **minimum** nor the **maximum** value in the array, or **`-1`** if there is no such number.\n\n\nReturn *the selected integer.*", "examples": ["**Input:** nums = [3,2,1,4]\n**Output:** 2\n**Explanation:** In this example, the minimum value is 1 and the maximum value is 4. Therefore, either 2 or 3 can be valid answers.", "**Input:** nums = [1,2]\n**Output:** -1\n**Explanation:** Since there is no number in nums that is neither the maximum nor the minimum, we cannot select a number that satisfies the given condition. Therefore, there is no answer.", "**Input:** nums = [2,1,3]\n**Output:** 2\n**Explanation:** Since 2 is neither the maximum nor the minimum value in nums, it is the only valid answer."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 100`\n* `1 <= nums[i] <= 100`\n* All values in `nums` are distinct", "difficulty": "Easy", "tags": ["Array", "Sorting"], "hints": ["Find any value in the array that is not the minimum or the maximum value."], "templates": {"cpp": "class Solution {\npublic:\n    int findNonMinOrMax(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public int findNonMinOrMax(int[] nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def findNonMinOrMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def findNonMinOrMax(self, nums: List[int]) -> int:\n        ", "c": "int findNonMinOrMax(int* nums, int numsSize){\n\n}", "csharp": "public class Solution {\n    public int FindNonMinOrMax(int[] nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findNonMinOrMax = function(nums) {\n    \n};", "typescript": "function findNonMinOrMax(nums: number[]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function findNonMinOrMax($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func findNonMinOrMax(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun findNonMinOrMax(nums: IntArray): Int {\n        \n    }\n}", "dart": "class Solution {\n  int findNonMinOrMax(List<int> nums) {\n\n  }\n}", "golang": "func findNonMinOrMax(nums []int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef find_non_min_or_max(nums)\n    \nend", "scala": "object Solution {\n    def findNonMinOrMax(nums: Array[Int]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn find_non_min_or_max(nums: Vec<i32>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (find-non-min-or-max nums)\n  (-> (listof exact-integer?) exact-integer?)\n\n  )", "erlang": "-spec find_non_min_or_max(Nums :: [integer()]) -> integer().\nfind_non_min_or_max(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec find_non_min_or_max(nums :: [integer]) :: integer\n  def find_non_min_or_max(nums) do\n\n  end\nend"}}
{"id": "leetcode_2908", "url": "https://leetcode.com/problems/minimum-sum-of-mountain-triplets-i/", "title": "Minimum Sum of Mountain Triplets I", "description": "You are given a **0-indexed** array `nums` of integers.\n\n\nA triplet of indices `(i, j, k)` is a **mountain** if:\n\n\n* `i < j < k`\n* `nums[i] < nums[j]` and `nums[k] < nums[j]`\n\n\nReturn *the **minimum possible sum** of a mountain triplet of* `nums`. *If no such triplet exists, return* `-1`.", "examples": ["**Input:** nums = [8,6,1,5,3]\n**Output:** 9\n**Explanation:** Triplet (2, 3, 4) is a mountain triplet of sum 9 since: \n- 2 < 3 < 4\n- nums[2] < nums[3] and nums[4] < nums[3]\nAnd the sum of this triplet is nums[2] + nums[3] + nums[4] = 9. It can be shown that there are no mountain triplets with a sum of less than 9.", "**Input:** nums = [5,4,8,7,10,2]\n**Output:** 13\n**Explanation:** Triplet (1, 3, 5) is a mountain triplet of sum 13 since: \n- 1 < 3 < 5\n- nums[1] < nums[3] and nums[5] < nums[3]\nAnd the sum of this triplet is nums[1] + nums[3] + nums[5] = 13. It can be shown that there are no mountain triplets with a sum of less than 13.", "**Input:** nums = [6,5,4,3,4,5]\n**Output:** -1\n**Explanation:** It can be shown that there are no mountain triplets in nums."], "constraints": "**Constraints:**\n\n\n* `3 <= nums.length <= 50`\n* `1 <= nums[i] <= 50`", "difficulty": "Easy", "tags": ["Array"], "hints": ["Bruteforce over all possible triplets."], "templates": {"cpp": "class Solution {\npublic:\n    int minimumSum(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public int minimumSum(int[] nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def minimumSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def minimumSum(self, nums: List[int]) -> int:\n        ", "c": "int minimumSum(int* nums, int numsSize) {\n    \n}", "csharp": "public class Solution {\n    public int MinimumSum(int[] nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minimumSum = function(nums) {\n    \n};", "typescript": "function minimumSum(nums: number[]): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function minimumSum($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func minimumSum(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun minimumSum(nums: IntArray): Int {\n        \n    }\n}", "dart": "class Solution {\n  int minimumSum(List<int> nums) {\n    \n  }\n}", "golang": "func minimumSum(nums []int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef minimum_sum(nums)\n    \nend", "scala": "object Solution {\n    def minimumSum(nums: Array[Int]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn minimum_sum(nums: Vec<i32>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (minimum-sum nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )", "erlang": "-spec minimum_sum(Nums :: [integer()]) -> integer().\nminimum_sum(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec minimum_sum(nums :: [integer]) :: integer\n  def minimum_sum(nums) do\n    \n  end\nend"}}
{"id": "leetcode_2928", "url": "https://leetcode.com/problems/distribute-candies-among-children-i/", "title": "Distribute Candies Among Children I", "description": "You are given two positive integers `n` and `limit`.\n\n\nReturn *the **total number** of ways to distribute* `n` *candies among* `3` *children such that no child gets more than* `limit` *candies.*", "examples": ["**Input:** n = 5, limit = 2\n**Output:** 3\n**Explanation:** There are 3 ways to distribute 5 candies such that no child gets more than 2 candies: (1, 2, 2), (2, 1, 2) and (2, 2, 1).", "**Input:** n = 3, limit = 3\n**Output:** 10\n**Explanation:** There are 10 ways to distribute 3 candies such that no child gets more than 3 candies: (0, 0, 3), (0, 1, 2), (0, 2, 1), (0, 3, 0), (1, 0, 2), (1, 1, 1), (1, 2, 0), (2, 0, 1), (2, 1, 0) and (3, 0, 0)."], "constraints": "**Constraints:**\n\n\n* `1 <= n <= 50`\n* `1 <= limit <= 50`", "difficulty": "Easy", "tags": ["Math", "Combinatorics", "Enumeration"], "hints": ["Use three nested for loops to check all the triplets."], "templates": {"cpp": "class Solution {\npublic:\n    int distributeCandies(int n, int limit) {\n        \n    }\n};", "java": "class Solution {\n    public int distributeCandies(int n, int limit) {\n        \n    }\n}", "python": "class Solution(object):\n    def distributeCandies(self, n, limit):\n        \"\"\"\n        :type n: int\n        :type limit: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def distributeCandies(self, n: int, limit: int) -> int:\n        ", "c": "int distributeCandies(int n, int limit) {\n    \n}", "csharp": "public class Solution {\n    public int DistributeCandies(int n, int limit) {\n        \n    }\n}", "javascript": "/**\n * @param {number} n\n * @param {number} limit\n * @return {number}\n */\nvar distributeCandies = function(n, limit) {\n    \n};", "typescript": "function distributeCandies(n: number, limit: number): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer $limit\n     * @return Integer\n     */\n    function distributeCandies($n, $limit) {\n        \n    }\n}", "swift": "class Solution {\n    func distributeCandies(_ n: Int, _ limit: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun distributeCandies(n: Int, limit: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int distributeCandies(int n, int limit) {\n    \n  }\n}", "golang": "func distributeCandies(n int, limit int) int {\n    \n}", "ruby": "# @param {Integer} n\n# @param {Integer} limit\n# @return {Integer}\ndef distribute_candies(n, limit)\n    \nend", "scala": "object Solution {\n    def distributeCandies(n: Int, limit: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn distribute_candies(n: i32, limit: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (distribute-candies n limit)\n  (-> exact-integer? exact-integer? exact-integer?)\n  )", "erlang": "-spec distribute_candies(N :: integer(), Limit :: integer()) -> integer().\ndistribute_candies(N, Limit) ->\n  .", "elixir": "defmodule Solution do\n  @spec distribute_candies(n :: integer, limit :: integer) :: integer\n  def distribute_candies(n, limit) do\n    \n  end\nend"}}
{"id": "leetcode_2744", "url": "https://leetcode.com/problems/find-maximum-number-of-string-pairs/", "title": "Find Maximum Number of String Pairs", "description": "You are given a **0-indexed** array `words` consisting of **distinct** strings.\n\n\nThe string `words[i]` can be paired with the string `words[j]` if:\n\n\n* The string `words[i]` is equal to the reversed string of `words[j]`.\n* `0 <= i < j < words.length`.\n\n\nReturn *the **maximum** number of pairs that can be formed from the array* `words`*.*\n\n\nNote that\u00a0each string can belong in\u00a0**at most one** pair.", "examples": ["**Input:** words = [\"cd\",\"ac\",\"dc\",\"ca\",\"zz\"]\n**Output:** 2\n**Explanation:** In this example, we can form 2 pair of strings in the following way:\n- We pair the 0th string with the 2nd string, as the reversed string of word[0] is \"dc\" and is equal to words[2].\n- We pair the 1st string with the 3rd string, as the reversed string of word[1] is \"ca\" and is equal to words[3].\nIt can be proven that 2 is the maximum number of pairs that can be formed.", "**Input:** words = [\"ab\",\"ba\",\"cc\"]\n**Output:** 1\n**Explanation:** In this example, we can form 1 pair of strings in the following way:\n- We pair the 0th string with the 1st string, as the reversed string of words[1] is \"ab\" and is equal to words[0].\nIt can be proven that 1 is the maximum number of pairs that can be formed.", "**Input:** words = [\"aa\",\"ab\"]\n**Output:** 0\n**Explanation:** In this example, we are unable to form any pair of strings."], "constraints": "**Constraints:**\n\n\n* `1 <= words.length <= 50`\n* `words[i].length == 2`\n* `words`\u00a0consists of distinct strings.\n* `words[i]`\u00a0contains only lowercase English letters.", "difficulty": "Easy", "tags": ["Array", "Hash Table", "String", "Simulation"], "hints": ["Notice that array words consist of distinct strings.", "Iterate over all indices (i, j) and check if they can be paired."], "templates": {"cpp": "class Solution {\npublic:\n    int maximumNumberOfStringPairs(vector<string>& words) {\n        \n    }\n};", "java": "class Solution {\n    public int maximumNumberOfStringPairs(String[] words) {\n        \n    }\n}", "python": "class Solution(object):\n    def maximumNumberOfStringPairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\n        ", "c": "int maximumNumberOfStringPairs(char ** words, int wordsSize){\n\n}", "csharp": "public class Solution {\n    public int MaximumNumberOfStringPairs(string[] words) {\n        \n    }\n}", "javascript": "/**\n * @param {string[]} words\n * @return {number}\n */\nvar maximumNumberOfStringPairs = function(words) {\n    \n};", "typescript": "function maximumNumberOfStringPairs(words: string[]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param String[] $words\n     * @return Integer\n     */\n    function maximumNumberOfStringPairs($words) {\n        \n    }\n}", "swift": "class Solution {\n    func maximumNumberOfStringPairs(_ words: [String]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun maximumNumberOfStringPairs(words: Array<String>): Int {\n        \n    }\n}", "dart": "class Solution {\n  int maximumNumberOfStringPairs(List<String> words) {\n\n  }\n}", "golang": "func maximumNumberOfStringPairs(words []string) int {\n    \n}", "ruby": "# @param {String[]} words\n# @return {Integer}\ndef maximum_number_of_string_pairs(words)\n    \nend", "scala": "object Solution {\n    def maximumNumberOfStringPairs(words: Array[String]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn maximum_number_of_string_pairs(words: Vec<String>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (maximum-number-of-string-pairs words)\n  (-> (listof string?) exact-integer?)\n\n  )", "erlang": "-spec maximum_number_of_string_pairs(Words :: [unicode:unicode_binary()]) -> integer().\nmaximum_number_of_string_pairs(Words) ->\n  .", "elixir": "defmodule Solution do\n  @spec maximum_number_of_string_pairs(words :: [String.t]) :: integer\n  def maximum_number_of_string_pairs(words) do\n\n  end\nend"}}
{"id": "leetcode_2894", "url": "https://leetcode.com/problems/divisible-and-non-divisible-sums-difference/", "title": "Divisible and Non-divisible Sums Difference", "description": "You are given positive integers `n` and `m`.\n\n\nDefine two integers, `num1` and `num2`, as follows:\n\n\n* `num1`: The sum of all integers in the range `[1, n]` that are **not divisible** by `m`.\n* `num2`: The sum of all integers in the range `[1, n]` that are **divisible** by `m`.\n\n\nReturn *the integer* `num1 - num2`.", "examples": ["**Input:** n = 10, m = 3\n**Output:** 19\n**Explanation:** In the given example:\n- Integers in the range [1, 10] that are not divisible by 3 are [1,2,4,5,7,8,10], num1 is the sum of those integers = 37.\n- Integers in the range [1, 10] that are divisible by 3 are [3,6,9], num2 is the sum of those integers = 18.\nWe return 37 - 18 = 19 as the answer.", "**Input:** n = 5, m = 6\n**Output:** 15\n**Explanation:** In the given example:\n- Integers in the range [1, 5] that are not divisible by 6 are [1,2,3,4,5], num1 is the sum of those integers = 15.\n- Integers in the range [1, 5] that are divisible by 6 are [], num2 is the sum of those integers = 0.\nWe return 15 - 0 = 15 as the answer.", "**Input:** n = 5, m = 1\n**Output:** -15\n**Explanation:** In the given example:\n- Integers in the range [1, 5] that are not divisible by 1 are [], num1 is the sum of those integers = 0.\n- Integers in the range [1, 5] that are divisible by 1 are [1,2,3,4,5], num2 is the sum of those integers = 15.\nWe return 0 - 15 = -15 as the answer."], "constraints": "**Constraints:**\n\n\n* `1 <= n, m <= 1000`", "difficulty": "Easy", "tags": ["Math"], "hints": ["With arithmetic progression we know that the sum of integers in the range <code>[1, n]</code> is <code>n * (n + 1) / 2 </code>."], "templates": {"cpp": "class Solution {\npublic:\n    int differenceOfSums(int n, int m) {\n        \n    }\n};", "java": "class Solution {\n    public int differenceOfSums(int n, int m) {\n        \n    }\n}", "python": "class Solution(object):\n    def differenceOfSums(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def differenceOfSums(self, n: int, m: int) -> int:\n        ", "c": "int differenceOfSums(int n, int m) {\n    \n}", "csharp": "public class Solution {\n    public int DifferenceOfSums(int n, int m) {\n        \n    }\n}", "javascript": "/**\n * @param {number} n\n * @param {number} m\n * @return {number}\n */\nvar differenceOfSums = function(n, m) {\n    \n};", "typescript": "function differenceOfSums(n: number, m: number): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer $m\n     * @return Integer\n     */\n    function differenceOfSums($n, $m) {\n        \n    }\n}", "swift": "class Solution {\n    func differenceOfSums(_ n: Int, _ m: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun differenceOfSums(n: Int, m: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int differenceOfSums(int n, int m) {\n    \n  }\n}", "golang": "func differenceOfSums(n int, m int) int {\n    \n}", "ruby": "# @param {Integer} n\n# @param {Integer} m\n# @return {Integer}\ndef difference_of_sums(n, m)\n    \nend", "scala": "object Solution {\n    def differenceOfSums(n: Int, m: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn difference_of_sums(n: i32, m: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (difference-of-sums n m)\n  (-> exact-integer? exact-integer? exact-integer?)\n  )", "erlang": "-spec difference_of_sums(N :: integer(), M :: integer()) -> integer().\ndifference_of_sums(N, M) ->\n  .", "elixir": "defmodule Solution do\n  @spec difference_of_sums(n :: integer, m :: integer) :: integer\n  def difference_of_sums(n, m) do\n    \n  end\nend"}}
{"id": "leetcode_2729", "url": "https://leetcode.com/problems/check-if-the-number-is-fascinating/", "title": "Check if The Number is Fascinating", "description": "You are given an integer `n` that consists of exactly `3` digits.\n\n\nWe call the number `n` **fascinating** if, after the following modification, the resulting number contains all the digits from `1` to `9` **exactly** once and does not contain any `0`'s:\n\n\n* **Concatenate** `n` with the numbers `2 * n` and `3 * n`.\n\n\nReturn `true` *if* `n` *is fascinating, or* `false` *otherwise*.\n\n\n**Concatenating** two numbers means joining them together. For example, the concatenation of `121` and `371` is `121371`.", "examples": ["**Input:** n = 192\n**Output:** true\n**Explanation:** We concatenate the numbers n = 192 and 2 * n = 384 and 3 * n = 576. The resulting number is 192384576. This number contains all the digits from 1 to 9 exactly once.", "**Input:** n = 100\n**Output:** false\n**Explanation:** We concatenate the numbers n = 100 and 2 * n = 200 and 3 * n = 300. The resulting number is 100200300. This number does not satisfy any of the conditions."], "constraints": "**Constraints:**\n\n\n* `100 <= n <= 999`", "difficulty": "Easy", "tags": ["Hash Table", "Math"], "hints": ["Consider changing the number to the way it is described in the statement.", "Check if the resulting number contains all the digits from 1 to 9 exactly once."], "templates": {"cpp": "class Solution {\npublic:\n    bool isFascinating(int n) {\n        \n    }\n};", "java": "class Solution {\n    public boolean isFascinating(int n) {\n        \n    }\n}", "python": "class Solution(object):\n    def isFascinating(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        ", "python3": "class Solution:\n    def isFascinating(self, n: int) -> bool:\n        ", "c": "bool isFascinating(int n){\n\n}", "csharp": "public class Solution {\n    public bool IsFascinating(int n) {\n        \n    }\n}", "javascript": "/**\n * @param {number} n\n * @return {boolean}\n */\nvar isFascinating = function(n) {\n    \n};", "typescript": "function isFascinating(n: number): boolean {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return Boolean\n     */\n    function isFascinating($n) {\n        \n    }\n}", "swift": "class Solution {\n    func isFascinating(_ n: Int) -> Bool {\n        \n    }\n}", "kotlin": "class Solution {\n    fun isFascinating(n: Int): Boolean {\n        \n    }\n}", "dart": "class Solution {\n  bool isFascinating(int n) {\n\n  }\n}", "golang": "func isFascinating(n int) bool {\n    \n}", "ruby": "# @param {Integer} n\n# @return {Boolean}\ndef is_fascinating(n)\n    \nend", "scala": "object Solution {\n    def isFascinating(n: Int): Boolean = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn is_fascinating(n: i32) -> bool {\n        \n    }\n}", "racket": "(define/contract (is-fascinating n)\n  (-> exact-integer? boolean?)\n\n  )", "erlang": "-spec is_fascinating(N :: integer()) -> boolean().\nis_fascinating(N) ->\n  .", "elixir": "defmodule Solution do\n  @spec is_fascinating(n :: integer) :: boolean\n  def is_fascinating(n) do\n\n  end\nend"}}
{"id": "leetcode_2923", "url": "https://leetcode.com/problems/find-champion-i/", "title": "Find Champion I", "description": "There are `n` teams numbered from `0` to `n - 1` in a tournament.\n\n\nGiven a **0-indexed** 2D boolean matrix `grid` of size `n * n`. For all `i, j` that `0 <= i, j <= n - 1` and `i != j` team `i` is **stronger** than team `j` if `grid[i][j] == 1`, otherwise, team `j` is **stronger** than team `i`.\n\n\nTeam `a` will be the **champion** of the tournament if there is no team `b` that is stronger than team `a`.\n\n\nReturn *the team that will be the champion of the tournament.*", "examples": ["**Input:** grid = [[0,1],[0,0]]\n**Output:** 0\n**Explanation:** There are two teams in this tournament.\ngrid[0][1] == 1 means that team 0 is stronger than team 1. So team 0 will be the champion.", "**Input:** grid = [[0,0,1],[1,0,1],[0,0,0]]\n**Output:** 1\n**Explanation:** There are three teams in this tournament.\ngrid[1][0] == 1 means that team 1 is stronger than team 0.\ngrid[1][2] == 1 means that team 1 is stronger than team 2.\nSo team 1 will be the champion."], "constraints": "**Constraints:**\n\n\n* `n == grid.length`\n* `n == grid[i].length`\n* `2 <= n <= 100`\n* `grid[i][j]` is either `0` or `1`.\n* For all `i grid[i][i]` is `0.`\n* For all `i, j` that `i != j`, `grid[i][j] != grid[j][i]`.\n* The input is generated such that if team `a` is stronger than team `b` and team `b` is stronger than team `c`, then team `a` is stronger than team `c`.", "difficulty": "Easy", "tags": ["Array", "Matrix"], "hints": ["The champion should be stronger than all the other teams."], "templates": {"cpp": "class Solution {\npublic:\n    int findChampion(vector<vector<int>>& grid) {\n        \n    }\n};", "java": "class Solution {\n    public int findChampion(int[][] grid) {\n        \n    }\n}", "python": "class Solution(object):\n    def findChampion(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def findChampion(self, grid: List[List[int]]) -> int:\n        ", "c": "int findChampion(int** grid, int gridSize, int* gridColSize) {\n    \n}", "csharp": "public class Solution {\n    public int FindChampion(int[][] grid) {\n        \n    }\n}", "javascript": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar findChampion = function(grid) {\n    \n};", "typescript": "function findChampion(grid: number[][]): number {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[][] $grid\n     * @return Integer\n     */\n    function findChampion($grid) {\n        \n    }\n}", "swift": "class Solution {\n    func findChampion(_ grid: [[Int]]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun findChampion(grid: Array<IntArray>): Int {\n        \n    }\n}", "dart": "class Solution {\n  int findChampion(List<List<int>> grid) {\n    \n  }\n}", "golang": "func findChampion(grid [][]int) int {\n    \n}", "ruby": "# @param {Integer[][]} grid\n# @return {Integer}\ndef find_champion(grid)\n    \nend", "scala": "object Solution {\n    def findChampion(grid: Array[Array[Int]]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn find_champion(grid: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (find-champion grid)\n  (-> (listof (listof exact-integer?)) exact-integer?)\n  )", "erlang": "-spec find_champion(Grid :: [[integer()]]) -> integer().\nfind_champion(Grid) ->\n  .", "elixir": "defmodule Solution do\n  @spec find_champion(grid :: [[integer]]) :: integer\n  def find_champion(grid) do\n    \n  end\nend"}}
{"id": "leetcode_2974", "url": "https://leetcode.com/problems/minimum-number-game/", "title": "Minimum Number Game", "description": "You are given a **0-indexed** integer array `nums` of **even** length and there is also an empty array `arr`. Alice and Bob decided to play a game where in every round Alice and Bob will do one move. The rules of the game are as follows:\n\n\n* Every round, first Alice will remove the **minimum** element from `nums`, and then Bob does the same.\n* Now, first Bob will append the removed element in the array `arr`, and then Alice does the same.\n* The game continues until `nums` becomes empty.\n\n\nReturn *the resulting array* `arr`.", "examples": ["**Input:** nums = [5,4,2,3]\n**Output:** [3,2,5,4]\n**Explanation:** In round one, first Alice removes 2 and then Bob removes 3. Then in arr firstly Bob appends 3 and then Alice appends 2. So arr = [3,2].\nAt the begining of round two, nums = [5,4]. Now, first Alice removes 4 and then Bob removes 5. Then both append in arr which becomes [3,2,5,4].", "**Input:** nums = [2,5]\n**Output:** [5,2]\n**Explanation:** In round one, first Alice removes 2 and then Bob removes 5. Then in arr firstly Bob appends and then Alice appends. So arr = [5,2]."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length <= 100`\n* `1 <= nums[i] <= 100`\n* `nums.length % 2 == 0`", "difficulty": "Easy", "tags": [], "hints": ["Sort the array in increasing order and then swap the adjacent elements."], "templates": {"cpp": "class Solution {\npublic:\n    vector<int> numberGame(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public int[] numberGame(int[] nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def numberGame(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        ", "python3": "class Solution:\n    def numberGame(self, nums: List[int]) -> List[int]:\n        ", "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* numberGame(int* nums, int numsSize, int* returnSize) {\n    \n}", "csharp": "public class Solution {\n    public int[] NumberGame(int[] nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar numberGame = function(nums) {\n    \n};", "typescript": "function numberGame(nums: number[]): number[] {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer[]\n     */\n    function numberGame($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func numberGame(_ nums: [Int]) -> [Int] {\n        \n    }\n}", "kotlin": "class Solution {\n    fun numberGame(nums: IntArray): IntArray {\n        \n    }\n}", "dart": "class Solution {\n  List<int> numberGame(List<int> nums) {\n    \n  }\n}", "golang": "func numberGame(nums []int) []int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer[]}\ndef number_game(nums)\n    \nend", "scala": "object Solution {\n    def numberGame(nums: Array[Int]): Array[Int] = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn number_game(nums: Vec<i32>) -> Vec<i32> {\n        \n    }\n}", "racket": "(define/contract (number-game nums)\n  (-> (listof exact-integer?) (listof exact-integer?))\n  )", "erlang": "-spec number_game(Nums :: [integer()]) -> [integer()].\nnumber_game(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec number_game(nums :: [integer]) :: [integer]\n  def number_game(nums) do\n    \n  end\nend"}}
{"id": "leetcode_2903", "url": "https://leetcode.com/problems/find-indices-with-index-and-value-difference-i/", "title": "Find Indices With Index and Value Difference I", "description": "You are given a **0-indexed** integer array `nums` having length `n`, an integer `indexDifference`, and an integer `valueDifference`.\n\n\nYour task is to find **two** indices `i` and `j`, both in the range `[0, n - 1]`, that satisfy the following conditions:\n\n\n* `abs(i - j) >= indexDifference`, and\n* `abs(nums[i] - nums[j]) >= valueDifference`\n\n\nReturn *an integer array* `answer`, *where* `answer = [i, j]` *if there are two such indices*, *and* `answer = [-1, -1]` *otherwise*. If there are multiple choices for the two indices, return *any of them*.\n\n\n**Note:** `i` and `j` may be **equal**.", "examples": ["**Input:** nums = [5,1,4,1], indexDifference = 2, valueDifference = 4\n**Output:** [0,3]\n**Explanation:** In this example, i = 0 and j = 3 can be selected.\nabs(0 - 3) >= 2 and abs(nums[0] - nums[3]) >= 4.\nHence, a valid answer is [0,3].\n[3,0] is also a valid answer.", "**Input:** nums = [2,1], indexDifference = 0, valueDifference = 0\n**Output:** [0,0]\n**Explanation:** In this example, i = 0 and j = 0 can be selected.\nabs(0 - 0) >= 0 and abs(nums[0] - nums[0]) >= 0.\nHence, a valid answer is [0,0].\nOther valid answers are [0,1], [1,0], and [1,1].", "**Input:** nums = [1,2,3], indexDifference = 2, valueDifference = 4\n**Output:** [-1,-1]\n**Explanation:** In this example, it can be shown that it is impossible to find two indices that satisfy both conditions.\nHence, [-1,-1] is returned."], "constraints": "**Constraints:**\n\n\n* `1 <= n == nums.length <= 100`\n* `0 <= nums[i] <= 50`\n* `0 <= indexDifference <= 100`\n* `0 <= valueDifference <= 50`", "difficulty": "Easy", "tags": ["Array"], "hints": ["Use bruteforce.", "You can use a nested loop to compare each pair of indices <code>(i, j)</code> and check if the conditions are satisfied."], "templates": {"cpp": "class Solution {\npublic:\n    vector<int> findIndices(vector<int>& nums, int indexDifference, int valueDifference) {\n        \n    }\n};", "java": "class Solution {\n    public int[] findIndices(int[] nums, int indexDifference, int valueDifference) {\n        \n    }\n}", "python": "class Solution(object):\n    def findIndices(self, nums, indexDifference, valueDifference):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDifference: int\n        :type valueDifference: int\n        :rtype: List[int]\n        \"\"\"\n        ", "python3": "class Solution:\n    def findIndices(self, nums: List[int], indexDifference: int, valueDifference: int) -> List[int]:\n        ", "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* findIndices(int* nums, int numsSize, int indexDifference, int valueDifference, int* returnSize) {\n    \n}", "csharp": "public class Solution {\n    public int[] FindIndices(int[] nums, int indexDifference, int valueDifference) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @param {number} indexDifference\n * @param {number} valueDifference\n * @return {number[]}\n */\nvar findIndices = function(nums, indexDifference, valueDifference) {\n    \n};", "typescript": "function findIndices(nums: number[], indexDifference: number, valueDifference: number): number[] {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $indexDifference\n     * @param Integer $valueDifference\n     * @return Integer[]\n     */\n    function findIndices($nums, $indexDifference, $valueDifference) {\n        \n    }\n}", "swift": "class Solution {\n    func findIndices(_ nums: [Int], _ indexDifference: Int, _ valueDifference: Int) -> [Int] {\n        \n    }\n}", "kotlin": "class Solution {\n    fun findIndices(nums: IntArray, indexDifference: Int, valueDifference: Int): IntArray {\n        \n    }\n}", "dart": "class Solution {\n  List<int> findIndices(List<int> nums, int indexDifference, int valueDifference) {\n    \n  }\n}", "golang": "func findIndices(nums []int, indexDifference int, valueDifference int) []int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @param {Integer} index_difference\n# @param {Integer} value_difference\n# @return {Integer[]}\ndef find_indices(nums, index_difference, value_difference)\n    \nend", "scala": "object Solution {\n    def findIndices(nums: Array[Int], indexDifference: Int, valueDifference: Int): Array[Int] = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn find_indices(nums: Vec<i32>, index_difference: i32, value_difference: i32) -> Vec<i32> {\n        \n    }\n}", "racket": "(define/contract (find-indices nums indexDifference valueDifference)\n  (-> (listof exact-integer?) exact-integer? exact-integer? (listof exact-integer?))\n  )", "erlang": "-spec find_indices(Nums :: [integer()], IndexDifference :: integer(), ValueDifference :: integer()) -> [integer()].\nfind_indices(Nums, IndexDifference, ValueDifference) ->\n  .", "elixir": "defmodule Solution do\n  @spec find_indices(nums :: [integer], index_difference :: integer, value_difference :: integer) :: [integer]\n  def find_indices(nums, index_difference, value_difference) do\n    \n  end\nend"}}
{"id": "leetcode_2942", "url": "https://leetcode.com/problems/find-words-containing-character/", "title": "Find Words Containing Character", "description": "You are given a **0-indexed** array of strings `words` and a character `x`.\n\n\nReturn *an **array of indices** representing the words that contain the character* `x`.\n\n\n**Note** that the returned array may be in **any** order.", "examples": ["**Input:** words = [\"leet\",\"code\"], x = \"e\"\n**Output:** [0,1]\n**Explanation:** \"e\" occurs in both words: \"l**ee**t\", and \"cod**e**\". Hence, we return indices 0 and 1.", "**Input:** words = [\"abc\",\"bcd\",\"aaaa\",\"cbc\"], x = \"a\"\n**Output:** [0,2]\n**Explanation:** \"a\" occurs in \"**a**bc\", and \"**aaaa**\". Hence, we return indices 0 and 2.", "**Input:** words = [\"abc\",\"bcd\",\"aaaa\",\"cbc\"], x = \"z\"\n**Output:** []\n**Explanation:** \"z\" does not occur in any of the words. Hence, we return an empty array."], "constraints": "**Constraints:**\n\n\n* `1 <= words.length <= 50`\n* `1 <= words[i].length <= 50`\n* `x` is a lowercase English letter.\n* `words[i]` consists only of lowercase English letters.", "difficulty": "Easy", "tags": ["Array", "String"], "hints": ["Use two nested loops."], "templates": {"cpp": "class Solution {\npublic:\n    vector<int> findWordsContaining(vector<string>& words, char x) {\n        \n    }\n};", "java": "class Solution {\n    public List<Integer> findWordsContaining(String[] words, char x) {\n        \n    }\n}", "python": "class Solution(object):\n    def findWordsContaining(self, words, x):\n        \"\"\"\n        :type words: List[str]\n        :type x: str\n        :rtype: List[int]\n        \"\"\"\n        ", "python3": "class Solution:\n    def findWordsContaining(self, words: List[str], x: str) -> List[int]:\n        ", "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* findWordsContaining(char** words, int wordsSize, char x, int* returnSize) {\n    \n}", "csharp": "public class Solution {\n    public IList<int> FindWordsContaining(string[] words, char x) {\n        \n    }\n}", "javascript": "/**\n * @param {string[]} words\n * @param {character} x\n * @return {number[]}\n */\nvar findWordsContaining = function(words, x) {\n    \n};", "typescript": "function findWordsContaining(words: string[], x: string): number[] {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param String[] $words\n     * @param String $x\n     * @return Integer[]\n     */\n    function findWordsContaining($words, $x) {\n        \n    }\n}", "swift": "class Solution {\n    func findWordsContaining(_ words: [String], _ x: Character) -> [Int] {\n        \n    }\n}", "kotlin": "class Solution {\n    fun findWordsContaining(words: Array<String>, x: Char): List<Int> {\n        \n    }\n}", "dart": "class Solution {\n  List<int> findWordsContaining(List<String> words, String x) {\n    \n  }\n}", "golang": "func findWordsContaining(words []string, x byte) []int {\n    \n}", "ruby": "# @param {String[]} words\n# @param {Character} x\n# @return {Integer[]}\ndef find_words_containing(words, x)\n    \nend", "scala": "object Solution {\n    def findWordsContaining(words: Array[String], x: Char): List[Int] = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn find_words_containing(words: Vec<String>, x: char) -> Vec<i32> {\n        \n    }\n}", "racket": "(define/contract (find-words-containing words x)\n  (-> (listof string?) char? (listof exact-integer?))\n  )", "erlang": "-spec find_words_containing(Words :: [unicode:unicode_binary()], X :: char()) -> [integer()].\nfind_words_containing(Words, X) ->\n  .", "elixir": "defmodule Solution do\n  @spec find_words_containing(words :: [String.t], x :: char) :: [integer]\n  def find_words_containing(words, x) do\n    \n  end\nend"}}
{"id": "leetcode_2739", "url": "https://leetcode.com/problems/total-distance-traveled/", "title": "Total Distance Traveled", "description": "A truck has two fuel tanks. You are given two integers, `mainTank` representing the fuel present in the main tank in liters and `additionalTank` representing the fuel present in the additional tank in liters.\n\n\nThe truck has a mileage of `10` km per liter. Whenever `5` liters of fuel get\u00a0used up in the main tank,\u00a0if the additional tank has at least `1` liters of fuel, `1` liters of fuel will be transferred from the additional tank to the main tank.\n\n\nReturn *the maximum distance which can be traveled.*\n\n\n**Note:** Injection from the additional tank is not continuous. It happens suddenly and immediately for every 5 liters consumed.", "examples": ["**Input:** mainTank = 5, additionalTank = 10\n**Output:** 60\n**Explanation:** \nAfter spending 5 litre of fuel, fuel remaining is (5 - 5 + 1) = 1 litre and distance traveled is 50km.\nAfter spending another 1 litre of fuel, no fuel gets injected in the main tank and the main tank becomes empty.\nTotal distance traveled is 60km.", "**Input:** mainTank = 1, additionalTank = 2\n**Output:** 10\n**Explanation:** \nAfter spending 1 litre of fuel, the main tank becomes empty.\nTotal distance traveled is 10km."], "constraints": "**Constraints:**\n\n\n* `1 <= mainTank, additionalTank <= 100`", "difficulty": "Easy", "tags": ["Math", "Simulation"], "hints": ["Avoid calculations in decimal to prevent precision errors."], "templates": {"cpp": "class Solution {\npublic:\n    int distanceTraveled(int mainTank, int additionalTank) {\n        \n    }\n};", "java": "class Solution {\n    public int distanceTraveled(int mainTank, int additionalTank) {\n        \n    }\n}", "python": "class Solution(object):\n    def distanceTraveled(self, mainTank, additionalTank):\n        \"\"\"\n        :type mainTank: int\n        :type additionalTank: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\n        ", "c": "int distanceTraveled(int mainTank, int additionalTank){\n\n}", "csharp": "public class Solution {\n    public int DistanceTraveled(int mainTank, int additionalTank) {\n        \n    }\n}", "javascript": "/**\n * @param {number} mainTank\n * @param {number} additionalTank\n * @return {number}\n */\nvar distanceTraveled = function(mainTank, additionalTank) {\n    \n};", "typescript": "function distanceTraveled(mainTank: number, additionalTank: number): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer $mainTank\n     * @param Integer $additionalTank\n     * @return Integer\n     */\n    function distanceTraveled($mainTank, $additionalTank) {\n        \n    }\n}", "swift": "class Solution {\n    func distanceTraveled(_ mainTank: Int, _ additionalTank: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun distanceTraveled(mainTank: Int, additionalTank: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int distanceTraveled(int mainTank, int additionalTank) {\n\n  }\n}", "golang": "func distanceTraveled(mainTank int, additionalTank int) int {\n    \n}", "ruby": "# @param {Integer} main_tank\n# @param {Integer} additional_tank\n# @return {Integer}\ndef distance_traveled(main_tank, additional_tank)\n    \nend", "scala": "object Solution {\n    def distanceTraveled(mainTank: Int, additionalTank: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn distance_traveled(main_tank: i32, additional_tank: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (distance-traveled mainTank additionalTank)\n  (-> exact-integer? exact-integer? exact-integer?)\n\n  )", "erlang": "-spec distance_traveled(MainTank :: integer(), AdditionalTank :: integer()) -> integer().\ndistance_traveled(MainTank, AdditionalTank) ->\n  .", "elixir": "defmodule Solution do\n  @spec distance_traveled(main_tank :: integer, additional_tank :: integer) :: integer\n  def distance_traveled(main_tank, additional_tank) do\n\n  end\nend"}}
{"id": "leetcode_2806", "url": "https://leetcode.com/problems/account-balance-after-rounded-purchase/", "title": "Account Balance After Rounded Purchase", "description": "Initially, you have a bank account balance of `100` dollars.\n\n\nYou are given an integer `purchaseAmount` representing the amount you will spend on a purchase in dollars.\n\n\nAt the store where you will make the purchase, the purchase amount is rounded to the **nearest multiple** of `10`. In other words, you pay a **non-negative** amount, `roundedAmount`, such that `roundedAmount` is a multiple of `10` and `abs(roundedAmount - purchaseAmount)` is **minimized**.\n\n\nIf there is more than one nearest multiple of `10`, the **largest multiple** is chosen.\n\n\nReturn *an integer denoting your account balance after making a purchase worth* `purchaseAmount` *dollars from the store.*\n\n\n**Note:** `0` is considered to be a multiple of `10` in this problem.", "examples": ["**Input:** purchaseAmount = 9\n**Output:** 90\n**Explanation:** In this example, the nearest multiple of 10 to 9 is 10. Hence, your account balance becomes 100 - 10 = 90.", "**Input:** purchaseAmount = 15\n**Output:** 80\n**Explanation:** In this example, there are two nearest multiples of 10 to 15: 10 and 20. So, the larger multiple, 20, is chosen.\nHence, your account balance becomes 100 - 20 = 80."], "constraints": "**Constraints:**\n\n\n* `0 <= purchaseAmount <= 100`", "difficulty": "Easy", "tags": ["Math"], "hints": ["To determine the nearest multiple of 10, we can brute force the rounded amount since there are at most 100 options. In case of multiple nearest multiples, choose the largest.", "Another solution is observing that the rounded amount is floor((purchaseAmount + 5) / 10) * 10. Using this formula, we can calculate the account balance without having to brute force the rounded amount."], "templates": {"cpp": "class Solution {\npublic:\n    int accountBalanceAfterPurchase(int purchaseAmount) {\n        \n    }\n};", "java": "class Solution {\n    public int accountBalanceAfterPurchase(int purchaseAmount) {\n        \n    }\n}", "python": "class Solution(object):\n    def accountBalanceAfterPurchase(self, purchaseAmount):\n        \"\"\"\n        :type purchaseAmount: int\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def accountBalanceAfterPurchase(self, purchaseAmount: int) -> int:\n        ", "c": "int accountBalanceAfterPurchase(int purchaseAmount){\n\n}", "csharp": "public class Solution {\n    public int AccountBalanceAfterPurchase(int purchaseAmount) {\n        \n    }\n}", "javascript": "/**\n * @param {number} purchaseAmount\n * @return {number}\n */\nvar accountBalanceAfterPurchase = function(purchaseAmount) {\n    \n};", "typescript": "function accountBalanceAfterPurchase(purchaseAmount: number): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer $purchaseAmount\n     * @return Integer\n     */\n    function accountBalanceAfterPurchase($purchaseAmount) {\n        \n    }\n}", "swift": "class Solution {\n    func accountBalanceAfterPurchase(_ purchaseAmount: Int) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun accountBalanceAfterPurchase(purchaseAmount: Int): Int {\n        \n    }\n}", "dart": "class Solution {\n  int accountBalanceAfterPurchase(int purchaseAmount) {\n\n  }\n}", "golang": "func accountBalanceAfterPurchase(purchaseAmount int) int {\n    \n}", "ruby": "# @param {Integer} purchase_amount\n# @return {Integer}\ndef account_balance_after_purchase(purchase_amount)\n    \nend", "scala": "object Solution {\n    def accountBalanceAfterPurchase(purchaseAmount: Int): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn account_balance_after_purchase(purchase_amount: i32) -> i32 {\n        \n    }\n}", "racket": "(define/contract (account-balance-after-purchase purchaseAmount)\n  (-> exact-integer? exact-integer?)\n\n  )", "erlang": "-spec account_balance_after_purchase(PurchaseAmount :: integer()) -> integer().\naccount_balance_after_purchase(PurchaseAmount) ->\n  .", "elixir": "defmodule Solution do\n  @spec account_balance_after_purchase(purchase_amount :: integer) :: integer\n  def account_balance_after_purchase(purchase_amount) do\n\n  end\nend"}}
{"id": "leetcode_2810", "url": "https://leetcode.com/problems/faulty-keyboard/", "title": "Faulty Keyboard", "description": "Your laptop keyboard is faulty, and whenever you type a character `'i'` on it, it reverses the string that you have written. Typing other characters works as expected.\n\n\nYou are given a **0-indexed** string `s`, and you type each character of `s` using your faulty keyboard.\n\n\nReturn *the final string that will be present on your laptop screen.*", "examples": ["**Input:** s = \"string\"\n**Output:** \"rtsng\"\n**Explanation:** \nAfter typing first character, the text on the screen is \"s\".\nAfter the second character, the text is \"st\". \nAfter the third character, the text is \"str\".\nSince the fourth character is an 'i', the text gets reversed and becomes \"rts\".\nAfter the fifth character, the text is \"rtsn\". \nAfter the sixth character, the text is \"rtsng\". \nTherefore, we return \"rtsng\".", "**Input:** s = \"poiinter\"\n**Output:** \"ponter\"\n**Explanation:** \nAfter the first character, the text on the screen is \"p\".\nAfter the second character, the text is \"po\". \nSince the third character you type is an 'i', the text gets reversed and becomes \"op\". \nSince the fourth character you type is an 'i', the text gets reversed and becomes \"po\".\nAfter the fifth character, the text is \"pon\".\nAfter the sixth character, the text is \"pont\". \nAfter the seventh character, the text is \"ponte\". \nAfter the eighth character, the text is \"ponter\". \nTherefore, we return \"ponter\"."], "constraints": "**Constraints:**\n\n\n* `1 <= s.length <= 100`\n* `s` consists of lowercase English letters.\n* `s[0] != 'i'`", "difficulty": "Easy", "tags": ["String", "Simulation"], "hints": ["Try to build a new string by traversing the given string and reversing whenever you get the character \u2018i\u2019."], "templates": {"cpp": "class Solution {\npublic:\n    string finalString(string s) {\n        \n    }\n};", "java": "class Solution {\n    public String finalString(String s) {\n        \n    }\n}", "python": "class Solution(object):\n    def finalString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        ", "python3": "class Solution:\n    def finalString(self, s: str) -> str:\n        ", "c": "char* finalString(char* s) {\n    \n}", "csharp": "public class Solution {\n    public string FinalString(string s) {\n        \n    }\n}", "javascript": "/**\n * @param {string} s\n * @return {string}\n */\nvar finalString = function(s) {\n    \n};", "typescript": "function finalString(s: string): string {\n    \n};", "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @return String\n     */\n    function finalString($s) {\n        \n    }\n}", "swift": "class Solution {\n    func finalString(_ s: String) -> String {\n        \n    }\n}", "kotlin": "class Solution {\n    fun finalString(s: String): String {\n        \n    }\n}", "dart": "class Solution {\n  String finalString(String s) {\n    \n  }\n}", "golang": "func finalString(s string) string {\n    \n}", "ruby": "# @param {String} s\n# @return {String}\ndef final_string(s)\n    \nend", "scala": "object Solution {\n    def finalString(s: String): String = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn final_string(s: String) -> String {\n        \n    }\n}", "racket": "(define/contract (final-string s)\n  (-> string? string?)\n  )", "erlang": "-spec final_string(S :: unicode:unicode_binary()) -> unicode:unicode_binary().\nfinal_string(S) ->\n  .", "elixir": "defmodule Solution do\n  @spec final_string(s :: String.t) :: String.t\n  def final_string(s) do\n    \n  end\nend"}}
{"id": "leetcode_2778", "url": "https://leetcode.com/problems/sum-of-squares-of-special-elements/", "title": "Sum of Squares of Special Elements ", "description": "You are given a **1-indexed** integer array `nums` of length `n`.\n\n\nAn element `nums[i]` of `nums` is called **special** if `i` divides `n`, i.e. `n % i == 0`.\n\n\nReturn *the **sum of the squares** of all **special** elements of* `nums`.", "examples": ["**Input:** nums = [1,2,3,4]\n**Output:** 21\n**Explanation:** There are exactly 3 special elements in nums: nums[1] since 1 divides 4, nums[2] since 2 divides 4, and nums[4] since 4 divides 4. \nHence, the sum of the squares of all special elements of nums is nums[1] * nums[1] + nums[2] * nums[2] + nums[4] * nums[4] = 1 * 1 + 2 * 2 + 4 * 4 = 21.", "**Input:** nums = [2,7,1,19,18,3]\n**Output:** 63\n**Explanation:** There are exactly 4 special elements in nums: nums[1] since 1 divides 6, nums[2] since 2 divides 6, nums[3] since 3 divides 6, and nums[6] since 6 divides 6. \nHence, the sum of the squares of all special elements of nums is nums[1] * nums[1] + nums[2] * nums[2] + nums[3] * nums[3] + nums[6] * nums[6] = 2 * 2 + 7 * 7 + 1 * 1 + 3 * 3 = 63."], "constraints": "**Constraints:**\n\n\n* `1 <= nums.length == n <= 50`\n* `1 <= nums[i] <= 50`", "difficulty": "Easy", "tags": ["Array", "Simulation"], "hints": ["Iterate over all the elements of the array. For each index i, check if it is special using the modulo operator.", "if n%i == 0, index i is special and you should add nums[i] to the answer."], "templates": {"cpp": "class Solution {\npublic:\n    int sumOfSquares(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public int sumOfSquares(int[] nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def sumOfSquares(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ", "python3": "class Solution:\n    def sumOfSquares(self, nums: List[int]) -> int:\n        ", "c": "int sumOfSquares(int* nums, int numsSize){\n\n}", "csharp": "public class Solution {\n    public int SumOfSquares(int[] nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar sumOfSquares = function(nums) {\n    \n};", "typescript": "function sumOfSquares(nums: number[]): number {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function sumOfSquares($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func sumOfSquares(_ nums: [Int]) -> Int {\n        \n    }\n}", "kotlin": "class Solution {\n    fun sumOfSquares(nums: IntArray): Int {\n        \n    }\n}", "dart": "class Solution {\n  int sumOfSquares(List<int> nums) {\n\n  }\n}", "golang": "func sumOfSquares(nums []int) int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef sum_of_squares(nums)\n    \nend", "scala": "object Solution {\n    def sumOfSquares(nums: Array[Int]): Int = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn sum_of_squares(nums: Vec<i32>) -> i32 {\n        \n    }\n}", "racket": "(define/contract (sum-of-squares nums)\n  (-> (listof exact-integer?) exact-integer?)\n\n  )", "erlang": "-spec sum_of_squares(Nums :: [integer()]) -> integer().\nsum_of_squares(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec sum_of_squares(nums :: [integer]) :: integer\n  def sum_of_squares(nums) do\n\n  end\nend"}}
{"id": "leetcode_2670", "url": "https://leetcode.com/problems/find-the-distinct-difference-array/", "title": "Find the Distinct Difference Array", "description": "You are given a **0-indexed** array `nums` of length `n`.\n\n\nThe **distinct difference** array of `nums` is an array `diff` of length `n` such that `diff[i]` is equal to the number of distinct elements in the suffix `nums[i + 1, ..., n - 1]` **subtracted from** the number of distinct elements in the prefix `nums[0, ..., i]`.\n\n\nReturn *the **distinct difference** array of* `nums`.\n\n\nNote that `nums[i, ..., j]` denotes the subarray of `nums` starting at index `i` and ending at index `j` inclusive. Particularly, if `i > j` then `nums[i, ..., j]` denotes an empty subarray.", "examples": ["**Input:** nums = [1,2,3,4,5]\n**Output:** [-3,-1,1,3,5]\n**Explanation:** For index i = 0, there is 1 element in the prefix and 4 distinct elements in the suffix. Thus, diff[0] = 1 - 4 = -3.\nFor index i = 1, there are 2 distinct elements in the prefix and 3 distinct elements in the suffix. Thus, diff[1] = 2 - 3 = -1.\nFor index i = 2, there are 3 distinct elements in the prefix and 2 distinct elements in the suffix. Thus, diff[2] = 3 - 2 = 1.\nFor index i = 3, there are 4 distinct elements in the prefix and 1 distinct element in the suffix. Thus, diff[3] = 4 - 1 = 3.\nFor index i = 4, there are 5 distinct elements in the prefix and no elements in the suffix. Thus, diff[4] = 5 - 0 = 5.", "**Input:** nums = [3,2,3,4,2]\n**Output:** [-2,-1,0,2,3]\n**Explanation:** For index i = 0, there is 1 element in the prefix and 3 distinct elements in the suffix. Thus, diff[0] = 1 - 3 = -2.\nFor index i = 1, there are 2 distinct elements in the prefix and 3 distinct elements in the suffix. Thus, diff[1] = 2 - 3 = -1.\nFor index i = 2, there are 2 distinct elements in the prefix and 2 distinct elements in the suffix. Thus, diff[2] = 2 - 2 = 0.\nFor index i = 3, there are 3 distinct elements in the prefix and 1 distinct element in the suffix. Thus, diff[3] = 3 - 1 = 2.\nFor index i = 4, there are 3 distinct elements in the prefix and no elements in the suffix. Thus, diff[4] = 3 - 0 = 3."], "constraints": "**Constraints:**\n\n\n* `1 <= n == nums.length\u00a0<= 50`\n* `1 <= nums[i] <= 50`", "difficulty": "Easy", "tags": ["Array", "Hash Table"], "hints": ["Which data structure will help you maintain distinct elements?", "Iterate over all possible prefix sizes. Then, use a nested loop to add the elements of the prefix to a set, and another nested loop to add the elements of the suffix to another set."], "templates": {"cpp": "class Solution {\npublic:\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\n        \n    }\n};", "java": "class Solution {\n    public int[] distinctDifferenceArray(int[] nums) {\n        \n    }\n}", "python": "class Solution(object):\n    def distinctDifferenceArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        ", "python3": "class Solution:\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\n        ", "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* distinctDifferenceArray(int* nums, int numsSize, int* returnSize){\n\n}", "csharp": "public class Solution {\n    public int[] DistinctDifferenceArray(int[] nums) {\n        \n    }\n}", "javascript": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar distinctDifferenceArray = function(nums) {\n    \n};", "typescript": "function distinctDifferenceArray(nums: number[]): number[] {\n\n};", "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer[]\n     */\n    function distinctDifferenceArray($nums) {\n        \n    }\n}", "swift": "class Solution {\n    func distinctDifferenceArray(_ nums: [Int]) -> [Int] {\n        \n    }\n}", "kotlin": "class Solution {\n    fun distinctDifferenceArray(nums: IntArray): IntArray {\n        \n    }\n}", "dart": "class Solution {\n  List<int> distinctDifferenceArray(List<int> nums) {\n\n  }\n}", "golang": "func distinctDifferenceArray(nums []int) []int {\n    \n}", "ruby": "# @param {Integer[]} nums\n# @return {Integer[]}\ndef distinct_difference_array(nums)\n    \nend", "scala": "object Solution {\n    def distinctDifferenceArray(nums: Array[Int]): Array[Int] = {\n        \n    }\n}", "rust": "impl Solution {\n    pub fn distinct_difference_array(nums: Vec<i32>) -> Vec<i32> {\n        \n    }\n}", "racket": "(define/contract (distinct-difference-array nums)\n  (-> (listof exact-integer?) (listof exact-integer?))\n\n  )", "erlang": "-spec distinct_difference_array(Nums :: [integer()]) -> [integer()].\ndistinct_difference_array(Nums) ->\n  .", "elixir": "defmodule Solution do\n  @spec distinct_difference_array(nums :: [integer]) :: [integer]\n  def distinct_difference_array(nums) do\n\n  end\nend"}}
